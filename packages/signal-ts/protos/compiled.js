/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const signalservice = $root.signalservice = (() => {

    /**
     * Namespace signalservice.
     * @exports signalservice
     * @namespace
     */
    const signalservice = {};

    signalservice.ProvisioningUuid = (function() {

        /**
         * Properties of a ProvisioningUuid.
         * @memberof signalservice
         * @interface IProvisioningUuid
         * @property {string|null} [uuid] ProvisioningUuid uuid
         */

        /**
         * Constructs a new ProvisioningUuid.
         * @memberof signalservice
         * @classdesc Represents a ProvisioningUuid.
         * @implements IProvisioningUuid
         * @constructor
         * @param {signalservice.IProvisioningUuid=} [properties] Properties to set
         */
        function ProvisioningUuid(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProvisioningUuid uuid.
         * @member {string} uuid
         * @memberof signalservice.ProvisioningUuid
         * @instance
         */
        ProvisioningUuid.prototype.uuid = "";

        /**
         * Creates a new ProvisioningUuid instance using the specified properties.
         * @function create
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.IProvisioningUuid=} [properties] Properties to set
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid instance
         */
        ProvisioningUuid.create = function create(properties) {
            return new ProvisioningUuid(properties);
        };

        /**
         * Encodes the specified ProvisioningUuid message. Does not implicitly {@link signalservice.ProvisioningUuid.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.IProvisioningUuid} message ProvisioningUuid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisioningUuid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uuid);
            return writer;
        };

        /**
         * Encodes the specified ProvisioningUuid message, length delimited. Does not implicitly {@link signalservice.ProvisioningUuid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.IProvisioningUuid} message ProvisioningUuid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisioningUuid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProvisioningUuid message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisioningUuid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ProvisioningUuid();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uuid = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProvisioningUuid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisioningUuid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProvisioningUuid message.
         * @function verify
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProvisioningUuid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                if (!$util.isString(message.uuid))
                    return "uuid: string expected";
            return null;
        };

        /**
         * Creates a ProvisioningUuid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ProvisioningUuid} ProvisioningUuid
         */
        ProvisioningUuid.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ProvisioningUuid)
                return object;
            let message = new $root.signalservice.ProvisioningUuid();
            if (object.uuid != null)
                message.uuid = String(object.uuid);
            return message;
        };

        /**
         * Creates a plain object from a ProvisioningUuid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {signalservice.ProvisioningUuid} message ProvisioningUuid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProvisioningUuid.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.uuid = "";
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                object.uuid = message.uuid;
            return object;
        };

        /**
         * Converts this ProvisioningUuid to JSON.
         * @function toJSON
         * @memberof signalservice.ProvisioningUuid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProvisioningUuid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProvisioningUuid
         * @function getTypeUrl
         * @memberof signalservice.ProvisioningUuid
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProvisioningUuid.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.ProvisioningUuid";
        };

        return ProvisioningUuid;
    })();

    signalservice.ProvisionEnvelope = (function() {

        /**
         * Properties of a ProvisionEnvelope.
         * @memberof signalservice
         * @interface IProvisionEnvelope
         * @property {Uint8Array|null} [publicKey] ProvisionEnvelope publicKey
         * @property {Uint8Array|null} [body] ProvisionEnvelope body
         */

        /**
         * Constructs a new ProvisionEnvelope.
         * @memberof signalservice
         * @classdesc Represents a ProvisionEnvelope.
         * @implements IProvisionEnvelope
         * @constructor
         * @param {signalservice.IProvisionEnvelope=} [properties] Properties to set
         */
        function ProvisionEnvelope(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProvisionEnvelope publicKey.
         * @member {Uint8Array} publicKey
         * @memberof signalservice.ProvisionEnvelope
         * @instance
         */
        ProvisionEnvelope.prototype.publicKey = $util.newBuffer([]);

        /**
         * ProvisionEnvelope body.
         * @member {Uint8Array} body
         * @memberof signalservice.ProvisionEnvelope
         * @instance
         */
        ProvisionEnvelope.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new ProvisionEnvelope instance using the specified properties.
         * @function create
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.IProvisionEnvelope=} [properties] Properties to set
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope instance
         */
        ProvisionEnvelope.create = function create(properties) {
            return new ProvisionEnvelope(properties);
        };

        /**
         * Encodes the specified ProvisionEnvelope message. Does not implicitly {@link signalservice.ProvisionEnvelope.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.IProvisionEnvelope} message ProvisionEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.body);
            return writer;
        };

        /**
         * Encodes the specified ProvisionEnvelope message, length delimited. Does not implicitly {@link signalservice.ProvisionEnvelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.IProvisionEnvelope} message ProvisionEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProvisionEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ProvisionEnvelope();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.publicKey = reader.bytes();
                        break;
                    }
                case 2: {
                        message.body = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProvisionEnvelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionEnvelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProvisionEnvelope message.
         * @function verify
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProvisionEnvelope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a ProvisionEnvelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ProvisionEnvelope} ProvisionEnvelope
         */
        ProvisionEnvelope.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ProvisionEnvelope)
                return object;
            let message = new $root.signalservice.ProvisionEnvelope();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length >= 0)
                    message.publicKey = object.publicKey;
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length >= 0)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a ProvisionEnvelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {signalservice.ProvisionEnvelope} message ProvisionEnvelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProvisionEnvelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this ProvisionEnvelope to JSON.
         * @function toJSON
         * @memberof signalservice.ProvisionEnvelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProvisionEnvelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProvisionEnvelope
         * @function getTypeUrl
         * @memberof signalservice.ProvisionEnvelope
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProvisionEnvelope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.ProvisionEnvelope";
        };

        return ProvisionEnvelope;
    })();

    signalservice.ProvisionMessage = (function() {

        /**
         * Properties of a ProvisionMessage.
         * @memberof signalservice
         * @interface IProvisionMessage
         * @property {Uint8Array|null} [aciIdentityKeyPublic] ProvisionMessage aciIdentityKeyPublic
         * @property {Uint8Array|null} [aciIdentityKeyPrivate] ProvisionMessage aciIdentityKeyPrivate
         * @property {Uint8Array|null} [pniIdentityKeyPublic] ProvisionMessage pniIdentityKeyPublic
         * @property {Uint8Array|null} [pniIdentityKeyPrivate] ProvisionMessage pniIdentityKeyPrivate
         * @property {string|null} [aci] ProvisionMessage aci
         * @property {string|null} [pni] ProvisionMessage pni
         * @property {string|null} [number] ProvisionMessage number
         * @property {string|null} [provisioningCode] ProvisionMessage provisioningCode
         * @property {string|null} [userAgent] ProvisionMessage userAgent
         * @property {Uint8Array|null} [profileKey] ProvisionMessage profileKey
         * @property {boolean|null} [readReceipts] ProvisionMessage readReceipts
         * @property {number|null} [ProvisioningVersion] ProvisionMessage ProvisioningVersion
         * @property {Uint8Array|null} [masterKey] ProvisionMessage masterKey
         */

        /**
         * Constructs a new ProvisionMessage.
         * @memberof signalservice
         * @classdesc Represents a ProvisionMessage.
         * @implements IProvisionMessage
         * @constructor
         * @param {signalservice.IProvisionMessage=} [properties] Properties to set
         */
        function ProvisionMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProvisionMessage aciIdentityKeyPublic.
         * @member {Uint8Array} aciIdentityKeyPublic
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.aciIdentityKeyPublic = $util.newBuffer([]);

        /**
         * ProvisionMessage aciIdentityKeyPrivate.
         * @member {Uint8Array} aciIdentityKeyPrivate
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.aciIdentityKeyPrivate = $util.newBuffer([]);

        /**
         * ProvisionMessage pniIdentityKeyPublic.
         * @member {Uint8Array} pniIdentityKeyPublic
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.pniIdentityKeyPublic = $util.newBuffer([]);

        /**
         * ProvisionMessage pniIdentityKeyPrivate.
         * @member {Uint8Array} pniIdentityKeyPrivate
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.pniIdentityKeyPrivate = $util.newBuffer([]);

        /**
         * ProvisionMessage aci.
         * @member {string} aci
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.aci = "";

        /**
         * ProvisionMessage pni.
         * @member {string} pni
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.pni = "";

        /**
         * ProvisionMessage number.
         * @member {string} number
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.number = "";

        /**
         * ProvisionMessage provisioningCode.
         * @member {string} provisioningCode
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.provisioningCode = "";

        /**
         * ProvisionMessage userAgent.
         * @member {string} userAgent
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.userAgent = "";

        /**
         * ProvisionMessage profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.profileKey = $util.newBuffer([]);

        /**
         * ProvisionMessage readReceipts.
         * @member {boolean} readReceipts
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.readReceipts = false;

        /**
         * ProvisionMessage ProvisioningVersion.
         * @member {number} ProvisioningVersion
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.ProvisioningVersion = 0;

        /**
         * ProvisionMessage masterKey.
         * @member {Uint8Array} masterKey
         * @memberof signalservice.ProvisionMessage
         * @instance
         */
        ProvisionMessage.prototype.masterKey = $util.newBuffer([]);

        /**
         * Creates a new ProvisionMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.IProvisionMessage=} [properties] Properties to set
         * @returns {signalservice.ProvisionMessage} ProvisionMessage instance
         */
        ProvisionMessage.create = function create(properties) {
            return new ProvisionMessage(properties);
        };

        /**
         * Encodes the specified ProvisionMessage message. Does not implicitly {@link signalservice.ProvisionMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.IProvisionMessage} message ProvisionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aciIdentityKeyPublic != null && Object.hasOwnProperty.call(message, "aciIdentityKeyPublic"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.aciIdentityKeyPublic);
            if (message.aciIdentityKeyPrivate != null && Object.hasOwnProperty.call(message, "aciIdentityKeyPrivate"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.aciIdentityKeyPrivate);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.number);
            if (message.provisioningCode != null && Object.hasOwnProperty.call(message, "provisioningCode"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.provisioningCode);
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.userAgent);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.profileKey);
            if (message.readReceipts != null && Object.hasOwnProperty.call(message, "readReceipts"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.readReceipts);
            if (message.aci != null && Object.hasOwnProperty.call(message, "aci"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.aci);
            if (message.ProvisioningVersion != null && Object.hasOwnProperty.call(message, "ProvisioningVersion"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ProvisioningVersion);
            if (message.pni != null && Object.hasOwnProperty.call(message, "pni"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.pni);
            if (message.pniIdentityKeyPublic != null && Object.hasOwnProperty.call(message, "pniIdentityKeyPublic"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.pniIdentityKeyPublic);
            if (message.pniIdentityKeyPrivate != null && Object.hasOwnProperty.call(message, "pniIdentityKeyPrivate"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.pniIdentityKeyPrivate);
            if (message.masterKey != null && Object.hasOwnProperty.call(message, "masterKey"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.masterKey);
            return writer;
        };

        /**
         * Encodes the specified ProvisionMessage message, length delimited. Does not implicitly {@link signalservice.ProvisionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.IProvisionMessage} message ProvisionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProvisionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProvisionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ProvisionMessage} ProvisionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ProvisionMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.aciIdentityKeyPublic = reader.bytes();
                        break;
                    }
                case 2: {
                        message.aciIdentityKeyPrivate = reader.bytes();
                        break;
                    }
                case 11: {
                        message.pniIdentityKeyPublic = reader.bytes();
                        break;
                    }
                case 12: {
                        message.pniIdentityKeyPrivate = reader.bytes();
                        break;
                    }
                case 8: {
                        message.aci = reader.string();
                        break;
                    }
                case 10: {
                        message.pni = reader.string();
                        break;
                    }
                case 3: {
                        message.number = reader.string();
                        break;
                    }
                case 4: {
                        message.provisioningCode = reader.string();
                        break;
                    }
                case 5: {
                        message.userAgent = reader.string();
                        break;
                    }
                case 6: {
                        message.profileKey = reader.bytes();
                        break;
                    }
                case 7: {
                        message.readReceipts = reader.bool();
                        break;
                    }
                case 9: {
                        message.ProvisioningVersion = reader.uint32();
                        break;
                    }
                case 13: {
                        message.masterKey = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProvisionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ProvisionMessage} ProvisionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProvisionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProvisionMessage message.
         * @function verify
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProvisionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aciIdentityKeyPublic != null && message.hasOwnProperty("aciIdentityKeyPublic"))
                if (!(message.aciIdentityKeyPublic && typeof message.aciIdentityKeyPublic.length === "number" || $util.isString(message.aciIdentityKeyPublic)))
                    return "aciIdentityKeyPublic: buffer expected";
            if (message.aciIdentityKeyPrivate != null && message.hasOwnProperty("aciIdentityKeyPrivate"))
                if (!(message.aciIdentityKeyPrivate && typeof message.aciIdentityKeyPrivate.length === "number" || $util.isString(message.aciIdentityKeyPrivate)))
                    return "aciIdentityKeyPrivate: buffer expected";
            if (message.pniIdentityKeyPublic != null && message.hasOwnProperty("pniIdentityKeyPublic"))
                if (!(message.pniIdentityKeyPublic && typeof message.pniIdentityKeyPublic.length === "number" || $util.isString(message.pniIdentityKeyPublic)))
                    return "pniIdentityKeyPublic: buffer expected";
            if (message.pniIdentityKeyPrivate != null && message.hasOwnProperty("pniIdentityKeyPrivate"))
                if (!(message.pniIdentityKeyPrivate && typeof message.pniIdentityKeyPrivate.length === "number" || $util.isString(message.pniIdentityKeyPrivate)))
                    return "pniIdentityKeyPrivate: buffer expected";
            if (message.aci != null && message.hasOwnProperty("aci"))
                if (!$util.isString(message.aci))
                    return "aci: string expected";
            if (message.pni != null && message.hasOwnProperty("pni"))
                if (!$util.isString(message.pni))
                    return "pni: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isString(message.number))
                    return "number: string expected";
            if (message.provisioningCode != null && message.hasOwnProperty("provisioningCode"))
                if (!$util.isString(message.provisioningCode))
                    return "provisioningCode: string expected";
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                if (!(message.profileKey && typeof message.profileKey.length === "number" || $util.isString(message.profileKey)))
                    return "profileKey: buffer expected";
            if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                if (typeof message.readReceipts !== "boolean")
                    return "readReceipts: boolean expected";
            if (message.ProvisioningVersion != null && message.hasOwnProperty("ProvisioningVersion"))
                if (!$util.isInteger(message.ProvisioningVersion))
                    return "ProvisioningVersion: integer expected";
            if (message.masterKey != null && message.hasOwnProperty("masterKey"))
                if (!(message.masterKey && typeof message.masterKey.length === "number" || $util.isString(message.masterKey)))
                    return "masterKey: buffer expected";
            return null;
        };

        /**
         * Creates a ProvisionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ProvisionMessage} ProvisionMessage
         */
        ProvisionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ProvisionMessage)
                return object;
            let message = new $root.signalservice.ProvisionMessage();
            if (object.aciIdentityKeyPublic != null)
                if (typeof object.aciIdentityKeyPublic === "string")
                    $util.base64.decode(object.aciIdentityKeyPublic, message.aciIdentityKeyPublic = $util.newBuffer($util.base64.length(object.aciIdentityKeyPublic)), 0);
                else if (object.aciIdentityKeyPublic.length >= 0)
                    message.aciIdentityKeyPublic = object.aciIdentityKeyPublic;
            if (object.aciIdentityKeyPrivate != null)
                if (typeof object.aciIdentityKeyPrivate === "string")
                    $util.base64.decode(object.aciIdentityKeyPrivate, message.aciIdentityKeyPrivate = $util.newBuffer($util.base64.length(object.aciIdentityKeyPrivate)), 0);
                else if (object.aciIdentityKeyPrivate.length >= 0)
                    message.aciIdentityKeyPrivate = object.aciIdentityKeyPrivate;
            if (object.pniIdentityKeyPublic != null)
                if (typeof object.pniIdentityKeyPublic === "string")
                    $util.base64.decode(object.pniIdentityKeyPublic, message.pniIdentityKeyPublic = $util.newBuffer($util.base64.length(object.pniIdentityKeyPublic)), 0);
                else if (object.pniIdentityKeyPublic.length >= 0)
                    message.pniIdentityKeyPublic = object.pniIdentityKeyPublic;
            if (object.pniIdentityKeyPrivate != null)
                if (typeof object.pniIdentityKeyPrivate === "string")
                    $util.base64.decode(object.pniIdentityKeyPrivate, message.pniIdentityKeyPrivate = $util.newBuffer($util.base64.length(object.pniIdentityKeyPrivate)), 0);
                else if (object.pniIdentityKeyPrivate.length >= 0)
                    message.pniIdentityKeyPrivate = object.pniIdentityKeyPrivate;
            if (object.aci != null)
                message.aci = String(object.aci);
            if (object.pni != null)
                message.pni = String(object.pni);
            if (object.number != null)
                message.number = String(object.number);
            if (object.provisioningCode != null)
                message.provisioningCode = String(object.provisioningCode);
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length >= 0)
                    message.profileKey = object.profileKey;
            if (object.readReceipts != null)
                message.readReceipts = Boolean(object.readReceipts);
            if (object.ProvisioningVersion != null)
                message.ProvisioningVersion = object.ProvisioningVersion >>> 0;
            if (object.masterKey != null)
                if (typeof object.masterKey === "string")
                    $util.base64.decode(object.masterKey, message.masterKey = $util.newBuffer($util.base64.length(object.masterKey)), 0);
                else if (object.masterKey.length >= 0)
                    message.masterKey = object.masterKey;
            return message;
        };

        /**
         * Creates a plain object from a ProvisionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {signalservice.ProvisionMessage} message ProvisionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProvisionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.aciIdentityKeyPublic = "";
                else {
                    object.aciIdentityKeyPublic = [];
                    if (options.bytes !== Array)
                        object.aciIdentityKeyPublic = $util.newBuffer(object.aciIdentityKeyPublic);
                }
                if (options.bytes === String)
                    object.aciIdentityKeyPrivate = "";
                else {
                    object.aciIdentityKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.aciIdentityKeyPrivate = $util.newBuffer(object.aciIdentityKeyPrivate);
                }
                object.number = "";
                object.provisioningCode = "";
                object.userAgent = "";
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                object.readReceipts = false;
                object.aci = "";
                object.ProvisioningVersion = 0;
                object.pni = "";
                if (options.bytes === String)
                    object.pniIdentityKeyPublic = "";
                else {
                    object.pniIdentityKeyPublic = [];
                    if (options.bytes !== Array)
                        object.pniIdentityKeyPublic = $util.newBuffer(object.pniIdentityKeyPublic);
                }
                if (options.bytes === String)
                    object.pniIdentityKeyPrivate = "";
                else {
                    object.pniIdentityKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.pniIdentityKeyPrivate = $util.newBuffer(object.pniIdentityKeyPrivate);
                }
                if (options.bytes === String)
                    object.masterKey = "";
                else {
                    object.masterKey = [];
                    if (options.bytes !== Array)
                        object.masterKey = $util.newBuffer(object.masterKey);
                }
            }
            if (message.aciIdentityKeyPublic != null && message.hasOwnProperty("aciIdentityKeyPublic"))
                object.aciIdentityKeyPublic = options.bytes === String ? $util.base64.encode(message.aciIdentityKeyPublic, 0, message.aciIdentityKeyPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.aciIdentityKeyPublic) : message.aciIdentityKeyPublic;
            if (message.aciIdentityKeyPrivate != null && message.hasOwnProperty("aciIdentityKeyPrivate"))
                object.aciIdentityKeyPrivate = options.bytes === String ? $util.base64.encode(message.aciIdentityKeyPrivate, 0, message.aciIdentityKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.aciIdentityKeyPrivate) : message.aciIdentityKeyPrivate;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.provisioningCode != null && message.hasOwnProperty("provisioningCode"))
                object.provisioningCode = message.provisioningCode;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                object.readReceipts = message.readReceipts;
            if (message.aci != null && message.hasOwnProperty("aci"))
                object.aci = message.aci;
            if (message.ProvisioningVersion != null && message.hasOwnProperty("ProvisioningVersion"))
                object.ProvisioningVersion = message.ProvisioningVersion;
            if (message.pni != null && message.hasOwnProperty("pni"))
                object.pni = message.pni;
            if (message.pniIdentityKeyPublic != null && message.hasOwnProperty("pniIdentityKeyPublic"))
                object.pniIdentityKeyPublic = options.bytes === String ? $util.base64.encode(message.pniIdentityKeyPublic, 0, message.pniIdentityKeyPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.pniIdentityKeyPublic) : message.pniIdentityKeyPublic;
            if (message.pniIdentityKeyPrivate != null && message.hasOwnProperty("pniIdentityKeyPrivate"))
                object.pniIdentityKeyPrivate = options.bytes === String ? $util.base64.encode(message.pniIdentityKeyPrivate, 0, message.pniIdentityKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.pniIdentityKeyPrivate) : message.pniIdentityKeyPrivate;
            if (message.masterKey != null && message.hasOwnProperty("masterKey"))
                object.masterKey = options.bytes === String ? $util.base64.encode(message.masterKey, 0, message.masterKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterKey) : message.masterKey;
            return object;
        };

        /**
         * Converts this ProvisionMessage to JSON.
         * @function toJSON
         * @memberof signalservice.ProvisionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProvisionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProvisionMessage
         * @function getTypeUrl
         * @memberof signalservice.ProvisionMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProvisionMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.ProvisionMessage";
        };

        return ProvisionMessage;
    })();

    /**
     * ProvisioningVersion enum.
     * @name signalservice.ProvisioningVersion
     * @enum {number}
     * @property {number} INITIAL=0 INITIAL value
     * @property {number} TABLET_SUPPORT=1 TABLET_SUPPORT value
     * @property {number} CURRENT=1 CURRENT value
     */
    signalservice.ProvisioningVersion = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INITIAL"] = 0;
        values[valuesById[1] = "TABLET_SUPPORT"] = 1;
        values["CURRENT"] = 1;
        return values;
    })();

    signalservice.DeviceName = (function() {

        /**
         * Properties of a DeviceName.
         * @memberof signalservice
         * @interface IDeviceName
         * @property {Uint8Array|null} [ephemeralPublic] DeviceName ephemeralPublic
         * @property {Uint8Array|null} [syntheticIv] DeviceName syntheticIv
         * @property {Uint8Array|null} [ciphertext] DeviceName ciphertext
         */

        /**
         * Constructs a new DeviceName.
         * @memberof signalservice
         * @classdesc Represents a DeviceName.
         * @implements IDeviceName
         * @constructor
         * @param {signalservice.IDeviceName=} [properties] Properties to set
         */
        function DeviceName(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceName ephemeralPublic.
         * @member {Uint8Array} ephemeralPublic
         * @memberof signalservice.DeviceName
         * @instance
         */
        DeviceName.prototype.ephemeralPublic = $util.newBuffer([]);

        /**
         * DeviceName syntheticIv.
         * @member {Uint8Array} syntheticIv
         * @memberof signalservice.DeviceName
         * @instance
         */
        DeviceName.prototype.syntheticIv = $util.newBuffer([]);

        /**
         * DeviceName ciphertext.
         * @member {Uint8Array} ciphertext
         * @memberof signalservice.DeviceName
         * @instance
         */
        DeviceName.prototype.ciphertext = $util.newBuffer([]);

        /**
         * Creates a new DeviceName instance using the specified properties.
         * @function create
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.IDeviceName=} [properties] Properties to set
         * @returns {signalservice.DeviceName} DeviceName instance
         */
        DeviceName.create = function create(properties) {
            return new DeviceName(properties);
        };

        /**
         * Encodes the specified DeviceName message. Does not implicitly {@link signalservice.DeviceName.verify|verify} messages.
         * @function encode
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.IDeviceName} message DeviceName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceName.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ephemeralPublic != null && Object.hasOwnProperty.call(message, "ephemeralPublic"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeralPublic);
            if (message.syntheticIv != null && Object.hasOwnProperty.call(message, "syntheticIv"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.syntheticIv);
            if (message.ciphertext != null && Object.hasOwnProperty.call(message, "ciphertext"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ciphertext);
            return writer;
        };

        /**
         * Encodes the specified DeviceName message, length delimited. Does not implicitly {@link signalservice.DeviceName.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.IDeviceName} message DeviceName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceName.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceName message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.DeviceName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.DeviceName} DeviceName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DeviceName();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ephemeralPublic = reader.bytes();
                        break;
                    }
                case 2: {
                        message.syntheticIv = reader.bytes();
                        break;
                    }
                case 3: {
                        message.ciphertext = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceName message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.DeviceName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.DeviceName} DeviceName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceName.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceName message.
         * @function verify
         * @memberof signalservice.DeviceName
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceName.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ephemeralPublic != null && message.hasOwnProperty("ephemeralPublic"))
                if (!(message.ephemeralPublic && typeof message.ephemeralPublic.length === "number" || $util.isString(message.ephemeralPublic)))
                    return "ephemeralPublic: buffer expected";
            if (message.syntheticIv != null && message.hasOwnProperty("syntheticIv"))
                if (!(message.syntheticIv && typeof message.syntheticIv.length === "number" || $util.isString(message.syntheticIv)))
                    return "syntheticIv: buffer expected";
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                if (!(message.ciphertext && typeof message.ciphertext.length === "number" || $util.isString(message.ciphertext)))
                    return "ciphertext: buffer expected";
            return null;
        };

        /**
         * Creates a DeviceName message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.DeviceName
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.DeviceName} DeviceName
         */
        DeviceName.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.DeviceName)
                return object;
            let message = new $root.signalservice.DeviceName();
            if (object.ephemeralPublic != null)
                if (typeof object.ephemeralPublic === "string")
                    $util.base64.decode(object.ephemeralPublic, message.ephemeralPublic = $util.newBuffer($util.base64.length(object.ephemeralPublic)), 0);
                else if (object.ephemeralPublic.length >= 0)
                    message.ephemeralPublic = object.ephemeralPublic;
            if (object.syntheticIv != null)
                if (typeof object.syntheticIv === "string")
                    $util.base64.decode(object.syntheticIv, message.syntheticIv = $util.newBuffer($util.base64.length(object.syntheticIv)), 0);
                else if (object.syntheticIv.length >= 0)
                    message.syntheticIv = object.syntheticIv;
            if (object.ciphertext != null)
                if (typeof object.ciphertext === "string")
                    $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);
                else if (object.ciphertext.length >= 0)
                    message.ciphertext = object.ciphertext;
            return message;
        };

        /**
         * Creates a plain object from a DeviceName message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.DeviceName
         * @static
         * @param {signalservice.DeviceName} message DeviceName
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceName.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ephemeralPublic = "";
                else {
                    object.ephemeralPublic = [];
                    if (options.bytes !== Array)
                        object.ephemeralPublic = $util.newBuffer(object.ephemeralPublic);
                }
                if (options.bytes === String)
                    object.syntheticIv = "";
                else {
                    object.syntheticIv = [];
                    if (options.bytes !== Array)
                        object.syntheticIv = $util.newBuffer(object.syntheticIv);
                }
                if (options.bytes === String)
                    object.ciphertext = "";
                else {
                    object.ciphertext = [];
                    if (options.bytes !== Array)
                        object.ciphertext = $util.newBuffer(object.ciphertext);
                }
            }
            if (message.ephemeralPublic != null && message.hasOwnProperty("ephemeralPublic"))
                object.ephemeralPublic = options.bytes === String ? $util.base64.encode(message.ephemeralPublic, 0, message.ephemeralPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralPublic) : message.ephemeralPublic;
            if (message.syntheticIv != null && message.hasOwnProperty("syntheticIv"))
                object.syntheticIv = options.bytes === String ? $util.base64.encode(message.syntheticIv, 0, message.syntheticIv.length) : options.bytes === Array ? Array.prototype.slice.call(message.syntheticIv) : message.syntheticIv;
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;
            return object;
        };

        /**
         * Converts this DeviceName to JSON.
         * @function toJSON
         * @memberof signalservice.DeviceName
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceName.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeviceName
         * @function getTypeUrl
         * @memberof signalservice.DeviceName
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeviceName.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.DeviceName";
        };

        return DeviceName;
    })();

    signalservice.Envelope = (function() {

        /**
         * Properties of an Envelope.
         * @memberof signalservice
         * @interface IEnvelope
         * @property {signalservice.Envelope.Type|null} [type] Envelope type
         * @property {string|null} [sourceServiceId] Envelope sourceServiceId
         * @property {number|null} [sourceDevice] Envelope sourceDevice
         * @property {string|null} [destinationServiceId] Envelope destinationServiceId
         * @property {number|Long|null} [timestamp] Envelope timestamp
         * @property {Uint8Array|null} [content] Envelope content
         * @property {string|null} [serverGuid] Envelope serverGuid
         * @property {number|Long|null} [serverTimestamp] Envelope serverTimestamp
         * @property {boolean|null} [ephemeral] Envelope ephemeral
         * @property {boolean|null} [urgent] Envelope urgent
         * @property {string|null} [updatedPni] Envelope updatedPni
         * @property {boolean|null} [story] Envelope story
         * @property {Uint8Array|null} [reportingToken] Envelope reportingToken
         */

        /**
         * Constructs a new Envelope.
         * @memberof signalservice
         * @classdesc Represents an Envelope.
         * @implements IEnvelope
         * @constructor
         * @param {signalservice.IEnvelope=} [properties] Properties to set
         */
        function Envelope(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Envelope type.
         * @member {signalservice.Envelope.Type} type
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.type = 0;

        /**
         * Envelope sourceServiceId.
         * @member {string} sourceServiceId
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.sourceServiceId = "";

        /**
         * Envelope sourceDevice.
         * @member {number} sourceDevice
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.sourceDevice = 0;

        /**
         * Envelope destinationServiceId.
         * @member {string} destinationServiceId
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.destinationServiceId = "";

        /**
         * Envelope timestamp.
         * @member {number|Long} timestamp
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Envelope content.
         * @member {Uint8Array} content
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.content = $util.newBuffer([]);

        /**
         * Envelope serverGuid.
         * @member {string} serverGuid
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.serverGuid = "";

        /**
         * Envelope serverTimestamp.
         * @member {number|Long} serverTimestamp
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.serverTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Envelope ephemeral.
         * @member {boolean} ephemeral
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.ephemeral = false;

        /**
         * Envelope urgent.
         * @member {boolean} urgent
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.urgent = true;

        /**
         * Envelope updatedPni.
         * @member {string} updatedPni
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.updatedPni = "";

        /**
         * Envelope story.
         * @member {boolean} story
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.story = false;

        /**
         * Envelope reportingToken.
         * @member {Uint8Array} reportingToken
         * @memberof signalservice.Envelope
         * @instance
         */
        Envelope.prototype.reportingToken = $util.newBuffer([]);

        /**
         * Creates a new Envelope instance using the specified properties.
         * @function create
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.IEnvelope=} [properties] Properties to set
         * @returns {signalservice.Envelope} Envelope instance
         */
        Envelope.create = function create(properties) {
            return new Envelope(properties);
        };

        /**
         * Encodes the specified Envelope message. Does not implicitly {@link signalservice.Envelope.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.IEnvelope} message Envelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Envelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.timestamp);
            if (message.sourceDevice != null && Object.hasOwnProperty.call(message, "sourceDevice"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.sourceDevice);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.content);
            if (message.serverGuid != null && Object.hasOwnProperty.call(message, "serverGuid"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.serverGuid);
            if (message.serverTimestamp != null && Object.hasOwnProperty.call(message, "serverTimestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.serverTimestamp);
            if (message.sourceServiceId != null && Object.hasOwnProperty.call(message, "sourceServiceId"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.sourceServiceId);
            if (message.ephemeral != null && Object.hasOwnProperty.call(message, "ephemeral"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.ephemeral);
            if (message.destinationServiceId != null && Object.hasOwnProperty.call(message, "destinationServiceId"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.destinationServiceId);
            if (message.urgent != null && Object.hasOwnProperty.call(message, "urgent"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.urgent);
            if (message.updatedPni != null && Object.hasOwnProperty.call(message, "updatedPni"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.updatedPni);
            if (message.story != null && Object.hasOwnProperty.call(message, "story"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.story);
            if (message.reportingToken != null && Object.hasOwnProperty.call(message, "reportingToken"))
                writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.reportingToken);
            return writer;
        };

        /**
         * Encodes the specified Envelope message, length delimited. Does not implicitly {@link signalservice.Envelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.IEnvelope} message Envelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Envelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Envelope message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Envelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Envelope} Envelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Envelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Envelope();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 11: {
                        message.sourceServiceId = reader.string();
                        break;
                    }
                case 7: {
                        message.sourceDevice = reader.uint32();
                        break;
                    }
                case 13: {
                        message.destinationServiceId = reader.string();
                        break;
                    }
                case 5: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                case 8: {
                        message.content = reader.bytes();
                        break;
                    }
                case 9: {
                        message.serverGuid = reader.string();
                        break;
                    }
                case 10: {
                        message.serverTimestamp = reader.uint64();
                        break;
                    }
                case 12: {
                        message.ephemeral = reader.bool();
                        break;
                    }
                case 14: {
                        message.urgent = reader.bool();
                        break;
                    }
                case 15: {
                        message.updatedPni = reader.string();
                        break;
                    }
                case 16: {
                        message.story = reader.bool();
                        break;
                    }
                case 17: {
                        message.reportingToken = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Envelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Envelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Envelope} Envelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Envelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Envelope message.
         * @function verify
         * @memberof signalservice.Envelope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Envelope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 5:
                case 6:
                case 8:
                    break;
                }
            if (message.sourceServiceId != null && message.hasOwnProperty("sourceServiceId"))
                if (!$util.isString(message.sourceServiceId))
                    return "sourceServiceId: string expected";
            if (message.sourceDevice != null && message.hasOwnProperty("sourceDevice"))
                if (!$util.isInteger(message.sourceDevice))
                    return "sourceDevice: integer expected";
            if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                if (!$util.isString(message.destinationServiceId))
                    return "destinationServiceId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            if (message.serverGuid != null && message.hasOwnProperty("serverGuid"))
                if (!$util.isString(message.serverGuid))
                    return "serverGuid: string expected";
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                if (!$util.isInteger(message.serverTimestamp) && !(message.serverTimestamp && $util.isInteger(message.serverTimestamp.low) && $util.isInteger(message.serverTimestamp.high)))
                    return "serverTimestamp: integer|Long expected";
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                if (typeof message.ephemeral !== "boolean")
                    return "ephemeral: boolean expected";
            if (message.urgent != null && message.hasOwnProperty("urgent"))
                if (typeof message.urgent !== "boolean")
                    return "urgent: boolean expected";
            if (message.updatedPni != null && message.hasOwnProperty("updatedPni"))
                if (!$util.isString(message.updatedPni))
                    return "updatedPni: string expected";
            if (message.story != null && message.hasOwnProperty("story"))
                if (typeof message.story !== "boolean")
                    return "story: boolean expected";
            if (message.reportingToken != null && message.hasOwnProperty("reportingToken"))
                if (!(message.reportingToken && typeof message.reportingToken.length === "number" || $util.isString(message.reportingToken)))
                    return "reportingToken: buffer expected";
            return null;
        };

        /**
         * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Envelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Envelope} Envelope
         */
        Envelope.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Envelope)
                return object;
            let message = new $root.signalservice.Envelope();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "CIPHERTEXT":
            case 1:
                message.type = 1;
                break;
            case "KEY_EXCHANGE":
            case 2:
                message.type = 2;
                break;
            case "PREKEY_BUNDLE":
            case 3:
                message.type = 3;
                break;
            case "RECEIPT":
            case 5:
                message.type = 5;
                break;
            case "UNIDENTIFIED_SENDER":
            case 6:
                message.type = 6;
                break;
            case "PLAINTEXT_CONTENT":
            case 8:
                message.type = 8;
                break;
            }
            if (object.sourceServiceId != null)
                message.sourceServiceId = String(object.sourceServiceId);
            if (object.sourceDevice != null)
                message.sourceDevice = object.sourceDevice >>> 0;
            if (object.destinationServiceId != null)
                message.destinationServiceId = String(object.destinationServiceId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length >= 0)
                    message.content = object.content;
            if (object.serverGuid != null)
                message.serverGuid = String(object.serverGuid);
            if (object.serverTimestamp != null)
                if ($util.Long)
                    (message.serverTimestamp = $util.Long.fromValue(object.serverTimestamp)).unsigned = true;
                else if (typeof object.serverTimestamp === "string")
                    message.serverTimestamp = parseInt(object.serverTimestamp, 10);
                else if (typeof object.serverTimestamp === "number")
                    message.serverTimestamp = object.serverTimestamp;
                else if (typeof object.serverTimestamp === "object")
                    message.serverTimestamp = new $util.LongBits(object.serverTimestamp.low >>> 0, object.serverTimestamp.high >>> 0).toNumber(true);
            if (object.ephemeral != null)
                message.ephemeral = Boolean(object.ephemeral);
            if (object.urgent != null)
                message.urgent = Boolean(object.urgent);
            if (object.updatedPni != null)
                message.updatedPni = String(object.updatedPni);
            if (object.story != null)
                message.story = Boolean(object.story);
            if (object.reportingToken != null)
                if (typeof object.reportingToken === "string")
                    $util.base64.decode(object.reportingToken, message.reportingToken = $util.newBuffer($util.base64.length(object.reportingToken)), 0);
                else if (object.reportingToken.length >= 0)
                    message.reportingToken = object.reportingToken;
            return message;
        };

        /**
         * Creates a plain object from an Envelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Envelope
         * @static
         * @param {signalservice.Envelope} message Envelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Envelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.sourceDevice = 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
                object.serverGuid = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serverTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTimestamp = options.longs === String ? "0" : 0;
                object.sourceServiceId = "";
                object.ephemeral = false;
                object.destinationServiceId = "";
                object.urgent = true;
                object.updatedPni = "";
                object.story = false;
                if (options.bytes === String)
                    object.reportingToken = "";
                else {
                    object.reportingToken = [];
                    if (options.bytes !== Array)
                        object.reportingToken = $util.newBuffer(object.reportingToken);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.Envelope.Type[message.type] === undefined ? message.type : $root.signalservice.Envelope.Type[message.type] : message.type;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.sourceDevice != null && message.hasOwnProperty("sourceDevice"))
                object.sourceDevice = message.sourceDevice;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            if (message.serverGuid != null && message.hasOwnProperty("serverGuid"))
                object.serverGuid = message.serverGuid;
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                if (typeof message.serverTimestamp === "number")
                    object.serverTimestamp = options.longs === String ? String(message.serverTimestamp) : message.serverTimestamp;
                else
                    object.serverTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimestamp) : options.longs === Number ? new $util.LongBits(message.serverTimestamp.low >>> 0, message.serverTimestamp.high >>> 0).toNumber(true) : message.serverTimestamp;
            if (message.sourceServiceId != null && message.hasOwnProperty("sourceServiceId"))
                object.sourceServiceId = message.sourceServiceId;
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                object.ephemeral = message.ephemeral;
            if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                object.destinationServiceId = message.destinationServiceId;
            if (message.urgent != null && message.hasOwnProperty("urgent"))
                object.urgent = message.urgent;
            if (message.updatedPni != null && message.hasOwnProperty("updatedPni"))
                object.updatedPni = message.updatedPni;
            if (message.story != null && message.hasOwnProperty("story"))
                object.story = message.story;
            if (message.reportingToken != null && message.hasOwnProperty("reportingToken"))
                object.reportingToken = options.bytes === String ? $util.base64.encode(message.reportingToken, 0, message.reportingToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.reportingToken) : message.reportingToken;
            return object;
        };

        /**
         * Converts this Envelope to JSON.
         * @function toJSON
         * @memberof signalservice.Envelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Envelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Envelope
         * @function getTypeUrl
         * @memberof signalservice.Envelope
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Envelope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.Envelope";
        };

        /**
         * Type enum.
         * @name signalservice.Envelope.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CIPHERTEXT=1 CIPHERTEXT value
         * @property {number} KEY_EXCHANGE=2 KEY_EXCHANGE value
         * @property {number} PREKEY_BUNDLE=3 PREKEY_BUNDLE value
         * @property {number} RECEIPT=5 RECEIPT value
         * @property {number} UNIDENTIFIED_SENDER=6 UNIDENTIFIED_SENDER value
         * @property {number} PLAINTEXT_CONTENT=8 PLAINTEXT_CONTENT value
         */
        Envelope.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CIPHERTEXT"] = 1;
            values[valuesById[2] = "KEY_EXCHANGE"] = 2;
            values[valuesById[3] = "PREKEY_BUNDLE"] = 3;
            values[valuesById[5] = "RECEIPT"] = 5;
            values[valuesById[6] = "UNIDENTIFIED_SENDER"] = 6;
            values[valuesById[8] = "PLAINTEXT_CONTENT"] = 8;
            return values;
        })();

        return Envelope;
    })();

    signalservice.Content = (function() {

        /**
         * Properties of a Content.
         * @memberof signalservice
         * @interface IContent
         * @property {signalservice.IDataMessage|null} [dataMessage] Content dataMessage
         * @property {signalservice.ISyncMessage|null} [syncMessage] Content syncMessage
         * @property {signalservice.ICallingMessage|null} [callingMessage] Content callingMessage
         * @property {signalservice.INullMessage|null} [nullMessage] Content nullMessage
         * @property {signalservice.IReceiptMessage|null} [receiptMessage] Content receiptMessage
         * @property {signalservice.ITypingMessage|null} [typingMessage] Content typingMessage
         * @property {Uint8Array|null} [senderKeyDistributionMessage] Content senderKeyDistributionMessage
         * @property {Uint8Array|null} [decryptionErrorMessage] Content decryptionErrorMessage
         * @property {signalservice.IStoryMessage|null} [storyMessage] Content storyMessage
         * @property {signalservice.IPniSignatureMessage|null} [pniSignatureMessage] Content pniSignatureMessage
         * @property {signalservice.IEditMessage|null} [editMessage] Content editMessage
         */

        /**
         * Constructs a new Content.
         * @memberof signalservice
         * @classdesc Represents a Content.
         * @implements IContent
         * @constructor
         * @param {signalservice.IContent=} [properties] Properties to set
         */
        function Content(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Content dataMessage.
         * @member {signalservice.IDataMessage|null|undefined} dataMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.dataMessage = null;

        /**
         * Content syncMessage.
         * @member {signalservice.ISyncMessage|null|undefined} syncMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.syncMessage = null;

        /**
         * Content callingMessage.
         * @member {signalservice.ICallingMessage|null|undefined} callingMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.callingMessage = null;

        /**
         * Content nullMessage.
         * @member {signalservice.INullMessage|null|undefined} nullMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.nullMessage = null;

        /**
         * Content receiptMessage.
         * @member {signalservice.IReceiptMessage|null|undefined} receiptMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.receiptMessage = null;

        /**
         * Content typingMessage.
         * @member {signalservice.ITypingMessage|null|undefined} typingMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.typingMessage = null;

        /**
         * Content senderKeyDistributionMessage.
         * @member {Uint8Array} senderKeyDistributionMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.senderKeyDistributionMessage = $util.newBuffer([]);

        /**
         * Content decryptionErrorMessage.
         * @member {Uint8Array} decryptionErrorMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.decryptionErrorMessage = $util.newBuffer([]);

        /**
         * Content storyMessage.
         * @member {signalservice.IStoryMessage|null|undefined} storyMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.storyMessage = null;

        /**
         * Content pniSignatureMessage.
         * @member {signalservice.IPniSignatureMessage|null|undefined} pniSignatureMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.pniSignatureMessage = null;

        /**
         * Content editMessage.
         * @member {signalservice.IEditMessage|null|undefined} editMessage
         * @memberof signalservice.Content
         * @instance
         */
        Content.prototype.editMessage = null;

        /**
         * Creates a new Content instance using the specified properties.
         * @function create
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.IContent=} [properties] Properties to set
         * @returns {signalservice.Content} Content instance
         */
        Content.create = function create(properties) {
            return new Content(properties);
        };

        /**
         * Encodes the specified Content message. Does not implicitly {@link signalservice.Content.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.IContent} message Content message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Content.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dataMessage != null && Object.hasOwnProperty.call(message, "dataMessage"))
                $root.signalservice.DataMessage.encode(message.dataMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.syncMessage != null && Object.hasOwnProperty.call(message, "syncMessage"))
                $root.signalservice.SyncMessage.encode(message.syncMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callingMessage != null && Object.hasOwnProperty.call(message, "callingMessage"))
                $root.signalservice.CallingMessage.encode(message.callingMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.nullMessage != null && Object.hasOwnProperty.call(message, "nullMessage"))
                $root.signalservice.NullMessage.encode(message.nullMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.receiptMessage != null && Object.hasOwnProperty.call(message, "receiptMessage"))
                $root.signalservice.ReceiptMessage.encode(message.receiptMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.typingMessage != null && Object.hasOwnProperty.call(message, "typingMessage"))
                $root.signalservice.TypingMessage.encode(message.typingMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "senderKeyDistributionMessage"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.senderKeyDistributionMessage);
            if (message.decryptionErrorMessage != null && Object.hasOwnProperty.call(message, "decryptionErrorMessage"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.decryptionErrorMessage);
            if (message.storyMessage != null && Object.hasOwnProperty.call(message, "storyMessage"))
                $root.signalservice.StoryMessage.encode(message.storyMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.pniSignatureMessage != null && Object.hasOwnProperty.call(message, "pniSignatureMessage"))
                $root.signalservice.PniSignatureMessage.encode(message.pniSignatureMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.editMessage != null && Object.hasOwnProperty.call(message, "editMessage"))
                $root.signalservice.EditMessage.encode(message.editMessage, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Content message, length delimited. Does not implicitly {@link signalservice.Content.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.IContent} message Content message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Content.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Content message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Content
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Content} Content
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Content.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Content();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dataMessage = $root.signalservice.DataMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.syncMessage = $root.signalservice.SyncMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.callingMessage = $root.signalservice.CallingMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.nullMessage = $root.signalservice.NullMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.receiptMessage = $root.signalservice.ReceiptMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.typingMessage = $root.signalservice.TypingMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.senderKeyDistributionMessage = reader.bytes();
                        break;
                    }
                case 8: {
                        message.decryptionErrorMessage = reader.bytes();
                        break;
                    }
                case 9: {
                        message.storyMessage = $root.signalservice.StoryMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.pniSignatureMessage = $root.signalservice.PniSignatureMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.editMessage = $root.signalservice.EditMessage.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Content message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Content
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Content} Content
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Content.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Content message.
         * @function verify
         * @memberof signalservice.Content
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Content.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dataMessage != null && message.hasOwnProperty("dataMessage")) {
                let error = $root.signalservice.DataMessage.verify(message.dataMessage);
                if (error)
                    return "dataMessage." + error;
            }
            if (message.syncMessage != null && message.hasOwnProperty("syncMessage")) {
                let error = $root.signalservice.SyncMessage.verify(message.syncMessage);
                if (error)
                    return "syncMessage." + error;
            }
            if (message.callingMessage != null && message.hasOwnProperty("callingMessage")) {
                let error = $root.signalservice.CallingMessage.verify(message.callingMessage);
                if (error)
                    return "callingMessage." + error;
            }
            if (message.nullMessage != null && message.hasOwnProperty("nullMessage")) {
                let error = $root.signalservice.NullMessage.verify(message.nullMessage);
                if (error)
                    return "nullMessage." + error;
            }
            if (message.receiptMessage != null && message.hasOwnProperty("receiptMessage")) {
                let error = $root.signalservice.ReceiptMessage.verify(message.receiptMessage);
                if (error)
                    return "receiptMessage." + error;
            }
            if (message.typingMessage != null && message.hasOwnProperty("typingMessage")) {
                let error = $root.signalservice.TypingMessage.verify(message.typingMessage);
                if (error)
                    return "typingMessage." + error;
            }
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage"))
                if (!(message.senderKeyDistributionMessage && typeof message.senderKeyDistributionMessage.length === "number" || $util.isString(message.senderKeyDistributionMessage)))
                    return "senderKeyDistributionMessage: buffer expected";
            if (message.decryptionErrorMessage != null && message.hasOwnProperty("decryptionErrorMessage"))
                if (!(message.decryptionErrorMessage && typeof message.decryptionErrorMessage.length === "number" || $util.isString(message.decryptionErrorMessage)))
                    return "decryptionErrorMessage: buffer expected";
            if (message.storyMessage != null && message.hasOwnProperty("storyMessage")) {
                let error = $root.signalservice.StoryMessage.verify(message.storyMessage);
                if (error)
                    return "storyMessage." + error;
            }
            if (message.pniSignatureMessage != null && message.hasOwnProperty("pniSignatureMessage")) {
                let error = $root.signalservice.PniSignatureMessage.verify(message.pniSignatureMessage);
                if (error)
                    return "pniSignatureMessage." + error;
            }
            if (message.editMessage != null && message.hasOwnProperty("editMessage")) {
                let error = $root.signalservice.EditMessage.verify(message.editMessage);
                if (error)
                    return "editMessage." + error;
            }
            return null;
        };

        /**
         * Creates a Content message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Content
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Content} Content
         */
        Content.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Content)
                return object;
            let message = new $root.signalservice.Content();
            if (object.dataMessage != null) {
                if (typeof object.dataMessage !== "object")
                    throw TypeError(".signalservice.Content.dataMessage: object expected");
                message.dataMessage = $root.signalservice.DataMessage.fromObject(object.dataMessage);
            }
            if (object.syncMessage != null) {
                if (typeof object.syncMessage !== "object")
                    throw TypeError(".signalservice.Content.syncMessage: object expected");
                message.syncMessage = $root.signalservice.SyncMessage.fromObject(object.syncMessage);
            }
            if (object.callingMessage != null) {
                if (typeof object.callingMessage !== "object")
                    throw TypeError(".signalservice.Content.callingMessage: object expected");
                message.callingMessage = $root.signalservice.CallingMessage.fromObject(object.callingMessage);
            }
            if (object.nullMessage != null) {
                if (typeof object.nullMessage !== "object")
                    throw TypeError(".signalservice.Content.nullMessage: object expected");
                message.nullMessage = $root.signalservice.NullMessage.fromObject(object.nullMessage);
            }
            if (object.receiptMessage != null) {
                if (typeof object.receiptMessage !== "object")
                    throw TypeError(".signalservice.Content.receiptMessage: object expected");
                message.receiptMessage = $root.signalservice.ReceiptMessage.fromObject(object.receiptMessage);
            }
            if (object.typingMessage != null) {
                if (typeof object.typingMessage !== "object")
                    throw TypeError(".signalservice.Content.typingMessage: object expected");
                message.typingMessage = $root.signalservice.TypingMessage.fromObject(object.typingMessage);
            }
            if (object.senderKeyDistributionMessage != null)
                if (typeof object.senderKeyDistributionMessage === "string")
                    $util.base64.decode(object.senderKeyDistributionMessage, message.senderKeyDistributionMessage = $util.newBuffer($util.base64.length(object.senderKeyDistributionMessage)), 0);
                else if (object.senderKeyDistributionMessage.length >= 0)
                    message.senderKeyDistributionMessage = object.senderKeyDistributionMessage;
            if (object.decryptionErrorMessage != null)
                if (typeof object.decryptionErrorMessage === "string")
                    $util.base64.decode(object.decryptionErrorMessage, message.decryptionErrorMessage = $util.newBuffer($util.base64.length(object.decryptionErrorMessage)), 0);
                else if (object.decryptionErrorMessage.length >= 0)
                    message.decryptionErrorMessage = object.decryptionErrorMessage;
            if (object.storyMessage != null) {
                if (typeof object.storyMessage !== "object")
                    throw TypeError(".signalservice.Content.storyMessage: object expected");
                message.storyMessage = $root.signalservice.StoryMessage.fromObject(object.storyMessage);
            }
            if (object.pniSignatureMessage != null) {
                if (typeof object.pniSignatureMessage !== "object")
                    throw TypeError(".signalservice.Content.pniSignatureMessage: object expected");
                message.pniSignatureMessage = $root.signalservice.PniSignatureMessage.fromObject(object.pniSignatureMessage);
            }
            if (object.editMessage != null) {
                if (typeof object.editMessage !== "object")
                    throw TypeError(".signalservice.Content.editMessage: object expected");
                message.editMessage = $root.signalservice.EditMessage.fromObject(object.editMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from a Content message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Content
         * @static
         * @param {signalservice.Content} message Content
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Content.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.dataMessage = null;
                object.syncMessage = null;
                object.callingMessage = null;
                object.nullMessage = null;
                object.receiptMessage = null;
                object.typingMessage = null;
                if (options.bytes === String)
                    object.senderKeyDistributionMessage = "";
                else {
                    object.senderKeyDistributionMessage = [];
                    if (options.bytes !== Array)
                        object.senderKeyDistributionMessage = $util.newBuffer(object.senderKeyDistributionMessage);
                }
                if (options.bytes === String)
                    object.decryptionErrorMessage = "";
                else {
                    object.decryptionErrorMessage = [];
                    if (options.bytes !== Array)
                        object.decryptionErrorMessage = $util.newBuffer(object.decryptionErrorMessage);
                }
                object.storyMessage = null;
                object.pniSignatureMessage = null;
                object.editMessage = null;
            }
            if (message.dataMessage != null && message.hasOwnProperty("dataMessage"))
                object.dataMessage = $root.signalservice.DataMessage.toObject(message.dataMessage, options);
            if (message.syncMessage != null && message.hasOwnProperty("syncMessage"))
                object.syncMessage = $root.signalservice.SyncMessage.toObject(message.syncMessage, options);
            if (message.callingMessage != null && message.hasOwnProperty("callingMessage"))
                object.callingMessage = $root.signalservice.CallingMessage.toObject(message.callingMessage, options);
            if (message.nullMessage != null && message.hasOwnProperty("nullMessage"))
                object.nullMessage = $root.signalservice.NullMessage.toObject(message.nullMessage, options);
            if (message.receiptMessage != null && message.hasOwnProperty("receiptMessage"))
                object.receiptMessage = $root.signalservice.ReceiptMessage.toObject(message.receiptMessage, options);
            if (message.typingMessage != null && message.hasOwnProperty("typingMessage"))
                object.typingMessage = $root.signalservice.TypingMessage.toObject(message.typingMessage, options);
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage"))
                object.senderKeyDistributionMessage = options.bytes === String ? $util.base64.encode(message.senderKeyDistributionMessage, 0, message.senderKeyDistributionMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderKeyDistributionMessage) : message.senderKeyDistributionMessage;
            if (message.decryptionErrorMessage != null && message.hasOwnProperty("decryptionErrorMessage"))
                object.decryptionErrorMessage = options.bytes === String ? $util.base64.encode(message.decryptionErrorMessage, 0, message.decryptionErrorMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.decryptionErrorMessage) : message.decryptionErrorMessage;
            if (message.storyMessage != null && message.hasOwnProperty("storyMessage"))
                object.storyMessage = $root.signalservice.StoryMessage.toObject(message.storyMessage, options);
            if (message.pniSignatureMessage != null && message.hasOwnProperty("pniSignatureMessage"))
                object.pniSignatureMessage = $root.signalservice.PniSignatureMessage.toObject(message.pniSignatureMessage, options);
            if (message.editMessage != null && message.hasOwnProperty("editMessage"))
                object.editMessage = $root.signalservice.EditMessage.toObject(message.editMessage, options);
            return object;
        };

        /**
         * Converts this Content to JSON.
         * @function toJSON
         * @memberof signalservice.Content
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Content.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Content
         * @function getTypeUrl
         * @memberof signalservice.Content
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Content.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.Content";
        };

        return Content;
    })();

    signalservice.CallingMessage = (function() {

        /**
         * Properties of a CallingMessage.
         * @memberof signalservice
         * @interface ICallingMessage
         * @property {signalservice.CallingMessage.IOffer|null} [offer] CallingMessage offer
         * @property {signalservice.CallingMessage.IAnswer|null} [answer] CallingMessage answer
         * @property {Array.<signalservice.CallingMessage.IIceCandidate>|null} [iceCandidates] CallingMessage iceCandidates
         * @property {signalservice.CallingMessage.IBusy|null} [busy] CallingMessage busy
         * @property {signalservice.CallingMessage.IHangup|null} [hangup] CallingMessage hangup
         * @property {number|null} [destinationDeviceId] CallingMessage destinationDeviceId
         * @property {signalservice.CallingMessage.IOpaque|null} [opaque] CallingMessage opaque
         */

        /**
         * Constructs a new CallingMessage.
         * @memberof signalservice
         * @classdesc Represents a CallingMessage.
         * @implements ICallingMessage
         * @constructor
         * @param {signalservice.ICallingMessage=} [properties] Properties to set
         */
        function CallingMessage(properties) {
            this.iceCandidates = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallingMessage offer.
         * @member {signalservice.CallingMessage.IOffer|null|undefined} offer
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.offer = null;

        /**
         * CallingMessage answer.
         * @member {signalservice.CallingMessage.IAnswer|null|undefined} answer
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.answer = null;

        /**
         * CallingMessage iceCandidates.
         * @member {Array.<signalservice.CallingMessage.IIceCandidate>} iceCandidates
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.iceCandidates = $util.emptyArray;

        /**
         * CallingMessage busy.
         * @member {signalservice.CallingMessage.IBusy|null|undefined} busy
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.busy = null;

        /**
         * CallingMessage hangup.
         * @member {signalservice.CallingMessage.IHangup|null|undefined} hangup
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.hangup = null;

        /**
         * CallingMessage destinationDeviceId.
         * @member {number} destinationDeviceId
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.destinationDeviceId = 0;

        /**
         * CallingMessage opaque.
         * @member {signalservice.CallingMessage.IOpaque|null|undefined} opaque
         * @memberof signalservice.CallingMessage
         * @instance
         */
        CallingMessage.prototype.opaque = null;

        /**
         * Creates a new CallingMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.ICallingMessage=} [properties] Properties to set
         * @returns {signalservice.CallingMessage} CallingMessage instance
         */
        CallingMessage.create = function create(properties) {
            return new CallingMessage(properties);
        };

        /**
         * Encodes the specified CallingMessage message. Does not implicitly {@link signalservice.CallingMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.ICallingMessage} message CallingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
                $root.signalservice.CallingMessage.Offer.encode(message.offer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.answer != null && Object.hasOwnProperty.call(message, "answer"))
                $root.signalservice.CallingMessage.Answer.encode(message.answer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.iceCandidates != null && message.iceCandidates.length)
                for (let i = 0; i < message.iceCandidates.length; ++i)
                    $root.signalservice.CallingMessage.IceCandidate.encode(message.iceCandidates[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.busy != null && Object.hasOwnProperty.call(message, "busy"))
                $root.signalservice.CallingMessage.Busy.encode(message.busy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.hangup != null && Object.hasOwnProperty.call(message, "hangup"))
                $root.signalservice.CallingMessage.Hangup.encode(message.hangup, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.destinationDeviceId != null && Object.hasOwnProperty.call(message, "destinationDeviceId"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.destinationDeviceId);
            if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                $root.signalservice.CallingMessage.Opaque.encode(message.opaque, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CallingMessage message, length delimited. Does not implicitly {@link signalservice.CallingMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.ICallingMessage} message CallingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.CallingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.CallingMessage} CallingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.offer = $root.signalservice.CallingMessage.Offer.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.answer = $root.signalservice.CallingMessage.Answer.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.iceCandidates && message.iceCandidates.length))
                            message.iceCandidates = [];
                        message.iceCandidates.push($root.signalservice.CallingMessage.IceCandidate.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.busy = $root.signalservice.CallingMessage.Busy.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.hangup = $root.signalservice.CallingMessage.Hangup.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.destinationDeviceId = reader.uint32();
                        break;
                    }
                case 10: {
                        message.opaque = $root.signalservice.CallingMessage.Opaque.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallingMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.CallingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.CallingMessage} CallingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallingMessage message.
         * @function verify
         * @memberof signalservice.CallingMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallingMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.offer != null && message.hasOwnProperty("offer")) {
                let error = $root.signalservice.CallingMessage.Offer.verify(message.offer);
                if (error)
                    return "offer." + error;
            }
            if (message.answer != null && message.hasOwnProperty("answer")) {
                let error = $root.signalservice.CallingMessage.Answer.verify(message.answer);
                if (error)
                    return "answer." + error;
            }
            if (message.iceCandidates != null && message.hasOwnProperty("iceCandidates")) {
                if (!Array.isArray(message.iceCandidates))
                    return "iceCandidates: array expected";
                for (let i = 0; i < message.iceCandidates.length; ++i) {
                    let error = $root.signalservice.CallingMessage.IceCandidate.verify(message.iceCandidates[i]);
                    if (error)
                        return "iceCandidates." + error;
                }
            }
            if (message.busy != null && message.hasOwnProperty("busy")) {
                let error = $root.signalservice.CallingMessage.Busy.verify(message.busy);
                if (error)
                    return "busy." + error;
            }
            if (message.hangup != null && message.hasOwnProperty("hangup")) {
                let error = $root.signalservice.CallingMessage.Hangup.verify(message.hangup);
                if (error)
                    return "hangup." + error;
            }
            if (message.destinationDeviceId != null && message.hasOwnProperty("destinationDeviceId"))
                if (!$util.isInteger(message.destinationDeviceId))
                    return "destinationDeviceId: integer expected";
            if (message.opaque != null && message.hasOwnProperty("opaque")) {
                let error = $root.signalservice.CallingMessage.Opaque.verify(message.opaque);
                if (error)
                    return "opaque." + error;
            }
            return null;
        };

        /**
         * Creates a CallingMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.CallingMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.CallingMessage} CallingMessage
         */
        CallingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.CallingMessage)
                return object;
            let message = new $root.signalservice.CallingMessage();
            if (object.offer != null) {
                if (typeof object.offer !== "object")
                    throw TypeError(".signalservice.CallingMessage.offer: object expected");
                message.offer = $root.signalservice.CallingMessage.Offer.fromObject(object.offer);
            }
            if (object.answer != null) {
                if (typeof object.answer !== "object")
                    throw TypeError(".signalservice.CallingMessage.answer: object expected");
                message.answer = $root.signalservice.CallingMessage.Answer.fromObject(object.answer);
            }
            if (object.iceCandidates) {
                if (!Array.isArray(object.iceCandidates))
                    throw TypeError(".signalservice.CallingMessage.iceCandidates: array expected");
                message.iceCandidates = [];
                for (let i = 0; i < object.iceCandidates.length; ++i) {
                    if (typeof object.iceCandidates[i] !== "object")
                        throw TypeError(".signalservice.CallingMessage.iceCandidates: object expected");
                    message.iceCandidates[i] = $root.signalservice.CallingMessage.IceCandidate.fromObject(object.iceCandidates[i]);
                }
            }
            if (object.busy != null) {
                if (typeof object.busy !== "object")
                    throw TypeError(".signalservice.CallingMessage.busy: object expected");
                message.busy = $root.signalservice.CallingMessage.Busy.fromObject(object.busy);
            }
            if (object.hangup != null) {
                if (typeof object.hangup !== "object")
                    throw TypeError(".signalservice.CallingMessage.hangup: object expected");
                message.hangup = $root.signalservice.CallingMessage.Hangup.fromObject(object.hangup);
            }
            if (object.destinationDeviceId != null)
                message.destinationDeviceId = object.destinationDeviceId >>> 0;
            if (object.opaque != null) {
                if (typeof object.opaque !== "object")
                    throw TypeError(".signalservice.CallingMessage.opaque: object expected");
                message.opaque = $root.signalservice.CallingMessage.Opaque.fromObject(object.opaque);
            }
            return message;
        };

        /**
         * Creates a plain object from a CallingMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.CallingMessage
         * @static
         * @param {signalservice.CallingMessage} message CallingMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.iceCandidates = [];
            if (options.defaults) {
                object.offer = null;
                object.answer = null;
                object.busy = null;
                object.hangup = null;
                object.destinationDeviceId = 0;
                object.opaque = null;
            }
            if (message.offer != null && message.hasOwnProperty("offer"))
                object.offer = $root.signalservice.CallingMessage.Offer.toObject(message.offer, options);
            if (message.answer != null && message.hasOwnProperty("answer"))
                object.answer = $root.signalservice.CallingMessage.Answer.toObject(message.answer, options);
            if (message.iceCandidates && message.iceCandidates.length) {
                object.iceCandidates = [];
                for (let j = 0; j < message.iceCandidates.length; ++j)
                    object.iceCandidates[j] = $root.signalservice.CallingMessage.IceCandidate.toObject(message.iceCandidates[j], options);
            }
            if (message.busy != null && message.hasOwnProperty("busy"))
                object.busy = $root.signalservice.CallingMessage.Busy.toObject(message.busy, options);
            if (message.hangup != null && message.hasOwnProperty("hangup"))
                object.hangup = $root.signalservice.CallingMessage.Hangup.toObject(message.hangup, options);
            if (message.destinationDeviceId != null && message.hasOwnProperty("destinationDeviceId"))
                object.destinationDeviceId = message.destinationDeviceId;
            if (message.opaque != null && message.hasOwnProperty("opaque"))
                object.opaque = $root.signalservice.CallingMessage.Opaque.toObject(message.opaque, options);
            return object;
        };

        /**
         * Converts this CallingMessage to JSON.
         * @function toJSON
         * @memberof signalservice.CallingMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CallingMessage
         * @function getTypeUrl
         * @memberof signalservice.CallingMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CallingMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.CallingMessage";
        };

        CallingMessage.Offer = (function() {

            /**
             * Properties of an Offer.
             * @memberof signalservice.CallingMessage
             * @interface IOffer
             * @property {number|Long|null} [callId] Offer callId
             * @property {signalservice.CallingMessage.Offer.Type|null} [type] Offer type
             * @property {Uint8Array|null} [opaque] Offer opaque
             */

            /**
             * Constructs a new Offer.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an Offer.
             * @implements IOffer
             * @constructor
             * @param {signalservice.CallingMessage.IOffer=} [properties] Properties to set
             */
            function Offer(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Offer callId.
             * @member {number|Long} callId
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Offer type.
             * @member {signalservice.CallingMessage.Offer.Type} type
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.type = 0;

            /**
             * Offer opaque.
             * @member {Uint8Array} opaque
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             */
            Offer.prototype.opaque = $util.newBuffer([]);

            /**
             * Creates a new Offer instance using the specified properties.
             * @function create
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.IOffer=} [properties] Properties to set
             * @returns {signalservice.CallingMessage.Offer} Offer instance
             */
            Offer.create = function create(properties) {
                return new Offer(properties);
            };

            /**
             * Encodes the specified Offer message. Does not implicitly {@link signalservice.CallingMessage.Offer.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.IOffer} message Offer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Offer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.opaque);
                return writer;
            };

            /**
             * Encodes the specified Offer message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Offer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.IOffer} message Offer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Offer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Offer message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Offer} Offer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Offer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Offer();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.callId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.type = reader.int32();
                            break;
                        }
                    case 4: {
                            message.opaque = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Offer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Offer} Offer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Offer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Offer message.
             * @function verify
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Offer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    if (!(message.opaque && typeof message.opaque.length === "number" || $util.isString(message.opaque)))
                        return "opaque: buffer expected";
                return null;
            };

            /**
             * Creates an Offer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Offer} Offer
             */
            Offer.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Offer)
                    return object;
                let message = new $root.signalservice.CallingMessage.Offer();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "OFFER_AUDIO_CALL":
                case 0:
                    message.type = 0;
                    break;
                case "OFFER_VIDEO_CALL":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.opaque != null)
                    if (typeof object.opaque === "string")
                        $util.base64.decode(object.opaque, message.opaque = $util.newBuffer($util.base64.length(object.opaque)), 0);
                    else if (object.opaque.length >= 0)
                        message.opaque = object.opaque;
                return message;
            };

            /**
             * Creates a plain object from an Offer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {signalservice.CallingMessage.Offer} message Offer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Offer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "OFFER_AUDIO_CALL" : 0;
                    if (options.bytes === String)
                        object.opaque = "";
                    else {
                        object.opaque = [];
                        if (options.bytes !== Array)
                            object.opaque = $util.newBuffer(object.opaque);
                    }
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.CallingMessage.Offer.Type[message.type] === undefined ? message.type : $root.signalservice.CallingMessage.Offer.Type[message.type] : message.type;
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    object.opaque = options.bytes === String ? $util.base64.encode(message.opaque, 0, message.opaque.length) : options.bytes === Array ? Array.prototype.slice.call(message.opaque) : message.opaque;
                return object;
            };

            /**
             * Converts this Offer to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Offer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Offer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Offer
             * @function getTypeUrl
             * @memberof signalservice.CallingMessage.Offer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Offer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.CallingMessage.Offer";
            };

            /**
             * Type enum.
             * @name signalservice.CallingMessage.Offer.Type
             * @enum {number}
             * @property {number} OFFER_AUDIO_CALL=0 OFFER_AUDIO_CALL value
             * @property {number} OFFER_VIDEO_CALL=1 OFFER_VIDEO_CALL value
             */
            Offer.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OFFER_AUDIO_CALL"] = 0;
                values[valuesById[1] = "OFFER_VIDEO_CALL"] = 1;
                return values;
            })();

            return Offer;
        })();

        CallingMessage.Answer = (function() {

            /**
             * Properties of an Answer.
             * @memberof signalservice.CallingMessage
             * @interface IAnswer
             * @property {number|Long|null} [callId] Answer callId
             * @property {Uint8Array|null} [opaque] Answer opaque
             */

            /**
             * Constructs a new Answer.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an Answer.
             * @implements IAnswer
             * @constructor
             * @param {signalservice.CallingMessage.IAnswer=} [properties] Properties to set
             */
            function Answer(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Answer callId.
             * @member {number|Long} callId
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             */
            Answer.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Answer opaque.
             * @member {Uint8Array} opaque
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             */
            Answer.prototype.opaque = $util.newBuffer([]);

            /**
             * Creates a new Answer instance using the specified properties.
             * @function create
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.IAnswer=} [properties] Properties to set
             * @returns {signalservice.CallingMessage.Answer} Answer instance
             */
            Answer.create = function create(properties) {
                return new Answer(properties);
            };

            /**
             * Encodes the specified Answer message. Does not implicitly {@link signalservice.CallingMessage.Answer.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.IAnswer} message Answer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Answer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.opaque);
                return writer;
            };

            /**
             * Encodes the specified Answer message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Answer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.IAnswer} message Answer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Answer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Answer message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Answer} Answer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Answer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Answer();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.callId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.opaque = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Answer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Answer} Answer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Answer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Answer message.
             * @function verify
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Answer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    if (!(message.opaque && typeof message.opaque.length === "number" || $util.isString(message.opaque)))
                        return "opaque: buffer expected";
                return null;
            };

            /**
             * Creates an Answer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Answer} Answer
             */
            Answer.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Answer)
                    return object;
                let message = new $root.signalservice.CallingMessage.Answer();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                if (object.opaque != null)
                    if (typeof object.opaque === "string")
                        $util.base64.decode(object.opaque, message.opaque = $util.newBuffer($util.base64.length(object.opaque)), 0);
                    else if (object.opaque.length >= 0)
                        message.opaque = object.opaque;
                return message;
            };

            /**
             * Creates a plain object from an Answer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {signalservice.CallingMessage.Answer} message Answer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Answer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.opaque = "";
                    else {
                        object.opaque = [];
                        if (options.bytes !== Array)
                            object.opaque = $util.newBuffer(object.opaque);
                    }
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    object.opaque = options.bytes === String ? $util.base64.encode(message.opaque, 0, message.opaque.length) : options.bytes === Array ? Array.prototype.slice.call(message.opaque) : message.opaque;
                return object;
            };

            /**
             * Converts this Answer to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Answer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Answer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Answer
             * @function getTypeUrl
             * @memberof signalservice.CallingMessage.Answer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Answer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.CallingMessage.Answer";
            };

            return Answer;
        })();

        CallingMessage.IceCandidate = (function() {

            /**
             * Properties of an IceCandidate.
             * @memberof signalservice.CallingMessage
             * @interface IIceCandidate
             * @property {number|Long|null} [callId] IceCandidate callId
             * @property {Uint8Array|null} [opaque] IceCandidate opaque
             */

            /**
             * Constructs a new IceCandidate.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an IceCandidate.
             * @implements IIceCandidate
             * @constructor
             * @param {signalservice.CallingMessage.IIceCandidate=} [properties] Properties to set
             */
            function IceCandidate(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IceCandidate callId.
             * @member {number|Long} callId
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * IceCandidate opaque.
             * @member {Uint8Array} opaque
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             */
            IceCandidate.prototype.opaque = $util.newBuffer([]);

            /**
             * Creates a new IceCandidate instance using the specified properties.
             * @function create
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IIceCandidate=} [properties] Properties to set
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate instance
             */
            IceCandidate.create = function create(properties) {
                return new IceCandidate(properties);
            };

            /**
             * Encodes the specified IceCandidate message. Does not implicitly {@link signalservice.CallingMessage.IceCandidate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IIceCandidate} message IceCandidate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IceCandidate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.opaque != null && Object.hasOwnProperty.call(message, "opaque"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.opaque);
                return writer;
            };

            /**
             * Encodes the specified IceCandidate message, length delimited. Does not implicitly {@link signalservice.CallingMessage.IceCandidate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IIceCandidate} message IceCandidate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IceCandidate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IceCandidate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IceCandidate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.IceCandidate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.callId = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.opaque = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IceCandidate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IceCandidate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IceCandidate message.
             * @function verify
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IceCandidate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    if (!(message.opaque && typeof message.opaque.length === "number" || $util.isString(message.opaque)))
                        return "opaque: buffer expected";
                return null;
            };

            /**
             * Creates an IceCandidate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.IceCandidate} IceCandidate
             */
            IceCandidate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.IceCandidate)
                    return object;
                let message = new $root.signalservice.CallingMessage.IceCandidate();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                if (object.opaque != null)
                    if (typeof object.opaque === "string")
                        $util.base64.decode(object.opaque, message.opaque = $util.newBuffer($util.base64.length(object.opaque)), 0);
                    else if (object.opaque.length >= 0)
                        message.opaque = object.opaque;
                return message;
            };

            /**
             * Creates a plain object from an IceCandidate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {signalservice.CallingMessage.IceCandidate} message IceCandidate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IceCandidate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.opaque = "";
                    else {
                        object.opaque = [];
                        if (options.bytes !== Array)
                            object.opaque = $util.newBuffer(object.opaque);
                    }
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.opaque != null && message.hasOwnProperty("opaque"))
                    object.opaque = options.bytes === String ? $util.base64.encode(message.opaque, 0, message.opaque.length) : options.bytes === Array ? Array.prototype.slice.call(message.opaque) : message.opaque;
                return object;
            };

            /**
             * Converts this IceCandidate to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.IceCandidate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IceCandidate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IceCandidate
             * @function getTypeUrl
             * @memberof signalservice.CallingMessage.IceCandidate
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IceCandidate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.CallingMessage.IceCandidate";
            };

            return IceCandidate;
        })();

        CallingMessage.Busy = (function() {

            /**
             * Properties of a Busy.
             * @memberof signalservice.CallingMessage
             * @interface IBusy
             * @property {number|Long|null} [callId] Busy callId
             */

            /**
             * Constructs a new Busy.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents a Busy.
             * @implements IBusy
             * @constructor
             * @param {signalservice.CallingMessage.IBusy=} [properties] Properties to set
             */
            function Busy(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Busy callId.
             * @member {number|Long} callId
             * @memberof signalservice.CallingMessage.Busy
             * @instance
             */
            Busy.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Busy instance using the specified properties.
             * @function create
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.IBusy=} [properties] Properties to set
             * @returns {signalservice.CallingMessage.Busy} Busy instance
             */
            Busy.create = function create(properties) {
                return new Busy(properties);
            };

            /**
             * Encodes the specified Busy message. Does not implicitly {@link signalservice.CallingMessage.Busy.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.IBusy} message Busy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Busy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                return writer;
            };

            /**
             * Encodes the specified Busy message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Busy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.IBusy} message Busy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Busy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Busy message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Busy} Busy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Busy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Busy();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.callId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Busy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Busy} Busy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Busy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Busy message.
             * @function verify
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Busy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                return null;
            };

            /**
             * Creates a Busy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Busy} Busy
             */
            Busy.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Busy)
                    return object;
                let message = new $root.signalservice.CallingMessage.Busy();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Busy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {signalservice.CallingMessage.Busy} message Busy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Busy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                return object;
            };

            /**
             * Converts this Busy to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Busy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Busy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Busy
             * @function getTypeUrl
             * @memberof signalservice.CallingMessage.Busy
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Busy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.CallingMessage.Busy";
            };

            return Busy;
        })();

        CallingMessage.Hangup = (function() {

            /**
             * Properties of a Hangup.
             * @memberof signalservice.CallingMessage
             * @interface IHangup
             * @property {number|Long|null} [callId] Hangup callId
             * @property {signalservice.CallingMessage.Hangup.Type|null} [type] Hangup type
             * @property {number|null} [deviceId] Hangup deviceId
             */

            /**
             * Constructs a new Hangup.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents a Hangup.
             * @implements IHangup
             * @constructor
             * @param {signalservice.CallingMessage.IHangup=} [properties] Properties to set
             */
            function Hangup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Hangup callId.
             * @member {number|Long} callId
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             */
            Hangup.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Hangup type.
             * @member {signalservice.CallingMessage.Hangup.Type} type
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             */
            Hangup.prototype.type = 0;

            /**
             * Hangup deviceId.
             * @member {number} deviceId
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             */
            Hangup.prototype.deviceId = 0;

            /**
             * Creates a new Hangup instance using the specified properties.
             * @function create
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.IHangup=} [properties] Properties to set
             * @returns {signalservice.CallingMessage.Hangup} Hangup instance
             */
            Hangup.create = function create(properties) {
                return new Hangup(properties);
            };

            /**
             * Encodes the specified Hangup message. Does not implicitly {@link signalservice.CallingMessage.Hangup.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.IHangup} message Hangup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hangup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.callId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.deviceId);
                return writer;
            };

            /**
             * Encodes the specified Hangup message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Hangup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.IHangup} message Hangup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hangup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Hangup message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Hangup} Hangup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hangup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Hangup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.callId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.type = reader.int32();
                            break;
                        }
                    case 3: {
                            message.deviceId = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Hangup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Hangup} Hangup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hangup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Hangup message.
             * @function verify
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Hangup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                    if (!$util.isInteger(message.deviceId))
                        return "deviceId: integer expected";
                return null;
            };

            /**
             * Creates a Hangup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Hangup} Hangup
             */
            Hangup.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Hangup)
                    return object;
                let message = new $root.signalservice.CallingMessage.Hangup();
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "HANGUP_NORMAL":
                case 0:
                    message.type = 0;
                    break;
                case "HANGUP_ACCEPTED":
                case 1:
                    message.type = 1;
                    break;
                case "HANGUP_DECLINED":
                case 2:
                    message.type = 2;
                    break;
                case "HANGUP_BUSY":
                case 3:
                    message.type = 3;
                    break;
                case "HANGUP_NEED_PERMISSION":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.deviceId != null)
                    message.deviceId = object.deviceId >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Hangup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {signalservice.CallingMessage.Hangup} message Hangup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Hangup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "HANGUP_NORMAL" : 0;
                    object.deviceId = 0;
                }
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.CallingMessage.Hangup.Type[message.type] === undefined ? message.type : $root.signalservice.CallingMessage.Hangup.Type[message.type] : message.type;
                if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                    object.deviceId = message.deviceId;
                return object;
            };

            /**
             * Converts this Hangup to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Hangup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Hangup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Hangup
             * @function getTypeUrl
             * @memberof signalservice.CallingMessage.Hangup
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Hangup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.CallingMessage.Hangup";
            };

            /**
             * Type enum.
             * @name signalservice.CallingMessage.Hangup.Type
             * @enum {number}
             * @property {number} HANGUP_NORMAL=0 HANGUP_NORMAL value
             * @property {number} HANGUP_ACCEPTED=1 HANGUP_ACCEPTED value
             * @property {number} HANGUP_DECLINED=2 HANGUP_DECLINED value
             * @property {number} HANGUP_BUSY=3 HANGUP_BUSY value
             * @property {number} HANGUP_NEED_PERMISSION=4 HANGUP_NEED_PERMISSION value
             */
            Hangup.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "HANGUP_NORMAL"] = 0;
                values[valuesById[1] = "HANGUP_ACCEPTED"] = 1;
                values[valuesById[2] = "HANGUP_DECLINED"] = 2;
                values[valuesById[3] = "HANGUP_BUSY"] = 3;
                values[valuesById[4] = "HANGUP_NEED_PERMISSION"] = 4;
                return values;
            })();

            return Hangup;
        })();

        CallingMessage.Opaque = (function() {

            /**
             * Properties of an Opaque.
             * @memberof signalservice.CallingMessage
             * @interface IOpaque
             * @property {Uint8Array|null} [data] Opaque data
             * @property {signalservice.CallingMessage.Opaque.Urgency|null} [urgency] Opaque urgency
             */

            /**
             * Constructs a new Opaque.
             * @memberof signalservice.CallingMessage
             * @classdesc Represents an Opaque.
             * @implements IOpaque
             * @constructor
             * @param {signalservice.CallingMessage.IOpaque=} [properties] Properties to set
             */
            function Opaque(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Opaque data.
             * @member {Uint8Array} data
             * @memberof signalservice.CallingMessage.Opaque
             * @instance
             */
            Opaque.prototype.data = $util.newBuffer([]);

            /**
             * Opaque urgency.
             * @member {signalservice.CallingMessage.Opaque.Urgency} urgency
             * @memberof signalservice.CallingMessage.Opaque
             * @instance
             */
            Opaque.prototype.urgency = 0;

            /**
             * Creates a new Opaque instance using the specified properties.
             * @function create
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.IOpaque=} [properties] Properties to set
             * @returns {signalservice.CallingMessage.Opaque} Opaque instance
             */
            Opaque.create = function create(properties) {
                return new Opaque(properties);
            };

            /**
             * Encodes the specified Opaque message. Does not implicitly {@link signalservice.CallingMessage.Opaque.verify|verify} messages.
             * @function encode
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.IOpaque} message Opaque message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Opaque.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                if (message.urgency != null && Object.hasOwnProperty.call(message, "urgency"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.urgency);
                return writer;
            };

            /**
             * Encodes the specified Opaque message, length delimited. Does not implicitly {@link signalservice.CallingMessage.Opaque.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.IOpaque} message Opaque message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Opaque.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Opaque message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.CallingMessage.Opaque} Opaque
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Opaque.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.CallingMessage.Opaque();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.data = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.urgency = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Opaque message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.CallingMessage.Opaque} Opaque
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Opaque.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Opaque message.
             * @function verify
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Opaque.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.urgency != null && message.hasOwnProperty("urgency"))
                    switch (message.urgency) {
                    default:
                        return "urgency: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates an Opaque message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.CallingMessage.Opaque} Opaque
             */
            Opaque.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.CallingMessage.Opaque)
                    return object;
                let message = new $root.signalservice.CallingMessage.Opaque();
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length >= 0)
                        message.data = object.data;
                switch (object.urgency) {
                default:
                    if (typeof object.urgency === "number") {
                        message.urgency = object.urgency;
                        break;
                    }
                    break;
                case "DROPPABLE":
                case 0:
                    message.urgency = 0;
                    break;
                case "HANDLE_IMMEDIATELY":
                case 1:
                    message.urgency = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an Opaque message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {signalservice.CallingMessage.Opaque} message Opaque
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Opaque.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    object.urgency = options.enums === String ? "DROPPABLE" : 0;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.urgency != null && message.hasOwnProperty("urgency"))
                    object.urgency = options.enums === String ? $root.signalservice.CallingMessage.Opaque.Urgency[message.urgency] === undefined ? message.urgency : $root.signalservice.CallingMessage.Opaque.Urgency[message.urgency] : message.urgency;
                return object;
            };

            /**
             * Converts this Opaque to JSON.
             * @function toJSON
             * @memberof signalservice.CallingMessage.Opaque
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Opaque.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Opaque
             * @function getTypeUrl
             * @memberof signalservice.CallingMessage.Opaque
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Opaque.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.CallingMessage.Opaque";
            };

            /**
             * Urgency enum.
             * @name signalservice.CallingMessage.Opaque.Urgency
             * @enum {number}
             * @property {number} DROPPABLE=0 DROPPABLE value
             * @property {number} HANDLE_IMMEDIATELY=1 HANDLE_IMMEDIATELY value
             */
            Opaque.Urgency = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DROPPABLE"] = 0;
                values[valuesById[1] = "HANDLE_IMMEDIATELY"] = 1;
                return values;
            })();

            return Opaque;
        })();

        return CallingMessage;
    })();

    signalservice.DataMessage = (function() {

        /**
         * Properties of a DataMessage.
         * @memberof signalservice
         * @interface IDataMessage
         * @property {string|null} [body] DataMessage body
         * @property {Array.<signalservice.IAttachmentPointer>|null} [attachments] DataMessage attachments
         * @property {signalservice.IGroupContextV2|null} [groupV2] DataMessage groupV2
         * @property {number|null} [flags] DataMessage flags
         * @property {number|null} [expireTimer] DataMessage expireTimer
         * @property {Uint8Array|null} [profileKey] DataMessage profileKey
         * @property {number|Long|null} [timestamp] DataMessage timestamp
         * @property {signalservice.DataMessage.IQuote|null} [quote] DataMessage quote
         * @property {Array.<signalservice.DataMessage.IContact>|null} [contact] DataMessage contact
         * @property {Array.<signalservice.DataMessage.IPreview>|null} [preview] DataMessage preview
         * @property {signalservice.DataMessage.ISticker|null} [sticker] DataMessage sticker
         * @property {number|null} [requiredProtocolVersion] DataMessage requiredProtocolVersion
         * @property {boolean|null} [isViewOnce] DataMessage isViewOnce
         * @property {signalservice.DataMessage.IReaction|null} [reaction] DataMessage reaction
         * @property {signalservice.DataMessage.IDelete|null} ["delete"] DataMessage delete
         * @property {Array.<signalservice.DataMessage.IBodyRange>|null} [bodyRanges] DataMessage bodyRanges
         * @property {signalservice.DataMessage.IGroupCallUpdate|null} [groupCallUpdate] DataMessage groupCallUpdate
         * @property {signalservice.DataMessage.IPayment|null} [payment] DataMessage payment
         * @property {signalservice.DataMessage.IStoryContext|null} [storyContext] DataMessage storyContext
         * @property {signalservice.DataMessage.IGiftBadge|null} [giftBadge] DataMessage giftBadge
         */

        /**
         * Constructs a new DataMessage.
         * @memberof signalservice
         * @classdesc Represents a DataMessage.
         * @implements IDataMessage
         * @constructor
         * @param {signalservice.IDataMessage=} [properties] Properties to set
         */
        function DataMessage(properties) {
            this.attachments = [];
            this.contact = [];
            this.preview = [];
            this.bodyRanges = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataMessage body.
         * @member {string} body
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.body = "";

        /**
         * DataMessage attachments.
         * @member {Array.<signalservice.IAttachmentPointer>} attachments
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.attachments = $util.emptyArray;

        /**
         * DataMessage groupV2.
         * @member {signalservice.IGroupContextV2|null|undefined} groupV2
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.groupV2 = null;

        /**
         * DataMessage flags.
         * @member {number} flags
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.flags = 0;

        /**
         * DataMessage expireTimer.
         * @member {number} expireTimer
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.expireTimer = 0;

        /**
         * DataMessage profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.profileKey = $util.newBuffer([]);

        /**
         * DataMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DataMessage quote.
         * @member {signalservice.DataMessage.IQuote|null|undefined} quote
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.quote = null;

        /**
         * DataMessage contact.
         * @member {Array.<signalservice.DataMessage.IContact>} contact
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.contact = $util.emptyArray;

        /**
         * DataMessage preview.
         * @member {Array.<signalservice.DataMessage.IPreview>} preview
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.preview = $util.emptyArray;

        /**
         * DataMessage sticker.
         * @member {signalservice.DataMessage.ISticker|null|undefined} sticker
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.sticker = null;

        /**
         * DataMessage requiredProtocolVersion.
         * @member {number} requiredProtocolVersion
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.requiredProtocolVersion = 0;

        /**
         * DataMessage isViewOnce.
         * @member {boolean} isViewOnce
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.isViewOnce = false;

        /**
         * DataMessage reaction.
         * @member {signalservice.DataMessage.IReaction|null|undefined} reaction
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.reaction = null;

        /**
         * DataMessage delete.
         * @member {signalservice.DataMessage.IDelete|null|undefined} delete
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype["delete"] = null;

        /**
         * DataMessage bodyRanges.
         * @member {Array.<signalservice.DataMessage.IBodyRange>} bodyRanges
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.bodyRanges = $util.emptyArray;

        /**
         * DataMessage groupCallUpdate.
         * @member {signalservice.DataMessage.IGroupCallUpdate|null|undefined} groupCallUpdate
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.groupCallUpdate = null;

        /**
         * DataMessage payment.
         * @member {signalservice.DataMessage.IPayment|null|undefined} payment
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.payment = null;

        /**
         * DataMessage storyContext.
         * @member {signalservice.DataMessage.IStoryContext|null|undefined} storyContext
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.storyContext = null;

        /**
         * DataMessage giftBadge.
         * @member {signalservice.DataMessage.IGiftBadge|null|undefined} giftBadge
         * @memberof signalservice.DataMessage
         * @instance
         */
        DataMessage.prototype.giftBadge = null;

        /**
         * Creates a new DataMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.IDataMessage=} [properties] Properties to set
         * @returns {signalservice.DataMessage} DataMessage instance
         */
        DataMessage.create = function create(properties) {
            return new DataMessage(properties);
        };

        /**
         * Encodes the specified DataMessage message. Does not implicitly {@link signalservice.DataMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.IDataMessage} message DataMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.body);
            if (message.attachments != null && message.attachments.length)
                for (let i = 0; i < message.attachments.length; ++i)
                    $root.signalservice.AttachmentPointer.encode(message.attachments[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags);
            if (message.expireTimer != null && Object.hasOwnProperty.call(message, "expireTimer"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.expireTimer);
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.profileKey);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.timestamp);
            if (message.quote != null && Object.hasOwnProperty.call(message, "quote"))
                $root.signalservice.DataMessage.Quote.encode(message.quote, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.contact != null && message.contact.length)
                for (let i = 0; i < message.contact.length; ++i)
                    $root.signalservice.DataMessage.Contact.encode(message.contact[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.preview != null && message.preview.length)
                for (let i = 0; i < message.preview.length; ++i)
                    $root.signalservice.DataMessage.Preview.encode(message.preview[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.sticker != null && Object.hasOwnProperty.call(message, "sticker"))
                $root.signalservice.DataMessage.Sticker.encode(message.sticker, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.requiredProtocolVersion != null && Object.hasOwnProperty.call(message, "requiredProtocolVersion"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.requiredProtocolVersion);
            if (message.isViewOnce != null && Object.hasOwnProperty.call(message, "isViewOnce"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isViewOnce);
            if (message.groupV2 != null && Object.hasOwnProperty.call(message, "groupV2"))
                $root.signalservice.GroupContextV2.encode(message.groupV2, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.reaction != null && Object.hasOwnProperty.call(message, "reaction"))
                $root.signalservice.DataMessage.Reaction.encode(message.reaction, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
                $root.signalservice.DataMessage.Delete.encode(message["delete"], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.bodyRanges != null && message.bodyRanges.length)
                for (let i = 0; i < message.bodyRanges.length; ++i)
                    $root.signalservice.DataMessage.BodyRange.encode(message.bodyRanges[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.groupCallUpdate != null && Object.hasOwnProperty.call(message, "groupCallUpdate"))
                $root.signalservice.DataMessage.GroupCallUpdate.encode(message.groupCallUpdate, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.payment != null && Object.hasOwnProperty.call(message, "payment"))
                $root.signalservice.DataMessage.Payment.encode(message.payment, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.storyContext != null && Object.hasOwnProperty.call(message, "storyContext"))
                $root.signalservice.DataMessage.StoryContext.encode(message.storyContext, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.giftBadge != null && Object.hasOwnProperty.call(message, "giftBadge"))
                $root.signalservice.DataMessage.GiftBadge.encode(message.giftBadge, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DataMessage message, length delimited. Does not implicitly {@link signalservice.DataMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.IDataMessage} message DataMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.DataMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.DataMessage} DataMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.body = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.attachments && message.attachments.length))
                            message.attachments = [];
                        message.attachments.push($root.signalservice.AttachmentPointer.decode(reader, reader.uint32()));
                        break;
                    }
                case 15: {
                        message.groupV2 = $root.signalservice.GroupContextV2.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 5: {
                        message.expireTimer = reader.uint32();
                        break;
                    }
                case 6: {
                        message.profileKey = reader.bytes();
                        break;
                    }
                case 7: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                case 8: {
                        message.quote = $root.signalservice.DataMessage.Quote.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        if (!(message.contact && message.contact.length))
                            message.contact = [];
                        message.contact.push($root.signalservice.DataMessage.Contact.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        if (!(message.preview && message.preview.length))
                            message.preview = [];
                        message.preview.push($root.signalservice.DataMessage.Preview.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        message.sticker = $root.signalservice.DataMessage.Sticker.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.requiredProtocolVersion = reader.uint32();
                        break;
                    }
                case 14: {
                        message.isViewOnce = reader.bool();
                        break;
                    }
                case 16: {
                        message.reaction = $root.signalservice.DataMessage.Reaction.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message["delete"] = $root.signalservice.DataMessage.Delete.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        if (!(message.bodyRanges && message.bodyRanges.length))
                            message.bodyRanges = [];
                        message.bodyRanges.push($root.signalservice.DataMessage.BodyRange.decode(reader, reader.uint32()));
                        break;
                    }
                case 19: {
                        message.groupCallUpdate = $root.signalservice.DataMessage.GroupCallUpdate.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.payment = $root.signalservice.DataMessage.Payment.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.storyContext = $root.signalservice.DataMessage.StoryContext.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.giftBadge = $root.signalservice.DataMessage.GiftBadge.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.DataMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.DataMessage} DataMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataMessage message.
         * @function verify
         * @memberof signalservice.DataMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            if (message.attachments != null && message.hasOwnProperty("attachments")) {
                if (!Array.isArray(message.attachments))
                    return "attachments: array expected";
                for (let i = 0; i < message.attachments.length; ++i) {
                    let error = $root.signalservice.AttachmentPointer.verify(message.attachments[i]);
                    if (error)
                        return "attachments." + error;
                }
            }
            if (message.groupV2 != null && message.hasOwnProperty("groupV2")) {
                let error = $root.signalservice.GroupContextV2.verify(message.groupV2);
                if (error)
                    return "groupV2." + error;
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                if (!$util.isInteger(message.expireTimer))
                    return "expireTimer: integer expected";
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                if (!(message.profileKey && typeof message.profileKey.length === "number" || $util.isString(message.profileKey)))
                    return "profileKey: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.quote != null && message.hasOwnProperty("quote")) {
                let error = $root.signalservice.DataMessage.Quote.verify(message.quote);
                if (error)
                    return "quote." + error;
            }
            if (message.contact != null && message.hasOwnProperty("contact")) {
                if (!Array.isArray(message.contact))
                    return "contact: array expected";
                for (let i = 0; i < message.contact.length; ++i) {
                    let error = $root.signalservice.DataMessage.Contact.verify(message.contact[i]);
                    if (error)
                        return "contact." + error;
                }
            }
            if (message.preview != null && message.hasOwnProperty("preview")) {
                if (!Array.isArray(message.preview))
                    return "preview: array expected";
                for (let i = 0; i < message.preview.length; ++i) {
                    let error = $root.signalservice.DataMessage.Preview.verify(message.preview[i]);
                    if (error)
                        return "preview." + error;
                }
            }
            if (message.sticker != null && message.hasOwnProperty("sticker")) {
                let error = $root.signalservice.DataMessage.Sticker.verify(message.sticker);
                if (error)
                    return "sticker." + error;
            }
            if (message.requiredProtocolVersion != null && message.hasOwnProperty("requiredProtocolVersion"))
                if (!$util.isInteger(message.requiredProtocolVersion))
                    return "requiredProtocolVersion: integer expected";
            if (message.isViewOnce != null && message.hasOwnProperty("isViewOnce"))
                if (typeof message.isViewOnce !== "boolean")
                    return "isViewOnce: boolean expected";
            if (message.reaction != null && message.hasOwnProperty("reaction")) {
                let error = $root.signalservice.DataMessage.Reaction.verify(message.reaction);
                if (error)
                    return "reaction." + error;
            }
            if (message["delete"] != null && message.hasOwnProperty("delete")) {
                let error = $root.signalservice.DataMessage.Delete.verify(message["delete"]);
                if (error)
                    return "delete." + error;
            }
            if (message.bodyRanges != null && message.hasOwnProperty("bodyRanges")) {
                if (!Array.isArray(message.bodyRanges))
                    return "bodyRanges: array expected";
                for (let i = 0; i < message.bodyRanges.length; ++i) {
                    let error = $root.signalservice.DataMessage.BodyRange.verify(message.bodyRanges[i]);
                    if (error)
                        return "bodyRanges." + error;
                }
            }
            if (message.groupCallUpdate != null && message.hasOwnProperty("groupCallUpdate")) {
                let error = $root.signalservice.DataMessage.GroupCallUpdate.verify(message.groupCallUpdate);
                if (error)
                    return "groupCallUpdate." + error;
            }
            if (message.payment != null && message.hasOwnProperty("payment")) {
                let error = $root.signalservice.DataMessage.Payment.verify(message.payment);
                if (error)
                    return "payment." + error;
            }
            if (message.storyContext != null && message.hasOwnProperty("storyContext")) {
                let error = $root.signalservice.DataMessage.StoryContext.verify(message.storyContext);
                if (error)
                    return "storyContext." + error;
            }
            if (message.giftBadge != null && message.hasOwnProperty("giftBadge")) {
                let error = $root.signalservice.DataMessage.GiftBadge.verify(message.giftBadge);
                if (error)
                    return "giftBadge." + error;
            }
            return null;
        };

        /**
         * Creates a DataMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.DataMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.DataMessage} DataMessage
         */
        DataMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.DataMessage)
                return object;
            let message = new $root.signalservice.DataMessage();
            if (object.body != null)
                message.body = String(object.body);
            if (object.attachments) {
                if (!Array.isArray(object.attachments))
                    throw TypeError(".signalservice.DataMessage.attachments: array expected");
                message.attachments = [];
                for (let i = 0; i < object.attachments.length; ++i) {
                    if (typeof object.attachments[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.attachments: object expected");
                    message.attachments[i] = $root.signalservice.AttachmentPointer.fromObject(object.attachments[i]);
                }
            }
            if (object.groupV2 != null) {
                if (typeof object.groupV2 !== "object")
                    throw TypeError(".signalservice.DataMessage.groupV2: object expected");
                message.groupV2 = $root.signalservice.GroupContextV2.fromObject(object.groupV2);
            }
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.expireTimer != null)
                message.expireTimer = object.expireTimer >>> 0;
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length >= 0)
                    message.profileKey = object.profileKey;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.quote != null) {
                if (typeof object.quote !== "object")
                    throw TypeError(".signalservice.DataMessage.quote: object expected");
                message.quote = $root.signalservice.DataMessage.Quote.fromObject(object.quote);
            }
            if (object.contact) {
                if (!Array.isArray(object.contact))
                    throw TypeError(".signalservice.DataMessage.contact: array expected");
                message.contact = [];
                for (let i = 0; i < object.contact.length; ++i) {
                    if (typeof object.contact[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.contact: object expected");
                    message.contact[i] = $root.signalservice.DataMessage.Contact.fromObject(object.contact[i]);
                }
            }
            if (object.preview) {
                if (!Array.isArray(object.preview))
                    throw TypeError(".signalservice.DataMessage.preview: array expected");
                message.preview = [];
                for (let i = 0; i < object.preview.length; ++i) {
                    if (typeof object.preview[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.preview: object expected");
                    message.preview[i] = $root.signalservice.DataMessage.Preview.fromObject(object.preview[i]);
                }
            }
            if (object.sticker != null) {
                if (typeof object.sticker !== "object")
                    throw TypeError(".signalservice.DataMessage.sticker: object expected");
                message.sticker = $root.signalservice.DataMessage.Sticker.fromObject(object.sticker);
            }
            if (object.requiredProtocolVersion != null)
                message.requiredProtocolVersion = object.requiredProtocolVersion >>> 0;
            if (object.isViewOnce != null)
                message.isViewOnce = Boolean(object.isViewOnce);
            if (object.reaction != null) {
                if (typeof object.reaction !== "object")
                    throw TypeError(".signalservice.DataMessage.reaction: object expected");
                message.reaction = $root.signalservice.DataMessage.Reaction.fromObject(object.reaction);
            }
            if (object["delete"] != null) {
                if (typeof object["delete"] !== "object")
                    throw TypeError(".signalservice.DataMessage.delete: object expected");
                message["delete"] = $root.signalservice.DataMessage.Delete.fromObject(object["delete"]);
            }
            if (object.bodyRanges) {
                if (!Array.isArray(object.bodyRanges))
                    throw TypeError(".signalservice.DataMessage.bodyRanges: array expected");
                message.bodyRanges = [];
                for (let i = 0; i < object.bodyRanges.length; ++i) {
                    if (typeof object.bodyRanges[i] !== "object")
                        throw TypeError(".signalservice.DataMessage.bodyRanges: object expected");
                    message.bodyRanges[i] = $root.signalservice.DataMessage.BodyRange.fromObject(object.bodyRanges[i]);
                }
            }
            if (object.groupCallUpdate != null) {
                if (typeof object.groupCallUpdate !== "object")
                    throw TypeError(".signalservice.DataMessage.groupCallUpdate: object expected");
                message.groupCallUpdate = $root.signalservice.DataMessage.GroupCallUpdate.fromObject(object.groupCallUpdate);
            }
            if (object.payment != null) {
                if (typeof object.payment !== "object")
                    throw TypeError(".signalservice.DataMessage.payment: object expected");
                message.payment = $root.signalservice.DataMessage.Payment.fromObject(object.payment);
            }
            if (object.storyContext != null) {
                if (typeof object.storyContext !== "object")
                    throw TypeError(".signalservice.DataMessage.storyContext: object expected");
                message.storyContext = $root.signalservice.DataMessage.StoryContext.fromObject(object.storyContext);
            }
            if (object.giftBadge != null) {
                if (typeof object.giftBadge !== "object")
                    throw TypeError(".signalservice.DataMessage.giftBadge: object expected");
                message.giftBadge = $root.signalservice.DataMessage.GiftBadge.fromObject(object.giftBadge);
            }
            return message;
        };

        /**
         * Creates a plain object from a DataMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.DataMessage
         * @static
         * @param {signalservice.DataMessage} message DataMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.attachments = [];
                object.contact = [];
                object.preview = [];
                object.bodyRanges = [];
            }
            if (options.defaults) {
                object.body = "";
                object.flags = 0;
                object.expireTimer = 0;
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.quote = null;
                object.sticker = null;
                object.requiredProtocolVersion = 0;
                object.isViewOnce = false;
                object.groupV2 = null;
                object.reaction = null;
                object["delete"] = null;
                object.groupCallUpdate = null;
                object.payment = null;
                object.storyContext = null;
                object.giftBadge = null;
            }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.attachments && message.attachments.length) {
                object.attachments = [];
                for (let j = 0; j < message.attachments.length; ++j)
                    object.attachments[j] = $root.signalservice.AttachmentPointer.toObject(message.attachments[j], options);
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                object.expireTimer = message.expireTimer;
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.quote != null && message.hasOwnProperty("quote"))
                object.quote = $root.signalservice.DataMessage.Quote.toObject(message.quote, options);
            if (message.contact && message.contact.length) {
                object.contact = [];
                for (let j = 0; j < message.contact.length; ++j)
                    object.contact[j] = $root.signalservice.DataMessage.Contact.toObject(message.contact[j], options);
            }
            if (message.preview && message.preview.length) {
                object.preview = [];
                for (let j = 0; j < message.preview.length; ++j)
                    object.preview[j] = $root.signalservice.DataMessage.Preview.toObject(message.preview[j], options);
            }
            if (message.sticker != null && message.hasOwnProperty("sticker"))
                object.sticker = $root.signalservice.DataMessage.Sticker.toObject(message.sticker, options);
            if (message.requiredProtocolVersion != null && message.hasOwnProperty("requiredProtocolVersion"))
                object.requiredProtocolVersion = message.requiredProtocolVersion;
            if (message.isViewOnce != null && message.hasOwnProperty("isViewOnce"))
                object.isViewOnce = message.isViewOnce;
            if (message.groupV2 != null && message.hasOwnProperty("groupV2"))
                object.groupV2 = $root.signalservice.GroupContextV2.toObject(message.groupV2, options);
            if (message.reaction != null && message.hasOwnProperty("reaction"))
                object.reaction = $root.signalservice.DataMessage.Reaction.toObject(message.reaction, options);
            if (message["delete"] != null && message.hasOwnProperty("delete"))
                object["delete"] = $root.signalservice.DataMessage.Delete.toObject(message["delete"], options);
            if (message.bodyRanges && message.bodyRanges.length) {
                object.bodyRanges = [];
                for (let j = 0; j < message.bodyRanges.length; ++j)
                    object.bodyRanges[j] = $root.signalservice.DataMessage.BodyRange.toObject(message.bodyRanges[j], options);
            }
            if (message.groupCallUpdate != null && message.hasOwnProperty("groupCallUpdate"))
                object.groupCallUpdate = $root.signalservice.DataMessage.GroupCallUpdate.toObject(message.groupCallUpdate, options);
            if (message.payment != null && message.hasOwnProperty("payment"))
                object.payment = $root.signalservice.DataMessage.Payment.toObject(message.payment, options);
            if (message.storyContext != null && message.hasOwnProperty("storyContext"))
                object.storyContext = $root.signalservice.DataMessage.StoryContext.toObject(message.storyContext, options);
            if (message.giftBadge != null && message.hasOwnProperty("giftBadge"))
                object.giftBadge = $root.signalservice.DataMessage.GiftBadge.toObject(message.giftBadge, options);
            return object;
        };

        /**
         * Converts this DataMessage to JSON.
         * @function toJSON
         * @memberof signalservice.DataMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DataMessage
         * @function getTypeUrl
         * @memberof signalservice.DataMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DataMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.DataMessage";
        };

        /**
         * Flags enum.
         * @name signalservice.DataMessage.Flags
         * @enum {number}
         * @property {number} END_SESSION=1 END_SESSION value
         * @property {number} EXPIRATION_TIMER_UPDATE=2 EXPIRATION_TIMER_UPDATE value
         * @property {number} PROFILE_KEY_UPDATE=4 PROFILE_KEY_UPDATE value
         */
        DataMessage.Flags = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "END_SESSION"] = 1;
            values[valuesById[2] = "EXPIRATION_TIMER_UPDATE"] = 2;
            values[valuesById[4] = "PROFILE_KEY_UPDATE"] = 4;
            return values;
        })();

        DataMessage.Payment = (function() {

            /**
             * Properties of a Payment.
             * @memberof signalservice.DataMessage
             * @interface IPayment
             * @property {signalservice.DataMessage.Payment.INotification|null} [notification] Payment notification
             * @property {signalservice.DataMessage.Payment.IActivation|null} [activation] Payment activation
             * @property {signalservice.DataMessage.Payment.IRequest|null} [request] Payment request
             * @property {signalservice.DataMessage.Payment.ICancellation|null} [cancellation] Payment cancellation
             */

            /**
             * Constructs a new Payment.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Payment.
             * @implements IPayment
             * @constructor
             * @param {signalservice.DataMessage.IPayment=} [properties] Properties to set
             */
            function Payment(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Payment notification.
             * @member {signalservice.DataMessage.Payment.INotification|null|undefined} notification
             * @memberof signalservice.DataMessage.Payment
             * @instance
             */
            Payment.prototype.notification = null;

            /**
             * Payment activation.
             * @member {signalservice.DataMessage.Payment.IActivation|null|undefined} activation
             * @memberof signalservice.DataMessage.Payment
             * @instance
             */
            Payment.prototype.activation = null;

            /**
             * Payment request.
             * @member {signalservice.DataMessage.Payment.IRequest|null|undefined} request
             * @memberof signalservice.DataMessage.Payment
             * @instance
             */
            Payment.prototype.request = null;

            /**
             * Payment cancellation.
             * @member {signalservice.DataMessage.Payment.ICancellation|null|undefined} cancellation
             * @memberof signalservice.DataMessage.Payment
             * @instance
             */
            Payment.prototype.cancellation = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Payment Item.
             * @member {"notification"|"activation"|"request"|"cancellation"|undefined} Item
             * @memberof signalservice.DataMessage.Payment
             * @instance
             */
            Object.defineProperty(Payment.prototype, "Item", {
                get: $util.oneOfGetter($oneOfFields = ["notification", "activation", "request", "cancellation"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Payment instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {signalservice.DataMessage.IPayment=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Payment} Payment instance
             */
            Payment.create = function create(properties) {
                return new Payment(properties);
            };

            /**
             * Encodes the specified Payment message. Does not implicitly {@link signalservice.DataMessage.Payment.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {signalservice.DataMessage.IPayment} message Payment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.notification != null && Object.hasOwnProperty.call(message, "notification"))
                    $root.signalservice.DataMessage.Payment.Notification.encode(message.notification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.activation != null && Object.hasOwnProperty.call(message, "activation"))
                    $root.signalservice.DataMessage.Payment.Activation.encode(message.activation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                    $root.signalservice.DataMessage.Payment.Request.encode(message.request, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
                if (message.cancellation != null && Object.hasOwnProperty.call(message, "cancellation"))
                    $root.signalservice.DataMessage.Payment.Cancellation.encode(message.cancellation, writer.uint32(/* id 1003, wireType 2 =*/8026).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Payment message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {signalservice.DataMessage.IPayment} message Payment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Payment message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Payment} Payment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.notification = $root.signalservice.DataMessage.Payment.Notification.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.activation = $root.signalservice.DataMessage.Payment.Activation.decode(reader, reader.uint32());
                            break;
                        }
                    case 1002: {
                            message.request = $root.signalservice.DataMessage.Payment.Request.decode(reader, reader.uint32());
                            break;
                        }
                    case 1003: {
                            message.cancellation = $root.signalservice.DataMessage.Payment.Cancellation.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Payment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Payment} Payment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Payment message.
             * @function verify
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Payment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.notification != null && message.hasOwnProperty("notification")) {
                    properties.Item = 1;
                    {
                        let error = $root.signalservice.DataMessage.Payment.Notification.verify(message.notification);
                        if (error)
                            return "notification." + error;
                    }
                }
                if (message.activation != null && message.hasOwnProperty("activation")) {
                    if (properties.Item === 1)
                        return "Item: multiple values";
                    properties.Item = 1;
                    {
                        let error = $root.signalservice.DataMessage.Payment.Activation.verify(message.activation);
                        if (error)
                            return "activation." + error;
                    }
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    if (properties.Item === 1)
                        return "Item: multiple values";
                    properties.Item = 1;
                    {
                        let error = $root.signalservice.DataMessage.Payment.Request.verify(message.request);
                        if (error)
                            return "request." + error;
                    }
                }
                if (message.cancellation != null && message.hasOwnProperty("cancellation")) {
                    if (properties.Item === 1)
                        return "Item: multiple values";
                    properties.Item = 1;
                    {
                        let error = $root.signalservice.DataMessage.Payment.Cancellation.verify(message.cancellation);
                        if (error)
                            return "cancellation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Payment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Payment} Payment
             */
            Payment.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Payment)
                    return object;
                let message = new $root.signalservice.DataMessage.Payment();
                if (object.notification != null) {
                    if (typeof object.notification !== "object")
                        throw TypeError(".signalservice.DataMessage.Payment.notification: object expected");
                    message.notification = $root.signalservice.DataMessage.Payment.Notification.fromObject(object.notification);
                }
                if (object.activation != null) {
                    if (typeof object.activation !== "object")
                        throw TypeError(".signalservice.DataMessage.Payment.activation: object expected");
                    message.activation = $root.signalservice.DataMessage.Payment.Activation.fromObject(object.activation);
                }
                if (object.request != null) {
                    if (typeof object.request !== "object")
                        throw TypeError(".signalservice.DataMessage.Payment.request: object expected");
                    message.request = $root.signalservice.DataMessage.Payment.Request.fromObject(object.request);
                }
                if (object.cancellation != null) {
                    if (typeof object.cancellation !== "object")
                        throw TypeError(".signalservice.DataMessage.Payment.cancellation: object expected");
                    message.cancellation = $root.signalservice.DataMessage.Payment.Cancellation.fromObject(object.cancellation);
                }
                return message;
            };

            /**
             * Creates a plain object from a Payment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {signalservice.DataMessage.Payment} message Payment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Payment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.notification != null && message.hasOwnProperty("notification")) {
                    object.notification = $root.signalservice.DataMessage.Payment.Notification.toObject(message.notification, options);
                    if (options.oneofs)
                        object.Item = "notification";
                }
                if (message.activation != null && message.hasOwnProperty("activation")) {
                    object.activation = $root.signalservice.DataMessage.Payment.Activation.toObject(message.activation, options);
                    if (options.oneofs)
                        object.Item = "activation";
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    object.request = $root.signalservice.DataMessage.Payment.Request.toObject(message.request, options);
                    if (options.oneofs)
                        object.Item = "request";
                }
                if (message.cancellation != null && message.hasOwnProperty("cancellation")) {
                    object.cancellation = $root.signalservice.DataMessage.Payment.Cancellation.toObject(message.cancellation, options);
                    if (options.oneofs)
                        object.Item = "cancellation";
                }
                return object;
            };

            /**
             * Converts this Payment to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Payment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Payment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Payment
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Payment
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Payment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Payment";
            };

            Payment.Amount = (function() {

                /**
                 * Properties of an Amount.
                 * @memberof signalservice.DataMessage.Payment
                 * @interface IAmount
                 * @property {signalservice.DataMessage.Payment.Amount.IMobileCoin|null} [mobileCoin] Amount mobileCoin
                 */

                /**
                 * Constructs a new Amount.
                 * @memberof signalservice.DataMessage.Payment
                 * @classdesc Represents an Amount.
                 * @implements IAmount
                 * @constructor
                 * @param {signalservice.DataMessage.Payment.IAmount=} [properties] Properties to set
                 */
                function Amount(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Amount mobileCoin.
                 * @member {signalservice.DataMessage.Payment.Amount.IMobileCoin|null|undefined} mobileCoin
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @instance
                 */
                Amount.prototype.mobileCoin = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Amount Amount.
                 * @member {"mobileCoin"|undefined} Amount
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @instance
                 */
                Object.defineProperty(Amount.prototype, "Amount", {
                    get: $util.oneOfGetter($oneOfFields = ["mobileCoin"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Amount instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {signalservice.DataMessage.Payment.IAmount=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Payment.Amount} Amount instance
                 */
                Amount.create = function create(properties) {
                    return new Amount(properties);
                };

                /**
                 * Encodes the specified Amount message. Does not implicitly {@link signalservice.DataMessage.Payment.Amount.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {signalservice.DataMessage.Payment.IAmount} message Amount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Amount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mobileCoin != null && Object.hasOwnProperty.call(message, "mobileCoin"))
                        $root.signalservice.DataMessage.Payment.Amount.MobileCoin.encode(message.mobileCoin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Amount message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Amount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {signalservice.DataMessage.Payment.IAmount} message Amount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Amount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Amount message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Payment.Amount} Amount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Amount.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Amount();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.mobileCoin = $root.signalservice.DataMessage.Payment.Amount.MobileCoin.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Amount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Payment.Amount} Amount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Amount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Amount message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Amount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.mobileCoin != null && message.hasOwnProperty("mobileCoin")) {
                        properties.Amount = 1;
                        {
                            let error = $root.signalservice.DataMessage.Payment.Amount.MobileCoin.verify(message.mobileCoin);
                            if (error)
                                return "mobileCoin." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Payment.Amount} Amount
                 */
                Amount.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Payment.Amount)
                        return object;
                    let message = new $root.signalservice.DataMessage.Payment.Amount();
                    if (object.mobileCoin != null) {
                        if (typeof object.mobileCoin !== "object")
                            throw TypeError(".signalservice.DataMessage.Payment.Amount.mobileCoin: object expected");
                        message.mobileCoin = $root.signalservice.DataMessage.Payment.Amount.MobileCoin.fromObject(object.mobileCoin);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Amount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {signalservice.DataMessage.Payment.Amount} message Amount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Amount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.mobileCoin != null && message.hasOwnProperty("mobileCoin")) {
                        object.mobileCoin = $root.signalservice.DataMessage.Payment.Amount.MobileCoin.toObject(message.mobileCoin, options);
                        if (options.oneofs)
                            object.Amount = "mobileCoin";
                    }
                    return object;
                };

                /**
                 * Converts this Amount to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Amount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Amount
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Payment.Amount
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Amount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Payment.Amount";
                };

                Amount.MobileCoin = (function() {

                    /**
                     * Properties of a MobileCoin.
                     * @memberof signalservice.DataMessage.Payment.Amount
                     * @interface IMobileCoin
                     * @property {number|Long|null} [picoMob] MobileCoin picoMob
                     */

                    /**
                     * Constructs a new MobileCoin.
                     * @memberof signalservice.DataMessage.Payment.Amount
                     * @classdesc Represents a MobileCoin.
                     * @implements IMobileCoin
                     * @constructor
                     * @param {signalservice.DataMessage.Payment.Amount.IMobileCoin=} [properties] Properties to set
                     */
                    function MobileCoin(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MobileCoin picoMob.
                     * @member {number|Long} picoMob
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @instance
                     */
                    MobileCoin.prototype.picoMob = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new MobileCoin instance using the specified properties.
                     * @function create
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Amount.IMobileCoin=} [properties] Properties to set
                     * @returns {signalservice.DataMessage.Payment.Amount.MobileCoin} MobileCoin instance
                     */
                    MobileCoin.create = function create(properties) {
                        return new MobileCoin(properties);
                    };

                    /**
                     * Encodes the specified MobileCoin message. Does not implicitly {@link signalservice.DataMessage.Payment.Amount.MobileCoin.verify|verify} messages.
                     * @function encode
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Amount.IMobileCoin} message MobileCoin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MobileCoin.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.picoMob != null && Object.hasOwnProperty.call(message, "picoMob"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.picoMob);
                        return writer;
                    };

                    /**
                     * Encodes the specified MobileCoin message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Amount.MobileCoin.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Amount.IMobileCoin} message MobileCoin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MobileCoin.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MobileCoin message from the specified reader or buffer.
                     * @function decode
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signalservice.DataMessage.Payment.Amount.MobileCoin} MobileCoin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MobileCoin.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Amount.MobileCoin();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.picoMob = reader.uint64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MobileCoin message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signalservice.DataMessage.Payment.Amount.MobileCoin} MobileCoin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MobileCoin.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MobileCoin message.
                     * @function verify
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MobileCoin.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.picoMob != null && message.hasOwnProperty("picoMob"))
                            if (!$util.isInteger(message.picoMob) && !(message.picoMob && $util.isInteger(message.picoMob.low) && $util.isInteger(message.picoMob.high)))
                                return "picoMob: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a MobileCoin message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signalservice.DataMessage.Payment.Amount.MobileCoin} MobileCoin
                     */
                    MobileCoin.fromObject = function fromObject(object) {
                        if (object instanceof $root.signalservice.DataMessage.Payment.Amount.MobileCoin)
                            return object;
                        let message = new $root.signalservice.DataMessage.Payment.Amount.MobileCoin();
                        if (object.picoMob != null)
                            if ($util.Long)
                                (message.picoMob = $util.Long.fromValue(object.picoMob)).unsigned = true;
                            else if (typeof object.picoMob === "string")
                                message.picoMob = parseInt(object.picoMob, 10);
                            else if (typeof object.picoMob === "number")
                                message.picoMob = object.picoMob;
                            else if (typeof object.picoMob === "object")
                                message.picoMob = new $util.LongBits(object.picoMob.low >>> 0, object.picoMob.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a MobileCoin message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Amount.MobileCoin} message MobileCoin
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MobileCoin.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.picoMob = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.picoMob = options.longs === String ? "0" : 0;
                        if (message.picoMob != null && message.hasOwnProperty("picoMob"))
                            if (typeof message.picoMob === "number")
                                object.picoMob = options.longs === String ? String(message.picoMob) : message.picoMob;
                            else
                                object.picoMob = options.longs === String ? $util.Long.prototype.toString.call(message.picoMob) : options.longs === Number ? new $util.LongBits(message.picoMob.low >>> 0, message.picoMob.high >>> 0).toNumber(true) : message.picoMob;
                        return object;
                    };

                    /**
                     * Converts this MobileCoin to JSON.
                     * @function toJSON
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MobileCoin.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MobileCoin
                     * @function getTypeUrl
                     * @memberof signalservice.DataMessage.Payment.Amount.MobileCoin
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MobileCoin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/signalservice.DataMessage.Payment.Amount.MobileCoin";
                    };

                    return MobileCoin;
                })();

                return Amount;
            })();

            Payment.RequestId = (function() {

                /**
                 * Properties of a RequestId.
                 * @memberof signalservice.DataMessage.Payment
                 * @interface IRequestId
                 * @property {string|null} [uuid] RequestId uuid
                 */

                /**
                 * Constructs a new RequestId.
                 * @memberof signalservice.DataMessage.Payment
                 * @classdesc Represents a RequestId.
                 * @implements IRequestId
                 * @constructor
                 * @param {signalservice.DataMessage.Payment.IRequestId=} [properties] Properties to set
                 */
                function RequestId(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestId uuid.
                 * @member {string} uuid
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @instance
                 */
                RequestId.prototype.uuid = "";

                /**
                 * Creates a new RequestId instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {signalservice.DataMessage.Payment.IRequestId=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Payment.RequestId} RequestId instance
                 */
                RequestId.create = function create(properties) {
                    return new RequestId(properties);
                };

                /**
                 * Encodes the specified RequestId message. Does not implicitly {@link signalservice.DataMessage.Payment.RequestId.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {signalservice.DataMessage.Payment.IRequestId} message RequestId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uuid);
                    return writer;
                };

                /**
                 * Encodes the specified RequestId message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.RequestId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {signalservice.DataMessage.Payment.IRequestId} message RequestId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RequestId message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Payment.RequestId} RequestId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.RequestId();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RequestId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Payment.RequestId} RequestId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RequestId message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        if (!$util.isString(message.uuid))
                            return "uuid: string expected";
                    return null;
                };

                /**
                 * Creates a RequestId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Payment.RequestId} RequestId
                 */
                RequestId.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Payment.RequestId)
                        return object;
                    let message = new $root.signalservice.DataMessage.Payment.RequestId();
                    if (object.uuid != null)
                        message.uuid = String(object.uuid);
                    return message;
                };

                /**
                 * Creates a plain object from a RequestId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {signalservice.DataMessage.Payment.RequestId} message RequestId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.uuid = "";
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = message.uuid;
                    return object;
                };

                /**
                 * Converts this RequestId to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RequestId
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Payment.RequestId
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RequestId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Payment.RequestId";
                };

                return RequestId;
            })();

            Payment.Request = (function() {

                /**
                 * Properties of a Request.
                 * @memberof signalservice.DataMessage.Payment
                 * @interface IRequest
                 * @property {signalservice.DataMessage.Payment.IRequestId|null} [requestId] Request requestId
                 * @property {signalservice.DataMessage.Payment.IAmount|null} [amount] Request amount
                 * @property {string|null} [note] Request note
                 */

                /**
                 * Constructs a new Request.
                 * @memberof signalservice.DataMessage.Payment
                 * @classdesc Represents a Request.
                 * @implements IRequest
                 * @constructor
                 * @param {signalservice.DataMessage.Payment.IRequest=} [properties] Properties to set
                 */
                function Request(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Request requestId.
                 * @member {signalservice.DataMessage.Payment.IRequestId|null|undefined} requestId
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @instance
                 */
                Request.prototype.requestId = null;

                /**
                 * Request amount.
                 * @member {signalservice.DataMessage.Payment.IAmount|null|undefined} amount
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @instance
                 */
                Request.prototype.amount = null;

                /**
                 * Request note.
                 * @member {string} note
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @instance
                 */
                Request.prototype.note = "";

                /**
                 * Creates a new Request instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {signalservice.DataMessage.Payment.IRequest=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Payment.Request} Request instance
                 */
                Request.create = function create(properties) {
                    return new Request(properties);
                };

                /**
                 * Encodes the specified Request message. Does not implicitly {@link signalservice.DataMessage.Payment.Request.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {signalservice.DataMessage.Payment.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                        $root.signalservice.DataMessage.Payment.RequestId.encode(message.requestId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.signalservice.DataMessage.Payment.Amount.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.note);
                    return writer;
                };

                /**
                 * Encodes the specified Request message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Request.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {signalservice.DataMessage.Payment.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Request message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Payment.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Request();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.requestId = $root.signalservice.DataMessage.Payment.RequestId.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.amount = $root.signalservice.DataMessage.Payment.Amount.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.note = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Request message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Payment.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Request message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Request.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requestId != null && message.hasOwnProperty("requestId")) {
                        let error = $root.signalservice.DataMessage.Payment.RequestId.verify(message.requestId);
                        if (error)
                            return "requestId." + error;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        let error = $root.signalservice.DataMessage.Payment.Amount.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.note != null && message.hasOwnProperty("note"))
                        if (!$util.isString(message.note))
                            return "note: string expected";
                    return null;
                };

                /**
                 * Creates a Request message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Payment.Request} Request
                 */
                Request.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Payment.Request)
                        return object;
                    let message = new $root.signalservice.DataMessage.Payment.Request();
                    if (object.requestId != null) {
                        if (typeof object.requestId !== "object")
                            throw TypeError(".signalservice.DataMessage.Payment.Request.requestId: object expected");
                        message.requestId = $root.signalservice.DataMessage.Payment.RequestId.fromObject(object.requestId);
                    }
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".signalservice.DataMessage.Payment.Request.amount: object expected");
                        message.amount = $root.signalservice.DataMessage.Payment.Amount.fromObject(object.amount);
                    }
                    if (object.note != null)
                        message.note = String(object.note);
                    return message;
                };

                /**
                 * Creates a plain object from a Request message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {signalservice.DataMessage.Payment.Request} message Request
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Request.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.requestId = null;
                        object.amount = null;
                        object.note = "";
                    }
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        object.requestId = $root.signalservice.DataMessage.Payment.RequestId.toObject(message.requestId, options);
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.signalservice.DataMessage.Payment.Amount.toObject(message.amount, options);
                    if (message.note != null && message.hasOwnProperty("note"))
                        object.note = message.note;
                    return object;
                };

                /**
                 * Converts this Request to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Request.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Request
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Payment.Request
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Payment.Request";
                };

                return Request;
            })();

            Payment.Notification = (function() {

                /**
                 * Properties of a Notification.
                 * @memberof signalservice.DataMessage.Payment
                 * @interface INotification
                 * @property {signalservice.DataMessage.Payment.Notification.IMobileCoin|null} [mobileCoin] Notification mobileCoin
                 * @property {string|null} [note] Notification note
                 * @property {signalservice.DataMessage.Payment.IRequestId|null} [requestId] Notification requestId
                 */

                /**
                 * Constructs a new Notification.
                 * @memberof signalservice.DataMessage.Payment
                 * @classdesc Represents a Notification.
                 * @implements INotification
                 * @constructor
                 * @param {signalservice.DataMessage.Payment.INotification=} [properties] Properties to set
                 */
                function Notification(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Notification mobileCoin.
                 * @member {signalservice.DataMessage.Payment.Notification.IMobileCoin|null|undefined} mobileCoin
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @instance
                 */
                Notification.prototype.mobileCoin = null;

                /**
                 * Notification note.
                 * @member {string} note
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @instance
                 */
                Notification.prototype.note = "";

                /**
                 * Notification requestId.
                 * @member {signalservice.DataMessage.Payment.IRequestId|null|undefined} requestId
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @instance
                 */
                Notification.prototype.requestId = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Notification Transaction.
                 * @member {"mobileCoin"|undefined} Transaction
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @instance
                 */
                Object.defineProperty(Notification.prototype, "Transaction", {
                    get: $util.oneOfGetter($oneOfFields = ["mobileCoin"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Notification instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {signalservice.DataMessage.Payment.INotification=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Payment.Notification} Notification instance
                 */
                Notification.create = function create(properties) {
                    return new Notification(properties);
                };

                /**
                 * Encodes the specified Notification message. Does not implicitly {@link signalservice.DataMessage.Payment.Notification.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {signalservice.DataMessage.Payment.INotification} message Notification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mobileCoin != null && Object.hasOwnProperty.call(message, "mobileCoin"))
                        $root.signalservice.DataMessage.Payment.Notification.MobileCoin.encode(message.mobileCoin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.note);
                    if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                        $root.signalservice.DataMessage.Payment.RequestId.encode(message.requestId, writer.uint32(/* id 1003, wireType 2 =*/8026).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Notification message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Notification.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {signalservice.DataMessage.Payment.INotification} message Notification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notification.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Notification message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Payment.Notification} Notification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Notification();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.mobileCoin = $root.signalservice.DataMessage.Payment.Notification.MobileCoin.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.note = reader.string();
                                break;
                            }
                        case 1003: {
                                message.requestId = $root.signalservice.DataMessage.Payment.RequestId.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Notification message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Payment.Notification} Notification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notification.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Notification message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Notification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.mobileCoin != null && message.hasOwnProperty("mobileCoin")) {
                        properties.Transaction = 1;
                        {
                            let error = $root.signalservice.DataMessage.Payment.Notification.MobileCoin.verify(message.mobileCoin);
                            if (error)
                                return "mobileCoin." + error;
                        }
                    }
                    if (message.note != null && message.hasOwnProperty("note"))
                        if (!$util.isString(message.note))
                            return "note: string expected";
                    if (message.requestId != null && message.hasOwnProperty("requestId")) {
                        let error = $root.signalservice.DataMessage.Payment.RequestId.verify(message.requestId);
                        if (error)
                            return "requestId." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Notification message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Payment.Notification} Notification
                 */
                Notification.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Payment.Notification)
                        return object;
                    let message = new $root.signalservice.DataMessage.Payment.Notification();
                    if (object.mobileCoin != null) {
                        if (typeof object.mobileCoin !== "object")
                            throw TypeError(".signalservice.DataMessage.Payment.Notification.mobileCoin: object expected");
                        message.mobileCoin = $root.signalservice.DataMessage.Payment.Notification.MobileCoin.fromObject(object.mobileCoin);
                    }
                    if (object.note != null)
                        message.note = String(object.note);
                    if (object.requestId != null) {
                        if (typeof object.requestId !== "object")
                            throw TypeError(".signalservice.DataMessage.Payment.Notification.requestId: object expected");
                        message.requestId = $root.signalservice.DataMessage.Payment.RequestId.fromObject(object.requestId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Notification message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {signalservice.DataMessage.Payment.Notification} message Notification
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Notification.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.note = "";
                        object.requestId = null;
                    }
                    if (message.mobileCoin != null && message.hasOwnProperty("mobileCoin")) {
                        object.mobileCoin = $root.signalservice.DataMessage.Payment.Notification.MobileCoin.toObject(message.mobileCoin, options);
                        if (options.oneofs)
                            object.Transaction = "mobileCoin";
                    }
                    if (message.note != null && message.hasOwnProperty("note"))
                        object.note = message.note;
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        object.requestId = $root.signalservice.DataMessage.Payment.RequestId.toObject(message.requestId, options);
                    return object;
                };

                /**
                 * Converts this Notification to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Notification.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Notification
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Payment.Notification
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Notification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Payment.Notification";
                };

                Notification.MobileCoin = (function() {

                    /**
                     * Properties of a MobileCoin.
                     * @memberof signalservice.DataMessage.Payment.Notification
                     * @interface IMobileCoin
                     * @property {Uint8Array|null} [receipt] MobileCoin receipt
                     */

                    /**
                     * Constructs a new MobileCoin.
                     * @memberof signalservice.DataMessage.Payment.Notification
                     * @classdesc Represents a MobileCoin.
                     * @implements IMobileCoin
                     * @constructor
                     * @param {signalservice.DataMessage.Payment.Notification.IMobileCoin=} [properties] Properties to set
                     */
                    function MobileCoin(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MobileCoin receipt.
                     * @member {Uint8Array} receipt
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @instance
                     */
                    MobileCoin.prototype.receipt = $util.newBuffer([]);

                    /**
                     * Creates a new MobileCoin instance using the specified properties.
                     * @function create
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Notification.IMobileCoin=} [properties] Properties to set
                     * @returns {signalservice.DataMessage.Payment.Notification.MobileCoin} MobileCoin instance
                     */
                    MobileCoin.create = function create(properties) {
                        return new MobileCoin(properties);
                    };

                    /**
                     * Encodes the specified MobileCoin message. Does not implicitly {@link signalservice.DataMessage.Payment.Notification.MobileCoin.verify|verify} messages.
                     * @function encode
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Notification.IMobileCoin} message MobileCoin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MobileCoin.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.receipt);
                        return writer;
                    };

                    /**
                     * Encodes the specified MobileCoin message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Notification.MobileCoin.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Notification.IMobileCoin} message MobileCoin message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MobileCoin.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MobileCoin message from the specified reader or buffer.
                     * @function decode
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {signalservice.DataMessage.Payment.Notification.MobileCoin} MobileCoin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MobileCoin.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Notification.MobileCoin();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.receipt = reader.bytes();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MobileCoin message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {signalservice.DataMessage.Payment.Notification.MobileCoin} MobileCoin
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MobileCoin.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MobileCoin message.
                     * @function verify
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MobileCoin.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.receipt != null && message.hasOwnProperty("receipt"))
                            if (!(message.receipt && typeof message.receipt.length === "number" || $util.isString(message.receipt)))
                                return "receipt: buffer expected";
                        return null;
                    };

                    /**
                     * Creates a MobileCoin message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {signalservice.DataMessage.Payment.Notification.MobileCoin} MobileCoin
                     */
                    MobileCoin.fromObject = function fromObject(object) {
                        if (object instanceof $root.signalservice.DataMessage.Payment.Notification.MobileCoin)
                            return object;
                        let message = new $root.signalservice.DataMessage.Payment.Notification.MobileCoin();
                        if (object.receipt != null)
                            if (typeof object.receipt === "string")
                                $util.base64.decode(object.receipt, message.receipt = $util.newBuffer($util.base64.length(object.receipt)), 0);
                            else if (object.receipt.length >= 0)
                                message.receipt = object.receipt;
                        return message;
                    };

                    /**
                     * Creates a plain object from a MobileCoin message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {signalservice.DataMessage.Payment.Notification.MobileCoin} message MobileCoin
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MobileCoin.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.receipt = "";
                            else {
                                object.receipt = [];
                                if (options.bytes !== Array)
                                    object.receipt = $util.newBuffer(object.receipt);
                            }
                        if (message.receipt != null && message.hasOwnProperty("receipt"))
                            object.receipt = options.bytes === String ? $util.base64.encode(message.receipt, 0, message.receipt.length) : options.bytes === Array ? Array.prototype.slice.call(message.receipt) : message.receipt;
                        return object;
                    };

                    /**
                     * Converts this MobileCoin to JSON.
                     * @function toJSON
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MobileCoin.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MobileCoin
                     * @function getTypeUrl
                     * @memberof signalservice.DataMessage.Payment.Notification.MobileCoin
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MobileCoin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/signalservice.DataMessage.Payment.Notification.MobileCoin";
                    };

                    return MobileCoin;
                })();

                return Notification;
            })();

            Payment.Cancellation = (function() {

                /**
                 * Properties of a Cancellation.
                 * @memberof signalservice.DataMessage.Payment
                 * @interface ICancellation
                 * @property {signalservice.DataMessage.Payment.IRequestId|null} [requestId] Cancellation requestId
                 */

                /**
                 * Constructs a new Cancellation.
                 * @memberof signalservice.DataMessage.Payment
                 * @classdesc Represents a Cancellation.
                 * @implements ICancellation
                 * @constructor
                 * @param {signalservice.DataMessage.Payment.ICancellation=} [properties] Properties to set
                 */
                function Cancellation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Cancellation requestId.
                 * @member {signalservice.DataMessage.Payment.IRequestId|null|undefined} requestId
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @instance
                 */
                Cancellation.prototype.requestId = null;

                /**
                 * Creates a new Cancellation instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {signalservice.DataMessage.Payment.ICancellation=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Payment.Cancellation} Cancellation instance
                 */
                Cancellation.create = function create(properties) {
                    return new Cancellation(properties);
                };

                /**
                 * Encodes the specified Cancellation message. Does not implicitly {@link signalservice.DataMessage.Payment.Cancellation.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {signalservice.DataMessage.Payment.ICancellation} message Cancellation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Cancellation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                        $root.signalservice.DataMessage.Payment.RequestId.encode(message.requestId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Cancellation message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Cancellation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {signalservice.DataMessage.Payment.ICancellation} message Cancellation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Cancellation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Cancellation message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Payment.Cancellation} Cancellation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Cancellation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Cancellation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.requestId = $root.signalservice.DataMessage.Payment.RequestId.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Cancellation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Payment.Cancellation} Cancellation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Cancellation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Cancellation message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Cancellation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requestId != null && message.hasOwnProperty("requestId")) {
                        let error = $root.signalservice.DataMessage.Payment.RequestId.verify(message.requestId);
                        if (error)
                            return "requestId." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Cancellation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Payment.Cancellation} Cancellation
                 */
                Cancellation.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Payment.Cancellation)
                        return object;
                    let message = new $root.signalservice.DataMessage.Payment.Cancellation();
                    if (object.requestId != null) {
                        if (typeof object.requestId !== "object")
                            throw TypeError(".signalservice.DataMessage.Payment.Cancellation.requestId: object expected");
                        message.requestId = $root.signalservice.DataMessage.Payment.RequestId.fromObject(object.requestId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Cancellation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {signalservice.DataMessage.Payment.Cancellation} message Cancellation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Cancellation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.requestId = null;
                    if (message.requestId != null && message.hasOwnProperty("requestId"))
                        object.requestId = $root.signalservice.DataMessage.Payment.RequestId.toObject(message.requestId, options);
                    return object;
                };

                /**
                 * Converts this Cancellation to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Cancellation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Cancellation
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Payment.Cancellation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Cancellation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Payment.Cancellation";
                };

                return Cancellation;
            })();

            Payment.Activation = (function() {

                /**
                 * Properties of an Activation.
                 * @memberof signalservice.DataMessage.Payment
                 * @interface IActivation
                 * @property {signalservice.DataMessage.Payment.Activation.Type|null} [type] Activation type
                 */

                /**
                 * Constructs a new Activation.
                 * @memberof signalservice.DataMessage.Payment
                 * @classdesc Represents an Activation.
                 * @implements IActivation
                 * @constructor
                 * @param {signalservice.DataMessage.Payment.IActivation=} [properties] Properties to set
                 */
                function Activation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Activation type.
                 * @member {signalservice.DataMessage.Payment.Activation.Type} type
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @instance
                 */
                Activation.prototype.type = 0;

                /**
                 * Creates a new Activation instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {signalservice.DataMessage.Payment.IActivation=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Payment.Activation} Activation instance
                 */
                Activation.create = function create(properties) {
                    return new Activation(properties);
                };

                /**
                 * Encodes the specified Activation message. Does not implicitly {@link signalservice.DataMessage.Payment.Activation.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {signalservice.DataMessage.Payment.IActivation} message Activation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Activation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    return writer;
                };

                /**
                 * Encodes the specified Activation message, length delimited. Does not implicitly {@link signalservice.DataMessage.Payment.Activation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {signalservice.DataMessage.Payment.IActivation} message Activation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Activation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Activation message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Payment.Activation} Activation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Activation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Payment.Activation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Activation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Payment.Activation} Activation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Activation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Activation message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Activation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Activation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Payment.Activation} Activation
                 */
                Activation.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Payment.Activation)
                        return object;
                    let message = new $root.signalservice.DataMessage.Payment.Activation();
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "REQUEST":
                    case 0:
                        message.type = 0;
                        break;
                    case "ACTIVATED":
                    case 1:
                        message.type = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Activation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {signalservice.DataMessage.Payment.Activation} message Activation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Activation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.type = options.enums === String ? "REQUEST" : 0;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Payment.Activation.Type[message.type] === undefined ? message.type : $root.signalservice.DataMessage.Payment.Activation.Type[message.type] : message.type;
                    return object;
                };

                /**
                 * Converts this Activation to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Activation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Activation
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Payment.Activation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Activation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Payment.Activation";
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Payment.Activation.Type
                 * @enum {number}
                 * @property {number} REQUEST=0 REQUEST value
                 * @property {number} ACTIVATED=1 ACTIVATED value
                 */
                Activation.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "REQUEST"] = 0;
                    values[valuesById[1] = "ACTIVATED"] = 1;
                    return values;
                })();

                return Activation;
            })();

            return Payment;
        })();

        DataMessage.Quote = (function() {

            /**
             * Properties of a Quote.
             * @memberof signalservice.DataMessage
             * @interface IQuote
             * @property {number|Long|null} [id] Quote id
             * @property {string|null} [authorAci] Quote authorAci
             * @property {string|null} [text] Quote text
             * @property {Array.<signalservice.DataMessage.Quote.IQuotedAttachment>|null} [attachments] Quote attachments
             * @property {Array.<signalservice.DataMessage.IBodyRange>|null} [bodyRanges] Quote bodyRanges
             * @property {signalservice.DataMessage.Quote.Type|null} [type] Quote type
             */

            /**
             * Constructs a new Quote.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Quote.
             * @implements IQuote
             * @constructor
             * @param {signalservice.DataMessage.IQuote=} [properties] Properties to set
             */
            function Quote(properties) {
                this.attachments = [];
                this.bodyRanges = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Quote id.
             * @member {number|Long} id
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Quote authorAci.
             * @member {string} authorAci
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.authorAci = "";

            /**
             * Quote text.
             * @member {string} text
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.text = "";

            /**
             * Quote attachments.
             * @member {Array.<signalservice.DataMessage.Quote.IQuotedAttachment>} attachments
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.attachments = $util.emptyArray;

            /**
             * Quote bodyRanges.
             * @member {Array.<signalservice.DataMessage.IBodyRange>} bodyRanges
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.bodyRanges = $util.emptyArray;

            /**
             * Quote type.
             * @member {signalservice.DataMessage.Quote.Type} type
             * @memberof signalservice.DataMessage.Quote
             * @instance
             */
            Quote.prototype.type = 0;

            /**
             * Creates a new Quote instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.IQuote=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Quote} Quote instance
             */
            Quote.create = function create(properties) {
                return new Quote(properties);
            };

            /**
             * Encodes the specified Quote message. Does not implicitly {@link signalservice.DataMessage.Quote.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.IQuote} message Quote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quote.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
                if (message.attachments != null && message.attachments.length)
                    for (let i = 0; i < message.attachments.length; ++i)
                        $root.signalservice.DataMessage.Quote.QuotedAttachment.encode(message.attachments[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.authorAci != null && Object.hasOwnProperty.call(message, "authorAci"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.authorAci);
                if (message.bodyRanges != null && message.bodyRanges.length)
                    for (let i = 0; i < message.bodyRanges.length; ++i)
                        $root.signalservice.DataMessage.BodyRange.encode(message.bodyRanges[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified Quote message, length delimited. Does not implicitly {@link signalservice.DataMessage.Quote.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.IQuote} message Quote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quote.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Quote message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Quote} Quote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quote.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Quote();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.authorAci = reader.string();
                            break;
                        }
                    case 3: {
                            message.text = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.attachments && message.attachments.length))
                                message.attachments = [];
                            message.attachments.push($root.signalservice.DataMessage.Quote.QuotedAttachment.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            if (!(message.bodyRanges && message.bodyRanges.length))
                                message.bodyRanges = [];
                            message.bodyRanges.push($root.signalservice.DataMessage.BodyRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Quote message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Quote} Quote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quote.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Quote message.
             * @function verify
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Quote.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.authorAci != null && message.hasOwnProperty("authorAci"))
                    if (!$util.isString(message.authorAci))
                        return "authorAci: string expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.attachments != null && message.hasOwnProperty("attachments")) {
                    if (!Array.isArray(message.attachments))
                        return "attachments: array expected";
                    for (let i = 0; i < message.attachments.length; ++i) {
                        let error = $root.signalservice.DataMessage.Quote.QuotedAttachment.verify(message.attachments[i]);
                        if (error)
                            return "attachments." + error;
                    }
                }
                if (message.bodyRanges != null && message.hasOwnProperty("bodyRanges")) {
                    if (!Array.isArray(message.bodyRanges))
                        return "bodyRanges: array expected";
                    for (let i = 0; i < message.bodyRanges.length; ++i) {
                        let error = $root.signalservice.DataMessage.BodyRange.verify(message.bodyRanges[i]);
                        if (error)
                            return "bodyRanges." + error;
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Quote message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Quote} Quote
             */
            Quote.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Quote)
                    return object;
                let message = new $root.signalservice.DataMessage.Quote();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.authorAci != null)
                    message.authorAci = String(object.authorAci);
                if (object.text != null)
                    message.text = String(object.text);
                if (object.attachments) {
                    if (!Array.isArray(object.attachments))
                        throw TypeError(".signalservice.DataMessage.Quote.attachments: array expected");
                    message.attachments = [];
                    for (let i = 0; i < object.attachments.length; ++i) {
                        if (typeof object.attachments[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Quote.attachments: object expected");
                        message.attachments[i] = $root.signalservice.DataMessage.Quote.QuotedAttachment.fromObject(object.attachments[i]);
                    }
                }
                if (object.bodyRanges) {
                    if (!Array.isArray(object.bodyRanges))
                        throw TypeError(".signalservice.DataMessage.Quote.bodyRanges: array expected");
                    message.bodyRanges = [];
                    for (let i = 0; i < object.bodyRanges.length; ++i) {
                        if (typeof object.bodyRanges[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Quote.bodyRanges: object expected");
                        message.bodyRanges[i] = $root.signalservice.DataMessage.BodyRange.fromObject(object.bodyRanges[i]);
                    }
                }
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "NORMAL":
                case 0:
                    message.type = 0;
                    break;
                case "GIFT_BADGE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Quote message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {signalservice.DataMessage.Quote} message Quote
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Quote.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.attachments = [];
                    object.bodyRanges = [];
                }
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    object.text = "";
                    object.authorAci = "";
                    object.type = options.enums === String ? "NORMAL" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.attachments && message.attachments.length) {
                    object.attachments = [];
                    for (let j = 0; j < message.attachments.length; ++j)
                        object.attachments[j] = $root.signalservice.DataMessage.Quote.QuotedAttachment.toObject(message.attachments[j], options);
                }
                if (message.authorAci != null && message.hasOwnProperty("authorAci"))
                    object.authorAci = message.authorAci;
                if (message.bodyRanges && message.bodyRanges.length) {
                    object.bodyRanges = [];
                    for (let j = 0; j < message.bodyRanges.length; ++j)
                        object.bodyRanges[j] = $root.signalservice.DataMessage.BodyRange.toObject(message.bodyRanges[j], options);
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.DataMessage.Quote.Type[message.type] === undefined ? message.type : $root.signalservice.DataMessage.Quote.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Quote to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Quote
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Quote.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Quote
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Quote
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Quote.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Quote";
            };

            /**
             * Type enum.
             * @name signalservice.DataMessage.Quote.Type
             * @enum {number}
             * @property {number} NORMAL=0 NORMAL value
             * @property {number} GIFT_BADGE=1 GIFT_BADGE value
             */
            Quote.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NORMAL"] = 0;
                values[valuesById[1] = "GIFT_BADGE"] = 1;
                return values;
            })();

            Quote.QuotedAttachment = (function() {

                /**
                 * Properties of a QuotedAttachment.
                 * @memberof signalservice.DataMessage.Quote
                 * @interface IQuotedAttachment
                 * @property {string|null} [contentType] QuotedAttachment contentType
                 * @property {string|null} [fileName] QuotedAttachment fileName
                 * @property {signalservice.IAttachmentPointer|null} [thumbnail] QuotedAttachment thumbnail
                 */

                /**
                 * Constructs a new QuotedAttachment.
                 * @memberof signalservice.DataMessage.Quote
                 * @classdesc Represents a QuotedAttachment.
                 * @implements IQuotedAttachment
                 * @constructor
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment=} [properties] Properties to set
                 */
                function QuotedAttachment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QuotedAttachment contentType.
                 * @member {string} contentType
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 */
                QuotedAttachment.prototype.contentType = "";

                /**
                 * QuotedAttachment fileName.
                 * @member {string} fileName
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 */
                QuotedAttachment.prototype.fileName = "";

                /**
                 * QuotedAttachment thumbnail.
                 * @member {signalservice.IAttachmentPointer|null|undefined} thumbnail
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 */
                QuotedAttachment.prototype.thumbnail = null;

                /**
                 * Creates a new QuotedAttachment instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment instance
                 */
                QuotedAttachment.create = function create(properties) {
                    return new QuotedAttachment(properties);
                };

                /**
                 * Encodes the specified QuotedAttachment message. Does not implicitly {@link signalservice.DataMessage.Quote.QuotedAttachment.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment} message QuotedAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuotedAttachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                    if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                    if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                        $root.signalservice.AttachmentPointer.encode(message.thumbnail, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified QuotedAttachment message, length delimited. Does not implicitly {@link signalservice.DataMessage.Quote.QuotedAttachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.IQuotedAttachment} message QuotedAttachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuotedAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QuotedAttachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuotedAttachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Quote.QuotedAttachment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.contentType = reader.string();
                                break;
                            }
                        case 2: {
                                message.fileName = reader.string();
                                break;
                            }
                        case 3: {
                                message.thumbnail = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QuotedAttachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuotedAttachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QuotedAttachment message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QuotedAttachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        if (!$util.isString(message.contentType))
                            return "contentType: string expected";
                    if (message.fileName != null && message.hasOwnProperty("fileName"))
                        if (!$util.isString(message.fileName))
                            return "fileName: string expected";
                    if (message.thumbnail != null && message.hasOwnProperty("thumbnail")) {
                        let error = $root.signalservice.AttachmentPointer.verify(message.thumbnail);
                        if (error)
                            return "thumbnail." + error;
                    }
                    return null;
                };

                /**
                 * Creates a QuotedAttachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Quote.QuotedAttachment} QuotedAttachment
                 */
                QuotedAttachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Quote.QuotedAttachment)
                        return object;
                    let message = new $root.signalservice.DataMessage.Quote.QuotedAttachment();
                    if (object.contentType != null)
                        message.contentType = String(object.contentType);
                    if (object.fileName != null)
                        message.fileName = String(object.fileName);
                    if (object.thumbnail != null) {
                        if (typeof object.thumbnail !== "object")
                            throw TypeError(".signalservice.DataMessage.Quote.QuotedAttachment.thumbnail: object expected");
                        message.thumbnail = $root.signalservice.AttachmentPointer.fromObject(object.thumbnail);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QuotedAttachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {signalservice.DataMessage.Quote.QuotedAttachment} message QuotedAttachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QuotedAttachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.contentType = "";
                        object.fileName = "";
                        object.thumbnail = null;
                    }
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        object.contentType = message.contentType;
                    if (message.fileName != null && message.hasOwnProperty("fileName"))
                        object.fileName = message.fileName;
                    if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                        object.thumbnail = $root.signalservice.AttachmentPointer.toObject(message.thumbnail, options);
                    return object;
                };

                /**
                 * Converts this QuotedAttachment to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QuotedAttachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for QuotedAttachment
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Quote.QuotedAttachment
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                QuotedAttachment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Quote.QuotedAttachment";
                };

                return QuotedAttachment;
            })();

            return Quote;
        })();

        DataMessage.Contact = (function() {

            /**
             * Properties of a Contact.
             * @memberof signalservice.DataMessage
             * @interface IContact
             * @property {signalservice.DataMessage.Contact.IName|null} [name] Contact name
             * @property {Array.<signalservice.DataMessage.Contact.IPhone>|null} [number] Contact number
             * @property {Array.<signalservice.DataMessage.Contact.IEmail>|null} [email] Contact email
             * @property {Array.<signalservice.DataMessage.Contact.IPostalAddress>|null} [address] Contact address
             * @property {signalservice.DataMessage.Contact.IAvatar|null} [avatar] Contact avatar
             * @property {string|null} [organization] Contact organization
             */

            /**
             * Constructs a new Contact.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {signalservice.DataMessage.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                this.number = [];
                this.email = [];
                this.address = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contact name.
             * @member {signalservice.DataMessage.Contact.IName|null|undefined} name
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.name = null;

            /**
             * Contact number.
             * @member {Array.<signalservice.DataMessage.Contact.IPhone>} number
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.number = $util.emptyArray;

            /**
             * Contact email.
             * @member {Array.<signalservice.DataMessage.Contact.IEmail>} email
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.email = $util.emptyArray;

            /**
             * Contact address.
             * @member {Array.<signalservice.DataMessage.Contact.IPostalAddress>} address
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.address = $util.emptyArray;

            /**
             * Contact avatar.
             * @member {signalservice.DataMessage.Contact.IAvatar|null|undefined} avatar
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.avatar = null;

            /**
             * Contact organization.
             * @member {string} organization
             * @memberof signalservice.DataMessage.Contact
             * @instance
             */
            Contact.prototype.organization = "";

            /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.IContact=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Contact} Contact instance
             */
            Contact.create = function create(properties) {
                return new Contact(properties);
            };

            /**
             * Encodes the specified Contact message. Does not implicitly {@link signalservice.DataMessage.Contact.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    $root.signalservice.DataMessage.Contact.Name.encode(message.name, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.number != null && message.number.length)
                    for (let i = 0; i < message.number.length; ++i)
                        $root.signalservice.DataMessage.Contact.Phone.encode(message.number[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.email != null && message.email.length)
                    for (let i = 0; i < message.email.length; ++i)
                        $root.signalservice.DataMessage.Contact.Email.encode(message.email[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.address != null && message.address.length)
                    for (let i = 0; i < message.address.length; ++i)
                        $root.signalservice.DataMessage.Contact.PostalAddress.encode(message.address[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    $root.signalservice.DataMessage.Contact.Avatar.encode(message.avatar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.organization != null && Object.hasOwnProperty.call(message, "organization"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.organization);
                return writer;
            };

            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = $root.signalservice.DataMessage.Contact.Name.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            if (!(message.number && message.number.length))
                                message.number = [];
                            message.number.push($root.signalservice.DataMessage.Contact.Phone.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.email && message.email.length))
                                message.email = [];
                            message.email.push($root.signalservice.DataMessage.Contact.Email.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.address && message.address.length))
                                message.address = [];
                            message.address.push($root.signalservice.DataMessage.Contact.PostalAddress.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            message.avatar = $root.signalservice.DataMessage.Contact.Avatar.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.organization = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contact message.
             * @function verify
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    let error = $root.signalservice.DataMessage.Contact.Name.verify(message.name);
                    if (error)
                        return "name." + error;
                }
                if (message.number != null && message.hasOwnProperty("number")) {
                    if (!Array.isArray(message.number))
                        return "number: array expected";
                    for (let i = 0; i < message.number.length; ++i) {
                        let error = $root.signalservice.DataMessage.Contact.Phone.verify(message.number[i]);
                        if (error)
                            return "number." + error;
                    }
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    if (!Array.isArray(message.email))
                        return "email: array expected";
                    for (let i = 0; i < message.email.length; ++i) {
                        let error = $root.signalservice.DataMessage.Contact.Email.verify(message.email[i]);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.address != null && message.hasOwnProperty("address")) {
                    if (!Array.isArray(message.address))
                        return "address: array expected";
                    for (let i = 0; i < message.address.length; ++i) {
                        let error = $root.signalservice.DataMessage.Contact.PostalAddress.verify(message.address[i]);
                        if (error)
                            return "address." + error;
                    }
                }
                if (message.avatar != null && message.hasOwnProperty("avatar")) {
                    let error = $root.signalservice.DataMessage.Contact.Avatar.verify(message.avatar);
                    if (error)
                        return "avatar." + error;
                }
                if (message.organization != null && message.hasOwnProperty("organization"))
                    if (!$util.isString(message.organization))
                        return "organization: string expected";
                return null;
            };

            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Contact)
                    return object;
                let message = new $root.signalservice.DataMessage.Contact();
                if (object.name != null) {
                    if (typeof object.name !== "object")
                        throw TypeError(".signalservice.DataMessage.Contact.name: object expected");
                    message.name = $root.signalservice.DataMessage.Contact.Name.fromObject(object.name);
                }
                if (object.number) {
                    if (!Array.isArray(object.number))
                        throw TypeError(".signalservice.DataMessage.Contact.number: array expected");
                    message.number = [];
                    for (let i = 0; i < object.number.length; ++i) {
                        if (typeof object.number[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.number: object expected");
                        message.number[i] = $root.signalservice.DataMessage.Contact.Phone.fromObject(object.number[i]);
                    }
                }
                if (object.email) {
                    if (!Array.isArray(object.email))
                        throw TypeError(".signalservice.DataMessage.Contact.email: array expected");
                    message.email = [];
                    for (let i = 0; i < object.email.length; ++i) {
                        if (typeof object.email[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.email: object expected");
                        message.email[i] = $root.signalservice.DataMessage.Contact.Email.fromObject(object.email[i]);
                    }
                }
                if (object.address) {
                    if (!Array.isArray(object.address))
                        throw TypeError(".signalservice.DataMessage.Contact.address: array expected");
                    message.address = [];
                    for (let i = 0; i < object.address.length; ++i) {
                        if (typeof object.address[i] !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.address: object expected");
                        message.address[i] = $root.signalservice.DataMessage.Contact.PostalAddress.fromObject(object.address[i]);
                    }
                }
                if (object.avatar != null) {
                    if (typeof object.avatar !== "object")
                        throw TypeError(".signalservice.DataMessage.Contact.avatar: object expected");
                    message.avatar = $root.signalservice.DataMessage.Contact.Avatar.fromObject(object.avatar);
                }
                if (object.organization != null)
                    message.organization = String(object.organization);
                return message;
            };

            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {signalservice.DataMessage.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.number = [];
                    object.email = [];
                    object.address = [];
                }
                if (options.defaults) {
                    object.name = null;
                    object.avatar = null;
                    object.organization = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = $root.signalservice.DataMessage.Contact.Name.toObject(message.name, options);
                if (message.number && message.number.length) {
                    object.number = [];
                    for (let j = 0; j < message.number.length; ++j)
                        object.number[j] = $root.signalservice.DataMessage.Contact.Phone.toObject(message.number[j], options);
                }
                if (message.email && message.email.length) {
                    object.email = [];
                    for (let j = 0; j < message.email.length; ++j)
                        object.email[j] = $root.signalservice.DataMessage.Contact.Email.toObject(message.email[j], options);
                }
                if (message.address && message.address.length) {
                    object.address = [];
                    for (let j = 0; j < message.address.length; ++j)
                        object.address[j] = $root.signalservice.DataMessage.Contact.PostalAddress.toObject(message.address[j], options);
                }
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = $root.signalservice.DataMessage.Contact.Avatar.toObject(message.avatar, options);
                if (message.organization != null && message.hasOwnProperty("organization"))
                    object.organization = message.organization;
                return object;
            };

            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Contact
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Contact
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Contact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Contact";
            };

            Contact.Name = (function() {

                /**
                 * Properties of a Name.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IName
                 * @property {string|null} [givenName] Name givenName
                 * @property {string|null} [familyName] Name familyName
                 * @property {string|null} [prefix] Name prefix
                 * @property {string|null} [suffix] Name suffix
                 * @property {string|null} [middleName] Name middleName
                 * @property {string|null} [displayName] Name displayName
                 */

                /**
                 * Constructs a new Name.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents a Name.
                 * @implements IName
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IName=} [properties] Properties to set
                 */
                function Name(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Name givenName.
                 * @member {string} givenName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.givenName = "";

                /**
                 * Name familyName.
                 * @member {string} familyName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.familyName = "";

                /**
                 * Name prefix.
                 * @member {string} prefix
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.prefix = "";

                /**
                 * Name suffix.
                 * @member {string} suffix
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.suffix = "";

                /**
                 * Name middleName.
                 * @member {string} middleName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.middleName = "";

                /**
                 * Name displayName.
                 * @member {string} displayName
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 */
                Name.prototype.displayName = "";

                /**
                 * Creates a new Name instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.IName=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Contact.Name} Name instance
                 */
                Name.create = function create(properties) {
                    return new Name(properties);
                };

                /**
                 * Encodes the specified Name message. Does not implicitly {@link signalservice.DataMessage.Contact.Name.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.IName} message Name message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Name.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.givenName != null && Object.hasOwnProperty.call(message, "givenName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.givenName);
                    if (message.familyName != null && Object.hasOwnProperty.call(message, "familyName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.familyName);
                    if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.prefix);
                    if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.suffix);
                    if (message.middleName != null && Object.hasOwnProperty.call(message, "middleName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.middleName);
                    if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.displayName);
                    return writer;
                };

                /**
                 * Encodes the specified Name message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Name.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.IName} message Name message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Name.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Name message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Name} Name
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Name.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Name();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.givenName = reader.string();
                                break;
                            }
                        case 2: {
                                message.familyName = reader.string();
                                break;
                            }
                        case 3: {
                                message.prefix = reader.string();
                                break;
                            }
                        case 4: {
                                message.suffix = reader.string();
                                break;
                            }
                        case 5: {
                                message.middleName = reader.string();
                                break;
                            }
                        case 6: {
                                message.displayName = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Name message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Name} Name
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Name.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Name message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Name.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.givenName != null && message.hasOwnProperty("givenName"))
                        if (!$util.isString(message.givenName))
                            return "givenName: string expected";
                    if (message.familyName != null && message.hasOwnProperty("familyName"))
                        if (!$util.isString(message.familyName))
                            return "familyName: string expected";
                    if (message.prefix != null && message.hasOwnProperty("prefix"))
                        if (!$util.isString(message.prefix))
                            return "prefix: string expected";
                    if (message.suffix != null && message.hasOwnProperty("suffix"))
                        if (!$util.isString(message.suffix))
                            return "suffix: string expected";
                    if (message.middleName != null && message.hasOwnProperty("middleName"))
                        if (!$util.isString(message.middleName))
                            return "middleName: string expected";
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    return null;
                };

                /**
                 * Creates a Name message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Name} Name
                 */
                Name.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Name)
                        return object;
                    let message = new $root.signalservice.DataMessage.Contact.Name();
                    if (object.givenName != null)
                        message.givenName = String(object.givenName);
                    if (object.familyName != null)
                        message.familyName = String(object.familyName);
                    if (object.prefix != null)
                        message.prefix = String(object.prefix);
                    if (object.suffix != null)
                        message.suffix = String(object.suffix);
                    if (object.middleName != null)
                        message.middleName = String(object.middleName);
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    return message;
                };

                /**
                 * Creates a plain object from a Name message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {signalservice.DataMessage.Contact.Name} message Name
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Name.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.givenName = "";
                        object.familyName = "";
                        object.prefix = "";
                        object.suffix = "";
                        object.middleName = "";
                        object.displayName = "";
                    }
                    if (message.givenName != null && message.hasOwnProperty("givenName"))
                        object.givenName = message.givenName;
                    if (message.familyName != null && message.hasOwnProperty("familyName"))
                        object.familyName = message.familyName;
                    if (message.prefix != null && message.hasOwnProperty("prefix"))
                        object.prefix = message.prefix;
                    if (message.suffix != null && message.hasOwnProperty("suffix"))
                        object.suffix = message.suffix;
                    if (message.middleName != null && message.hasOwnProperty("middleName"))
                        object.middleName = message.middleName;
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    return object;
                };

                /**
                 * Converts this Name to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Name.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Name
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Contact.Name
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Name.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Contact.Name";
                };

                return Name;
            })();

            Contact.Phone = (function() {

                /**
                 * Properties of a Phone.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IPhone
                 * @property {string|null} [value] Phone value
                 * @property {signalservice.DataMessage.Contact.Phone.Type|null} [type] Phone type
                 * @property {string|null} [label] Phone label
                 */

                /**
                 * Constructs a new Phone.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents a Phone.
                 * @implements IPhone
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IPhone=} [properties] Properties to set
                 */
                function Phone(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Phone value.
                 * @member {string} value
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 */
                Phone.prototype.value = "";

                /**
                 * Phone type.
                 * @member {signalservice.DataMessage.Contact.Phone.Type} type
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 */
                Phone.prototype.type = 1;

                /**
                 * Phone label.
                 * @member {string} label
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 */
                Phone.prototype.label = "";

                /**
                 * Creates a new Phone instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPhone=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone instance
                 */
                Phone.create = function create(properties) {
                    return new Phone(properties);
                };

                /**
                 * Encodes the specified Phone message. Does not implicitly {@link signalservice.DataMessage.Contact.Phone.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPhone} message Phone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Phone.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.label);
                    return writer;
                };

                /**
                 * Encodes the specified Phone message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Phone.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPhone} message Phone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Phone.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Phone message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Phone.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Phone();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.value = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.label = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Phone message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Phone.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Phone message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Phone.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    return null;
                };

                /**
                 * Creates a Phone message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Phone} Phone
                 */
                Phone.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Phone)
                        return object;
                    let message = new $root.signalservice.DataMessage.Contact.Phone();
                    if (object.value != null)
                        message.value = String(object.value);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "HOME":
                    case 1:
                        message.type = 1;
                        break;
                    case "MOBILE":
                    case 2:
                        message.type = 2;
                        break;
                    case "WORK":
                    case 3:
                        message.type = 3;
                        break;
                    case "CUSTOM":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };

                /**
                 * Creates a plain object from a Phone message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {signalservice.DataMessage.Contact.Phone} message Phone
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Phone.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.value = "";
                        object.type = options.enums === String ? "HOME" : 1;
                        object.label = "";
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Contact.Phone.Type[message.type] === undefined ? message.type : $root.signalservice.DataMessage.Contact.Phone.Type[message.type] : message.type;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };

                /**
                 * Converts this Phone to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Phone.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Phone
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Contact.Phone
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Phone.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Contact.Phone";
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Contact.Phone.Type
                 * @enum {number}
                 * @property {number} HOME=1 HOME value
                 * @property {number} MOBILE=2 MOBILE value
                 * @property {number} WORK=3 WORK value
                 * @property {number} CUSTOM=4 CUSTOM value
                 */
                Phone.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "HOME"] = 1;
                    values[valuesById[2] = "MOBILE"] = 2;
                    values[valuesById[3] = "WORK"] = 3;
                    values[valuesById[4] = "CUSTOM"] = 4;
                    return values;
                })();

                return Phone;
            })();

            Contact.Email = (function() {

                /**
                 * Properties of an Email.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IEmail
                 * @property {string|null} [value] Email value
                 * @property {signalservice.DataMessage.Contact.Email.Type|null} [type] Email type
                 * @property {string|null} [label] Email label
                 */

                /**
                 * Constructs a new Email.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents an Email.
                 * @implements IEmail
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IEmail=} [properties] Properties to set
                 */
                function Email(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Email value.
                 * @member {string} value
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 */
                Email.prototype.value = "";

                /**
                 * Email type.
                 * @member {signalservice.DataMessage.Contact.Email.Type} type
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 */
                Email.prototype.type = 1;

                /**
                 * Email label.
                 * @member {string} label
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 */
                Email.prototype.label = "";

                /**
                 * Creates a new Email instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.IEmail=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Contact.Email} Email instance
                 */
                Email.create = function create(properties) {
                    return new Email(properties);
                };

                /**
                 * Encodes the specified Email message. Does not implicitly {@link signalservice.DataMessage.Contact.Email.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.IEmail} message Email message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Email.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.label);
                    return writer;
                };

                /**
                 * Encodes the specified Email message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Email.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.IEmail} message Email message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Email.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Email message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Email} Email
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Email.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Email();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.value = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.label = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Email message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Email} Email
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Email.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Email message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Email.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    return null;
                };

                /**
                 * Creates an Email message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Email} Email
                 */
                Email.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Email)
                        return object;
                    let message = new $root.signalservice.DataMessage.Contact.Email();
                    if (object.value != null)
                        message.value = String(object.value);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "HOME":
                    case 1:
                        message.type = 1;
                        break;
                    case "MOBILE":
                    case 2:
                        message.type = 2;
                        break;
                    case "WORK":
                    case 3:
                        message.type = 3;
                        break;
                    case "CUSTOM":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };

                /**
                 * Creates a plain object from an Email message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {signalservice.DataMessage.Contact.Email} message Email
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Email.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.value = "";
                        object.type = options.enums === String ? "HOME" : 1;
                        object.label = "";
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Contact.Email.Type[message.type] === undefined ? message.type : $root.signalservice.DataMessage.Contact.Email.Type[message.type] : message.type;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };

                /**
                 * Converts this Email to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Email.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Email
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Contact.Email
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Email.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Contact.Email";
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Contact.Email.Type
                 * @enum {number}
                 * @property {number} HOME=1 HOME value
                 * @property {number} MOBILE=2 MOBILE value
                 * @property {number} WORK=3 WORK value
                 * @property {number} CUSTOM=4 CUSTOM value
                 */
                Email.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "HOME"] = 1;
                    values[valuesById[2] = "MOBILE"] = 2;
                    values[valuesById[3] = "WORK"] = 3;
                    values[valuesById[4] = "CUSTOM"] = 4;
                    return values;
                })();

                return Email;
            })();

            Contact.PostalAddress = (function() {

                /**
                 * Properties of a PostalAddress.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IPostalAddress
                 * @property {signalservice.DataMessage.Contact.PostalAddress.Type|null} [type] PostalAddress type
                 * @property {string|null} [label] PostalAddress label
                 * @property {string|null} [street] PostalAddress street
                 * @property {string|null} [pobox] PostalAddress pobox
                 * @property {string|null} [neighborhood] PostalAddress neighborhood
                 * @property {string|null} [city] PostalAddress city
                 * @property {string|null} [region] PostalAddress region
                 * @property {string|null} [postcode] PostalAddress postcode
                 * @property {string|null} [country] PostalAddress country
                 */

                /**
                 * Constructs a new PostalAddress.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents a PostalAddress.
                 * @implements IPostalAddress
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IPostalAddress=} [properties] Properties to set
                 */
                function PostalAddress(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PostalAddress type.
                 * @member {signalservice.DataMessage.Contact.PostalAddress.Type} type
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.type = 1;

                /**
                 * PostalAddress label.
                 * @member {string} label
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.label = "";

                /**
                 * PostalAddress street.
                 * @member {string} street
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.street = "";

                /**
                 * PostalAddress pobox.
                 * @member {string} pobox
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.pobox = "";

                /**
                 * PostalAddress neighborhood.
                 * @member {string} neighborhood
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.neighborhood = "";

                /**
                 * PostalAddress city.
                 * @member {string} city
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.city = "";

                /**
                 * PostalAddress region.
                 * @member {string} region
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.region = "";

                /**
                 * PostalAddress postcode.
                 * @member {string} postcode
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.postcode = "";

                /**
                 * PostalAddress country.
                 * @member {string} country
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 */
                PostalAddress.prototype.country = "";

                /**
                 * Creates a new PostalAddress instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPostalAddress=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress instance
                 */
                PostalAddress.create = function create(properties) {
                    return new PostalAddress(properties);
                };

                /**
                 * Encodes the specified PostalAddress message. Does not implicitly {@link signalservice.DataMessage.Contact.PostalAddress.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPostalAddress} message PostalAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PostalAddress.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                    if (message.street != null && Object.hasOwnProperty.call(message, "street"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.street);
                    if (message.pobox != null && Object.hasOwnProperty.call(message, "pobox"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.pobox);
                    if (message.neighborhood != null && Object.hasOwnProperty.call(message, "neighborhood"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.neighborhood);
                    if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.city);
                    if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.region);
                    if (message.postcode != null && Object.hasOwnProperty.call(message, "postcode"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.postcode);
                    if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.country);
                    return writer;
                };

                /**
                 * Encodes the specified PostalAddress message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.PostalAddress.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.IPostalAddress} message PostalAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PostalAddress.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PostalAddress message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PostalAddress.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.PostalAddress();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        case 2: {
                                message.label = reader.string();
                                break;
                            }
                        case 3: {
                                message.street = reader.string();
                                break;
                            }
                        case 4: {
                                message.pobox = reader.string();
                                break;
                            }
                        case 5: {
                                message.neighborhood = reader.string();
                                break;
                            }
                        case 6: {
                                message.city = reader.string();
                                break;
                            }
                        case 7: {
                                message.region = reader.string();
                                break;
                            }
                        case 8: {
                                message.postcode = reader.string();
                                break;
                            }
                        case 9: {
                                message.country = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PostalAddress message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PostalAddress.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PostalAddress message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PostalAddress.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.street != null && message.hasOwnProperty("street"))
                        if (!$util.isString(message.street))
                            return "street: string expected";
                    if (message.pobox != null && message.hasOwnProperty("pobox"))
                        if (!$util.isString(message.pobox))
                            return "pobox: string expected";
                    if (message.neighborhood != null && message.hasOwnProperty("neighborhood"))
                        if (!$util.isString(message.neighborhood))
                            return "neighborhood: string expected";
                    if (message.city != null && message.hasOwnProperty("city"))
                        if (!$util.isString(message.city))
                            return "city: string expected";
                    if (message.region != null && message.hasOwnProperty("region"))
                        if (!$util.isString(message.region))
                            return "region: string expected";
                    if (message.postcode != null && message.hasOwnProperty("postcode"))
                        if (!$util.isString(message.postcode))
                            return "postcode: string expected";
                    if (message.country != null && message.hasOwnProperty("country"))
                        if (!$util.isString(message.country))
                            return "country: string expected";
                    return null;
                };

                /**
                 * Creates a PostalAddress message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.PostalAddress} PostalAddress
                 */
                PostalAddress.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.PostalAddress)
                        return object;
                    let message = new $root.signalservice.DataMessage.Contact.PostalAddress();
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "HOME":
                    case 1:
                        message.type = 1;
                        break;
                    case "WORK":
                    case 2:
                        message.type = 2;
                        break;
                    case "CUSTOM":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.street != null)
                        message.street = String(object.street);
                    if (object.pobox != null)
                        message.pobox = String(object.pobox);
                    if (object.neighborhood != null)
                        message.neighborhood = String(object.neighborhood);
                    if (object.city != null)
                        message.city = String(object.city);
                    if (object.region != null)
                        message.region = String(object.region);
                    if (object.postcode != null)
                        message.postcode = String(object.postcode);
                    if (object.country != null)
                        message.country = String(object.country);
                    return message;
                };

                /**
                 * Creates a plain object from a PostalAddress message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {signalservice.DataMessage.Contact.PostalAddress} message PostalAddress
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PostalAddress.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "HOME" : 1;
                        object.label = "";
                        object.street = "";
                        object.pobox = "";
                        object.neighborhood = "";
                        object.city = "";
                        object.region = "";
                        object.postcode = "";
                        object.country = "";
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.signalservice.DataMessage.Contact.PostalAddress.Type[message.type] === undefined ? message.type : $root.signalservice.DataMessage.Contact.PostalAddress.Type[message.type] : message.type;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.street != null && message.hasOwnProperty("street"))
                        object.street = message.street;
                    if (message.pobox != null && message.hasOwnProperty("pobox"))
                        object.pobox = message.pobox;
                    if (message.neighborhood != null && message.hasOwnProperty("neighborhood"))
                        object.neighborhood = message.neighborhood;
                    if (message.city != null && message.hasOwnProperty("city"))
                        object.city = message.city;
                    if (message.region != null && message.hasOwnProperty("region"))
                        object.region = message.region;
                    if (message.postcode != null && message.hasOwnProperty("postcode"))
                        object.postcode = message.postcode;
                    if (message.country != null && message.hasOwnProperty("country"))
                        object.country = message.country;
                    return object;
                };

                /**
                 * Converts this PostalAddress to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PostalAddress.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PostalAddress
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Contact.PostalAddress
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PostalAddress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Contact.PostalAddress";
                };

                /**
                 * Type enum.
                 * @name signalservice.DataMessage.Contact.PostalAddress.Type
                 * @enum {number}
                 * @property {number} HOME=1 HOME value
                 * @property {number} WORK=2 WORK value
                 * @property {number} CUSTOM=3 CUSTOM value
                 */
                PostalAddress.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "HOME"] = 1;
                    values[valuesById[2] = "WORK"] = 2;
                    values[valuesById[3] = "CUSTOM"] = 3;
                    return values;
                })();

                return PostalAddress;
            })();

            Contact.Avatar = (function() {

                /**
                 * Properties of an Avatar.
                 * @memberof signalservice.DataMessage.Contact
                 * @interface IAvatar
                 * @property {signalservice.IAttachmentPointer|null} [avatar] Avatar avatar
                 * @property {boolean|null} [isProfile] Avatar isProfile
                 */

                /**
                 * Constructs a new Avatar.
                 * @memberof signalservice.DataMessage.Contact
                 * @classdesc Represents an Avatar.
                 * @implements IAvatar
                 * @constructor
                 * @param {signalservice.DataMessage.Contact.IAvatar=} [properties] Properties to set
                 */
                function Avatar(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Avatar avatar.
                 * @member {signalservice.IAttachmentPointer|null|undefined} avatar
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @instance
                 */
                Avatar.prototype.avatar = null;

                /**
                 * Avatar isProfile.
                 * @member {boolean} isProfile
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @instance
                 */
                Avatar.prototype.isProfile = false;

                /**
                 * Creates a new Avatar instance using the specified properties.
                 * @function create
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.IAvatar=} [properties] Properties to set
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar instance
                 */
                Avatar.create = function create(properties) {
                    return new Avatar(properties);
                };

                /**
                 * Encodes the specified Avatar message. Does not implicitly {@link signalservice.DataMessage.Contact.Avatar.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.IAvatar} message Avatar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Avatar.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                        $root.signalservice.AttachmentPointer.encode(message.avatar, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.isProfile != null && Object.hasOwnProperty.call(message, "isProfile"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isProfile);
                    return writer;
                };

                /**
                 * Encodes the specified Avatar message, length delimited. Does not implicitly {@link signalservice.DataMessage.Contact.Avatar.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.IAvatar} message Avatar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Avatar.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Avatar message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Avatar.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Contact.Avatar();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.avatar = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.isProfile = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Avatar message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Avatar.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Avatar message.
                 * @function verify
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Avatar.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.avatar != null && message.hasOwnProperty("avatar")) {
                        let error = $root.signalservice.AttachmentPointer.verify(message.avatar);
                        if (error)
                            return "avatar." + error;
                    }
                    if (message.isProfile != null && message.hasOwnProperty("isProfile"))
                        if (typeof message.isProfile !== "boolean")
                            return "isProfile: boolean expected";
                    return null;
                };

                /**
                 * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.DataMessage.Contact.Avatar} Avatar
                 */
                Avatar.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.DataMessage.Contact.Avatar)
                        return object;
                    let message = new $root.signalservice.DataMessage.Contact.Avatar();
                    if (object.avatar != null) {
                        if (typeof object.avatar !== "object")
                            throw TypeError(".signalservice.DataMessage.Contact.Avatar.avatar: object expected");
                        message.avatar = $root.signalservice.AttachmentPointer.fromObject(object.avatar);
                    }
                    if (object.isProfile != null)
                        message.isProfile = Boolean(object.isProfile);
                    return message;
                };

                /**
                 * Creates a plain object from an Avatar message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {signalservice.DataMessage.Contact.Avatar} message Avatar
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Avatar.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.avatar = null;
                        object.isProfile = false;
                    }
                    if (message.avatar != null && message.hasOwnProperty("avatar"))
                        object.avatar = $root.signalservice.AttachmentPointer.toObject(message.avatar, options);
                    if (message.isProfile != null && message.hasOwnProperty("isProfile"))
                        object.isProfile = message.isProfile;
                    return object;
                };

                /**
                 * Converts this Avatar to JSON.
                 * @function toJSON
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Avatar.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Avatar
                 * @function getTypeUrl
                 * @memberof signalservice.DataMessage.Contact.Avatar
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Avatar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.DataMessage.Contact.Avatar";
                };

                return Avatar;
            })();

            return Contact;
        })();

        DataMessage.Preview = (function() {

            /**
             * Properties of a Preview.
             * @memberof signalservice.DataMessage
             * @interface IPreview
             * @property {string|null} [url] Preview url
             * @property {string|null} [title] Preview title
             * @property {signalservice.IAttachmentPointer|null} [image] Preview image
             * @property {string|null} [description] Preview description
             * @property {number|Long|null} [date] Preview date
             */

            /**
             * Constructs a new Preview.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Preview.
             * @implements IPreview
             * @constructor
             * @param {signalservice.DataMessage.IPreview=} [properties] Properties to set
             */
            function Preview(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Preview url.
             * @member {string} url
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.url = "";

            /**
             * Preview title.
             * @member {string} title
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.title = "";

            /**
             * Preview image.
             * @member {signalservice.IAttachmentPointer|null|undefined} image
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.image = null;

            /**
             * Preview description.
             * @member {string} description
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.description = "";

            /**
             * Preview date.
             * @member {number|Long} date
             * @memberof signalservice.DataMessage.Preview
             * @instance
             */
            Preview.prototype.date = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Preview instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.IPreview=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Preview} Preview instance
             */
            Preview.create = function create(properties) {
                return new Preview(properties);
            };

            /**
             * Encodes the specified Preview message. Does not implicitly {@link signalservice.DataMessage.Preview.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.IPreview} message Preview message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Preview.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.signalservice.AttachmentPointer.encode(message.image, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                if (message.date != null && Object.hasOwnProperty.call(message, "date"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.date);
                return writer;
            };

            /**
             * Encodes the specified Preview message, length delimited. Does not implicitly {@link signalservice.DataMessage.Preview.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.IPreview} message Preview message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Preview.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Preview message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Preview} Preview
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Preview.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Preview();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.image = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.description = reader.string();
                            break;
                        }
                    case 5: {
                            message.date = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Preview message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Preview} Preview
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Preview.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Preview message.
             * @function verify
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Preview.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.image != null && message.hasOwnProperty("image")) {
                    let error = $root.signalservice.AttachmentPointer.verify(message.image);
                    if (error)
                        return "image." + error;
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.date != null && message.hasOwnProperty("date"))
                    if (!$util.isInteger(message.date) && !(message.date && $util.isInteger(message.date.low) && $util.isInteger(message.date.high)))
                        return "date: integer|Long expected";
                return null;
            };

            /**
             * Creates a Preview message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Preview} Preview
             */
            Preview.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Preview)
                    return object;
                let message = new $root.signalservice.DataMessage.Preview();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".signalservice.DataMessage.Preview.image: object expected");
                    message.image = $root.signalservice.AttachmentPointer.fromObject(object.image);
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.date != null)
                    if ($util.Long)
                        (message.date = $util.Long.fromValue(object.date)).unsigned = true;
                    else if (typeof object.date === "string")
                        message.date = parseInt(object.date, 10);
                    else if (typeof object.date === "number")
                        message.date = object.date;
                    else if (typeof object.date === "object")
                        message.date = new $util.LongBits(object.date.low >>> 0, object.date.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Preview message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {signalservice.DataMessage.Preview} message Preview
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Preview.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.title = "";
                    object.image = null;
                    object.description = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.date = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.date = options.longs === String ? "0" : 0;
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = $root.signalservice.AttachmentPointer.toObject(message.image, options);
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.date != null && message.hasOwnProperty("date"))
                    if (typeof message.date === "number")
                        object.date = options.longs === String ? String(message.date) : message.date;
                    else
                        object.date = options.longs === String ? $util.Long.prototype.toString.call(message.date) : options.longs === Number ? new $util.LongBits(message.date.low >>> 0, message.date.high >>> 0).toNumber(true) : message.date;
                return object;
            };

            /**
             * Converts this Preview to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Preview
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Preview.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Preview
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Preview
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Preview.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Preview";
            };

            return Preview;
        })();

        DataMessage.Sticker = (function() {

            /**
             * Properties of a Sticker.
             * @memberof signalservice.DataMessage
             * @interface ISticker
             * @property {Uint8Array|null} [packId] Sticker packId
             * @property {Uint8Array|null} [packKey] Sticker packKey
             * @property {number|null} [stickerId] Sticker stickerId
             * @property {signalservice.IAttachmentPointer|null} [data] Sticker data
             * @property {string|null} [emoji] Sticker emoji
             */

            /**
             * Constructs a new Sticker.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Sticker.
             * @implements ISticker
             * @constructor
             * @param {signalservice.DataMessage.ISticker=} [properties] Properties to set
             */
            function Sticker(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sticker packId.
             * @member {Uint8Array} packId
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.packId = $util.newBuffer([]);

            /**
             * Sticker packKey.
             * @member {Uint8Array} packKey
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.packKey = $util.newBuffer([]);

            /**
             * Sticker stickerId.
             * @member {number} stickerId
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.stickerId = 0;

            /**
             * Sticker data.
             * @member {signalservice.IAttachmentPointer|null|undefined} data
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.data = null;

            /**
             * Sticker emoji.
             * @member {string} emoji
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             */
            Sticker.prototype.emoji = "";

            /**
             * Creates a new Sticker instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.ISticker=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Sticker} Sticker instance
             */
            Sticker.create = function create(properties) {
                return new Sticker(properties);
            };

            /**
             * Encodes the specified Sticker message. Does not implicitly {@link signalservice.DataMessage.Sticker.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.ISticker} message Sticker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sticker.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packId != null && Object.hasOwnProperty.call(message, "packId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.packId);
                if (message.packKey != null && Object.hasOwnProperty.call(message, "packKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packKey);
                if (message.stickerId != null && Object.hasOwnProperty.call(message, "stickerId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stickerId);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.signalservice.AttachmentPointer.encode(message.data, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.emoji);
                return writer;
            };

            /**
             * Encodes the specified Sticker message, length delimited. Does not implicitly {@link signalservice.DataMessage.Sticker.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.ISticker} message Sticker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sticker.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sticker message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Sticker} Sticker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sticker.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Sticker();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.packId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.packKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.stickerId = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.data = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.emoji = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sticker message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Sticker} Sticker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sticker.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sticker message.
             * @function verify
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sticker.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packId != null && message.hasOwnProperty("packId"))
                    if (!(message.packId && typeof message.packId.length === "number" || $util.isString(message.packId)))
                        return "packId: buffer expected";
                if (message.packKey != null && message.hasOwnProperty("packKey"))
                    if (!(message.packKey && typeof message.packKey.length === "number" || $util.isString(message.packKey)))
                        return "packKey: buffer expected";
                if (message.stickerId != null && message.hasOwnProperty("stickerId"))
                    if (!$util.isInteger(message.stickerId))
                        return "stickerId: integer expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    let error = $root.signalservice.AttachmentPointer.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    if (!$util.isString(message.emoji))
                        return "emoji: string expected";
                return null;
            };

            /**
             * Creates a Sticker message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Sticker} Sticker
             */
            Sticker.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Sticker)
                    return object;
                let message = new $root.signalservice.DataMessage.Sticker();
                if (object.packId != null)
                    if (typeof object.packId === "string")
                        $util.base64.decode(object.packId, message.packId = $util.newBuffer($util.base64.length(object.packId)), 0);
                    else if (object.packId.length >= 0)
                        message.packId = object.packId;
                if (object.packKey != null)
                    if (typeof object.packKey === "string")
                        $util.base64.decode(object.packKey, message.packKey = $util.newBuffer($util.base64.length(object.packKey)), 0);
                    else if (object.packKey.length >= 0)
                        message.packKey = object.packKey;
                if (object.stickerId != null)
                    message.stickerId = object.stickerId >>> 0;
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".signalservice.DataMessage.Sticker.data: object expected");
                    message.data = $root.signalservice.AttachmentPointer.fromObject(object.data);
                }
                if (object.emoji != null)
                    message.emoji = String(object.emoji);
                return message;
            };

            /**
             * Creates a plain object from a Sticker message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {signalservice.DataMessage.Sticker} message Sticker
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sticker.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.packId = "";
                    else {
                        object.packId = [];
                        if (options.bytes !== Array)
                            object.packId = $util.newBuffer(object.packId);
                    }
                    if (options.bytes === String)
                        object.packKey = "";
                    else {
                        object.packKey = [];
                        if (options.bytes !== Array)
                            object.packKey = $util.newBuffer(object.packKey);
                    }
                    object.stickerId = 0;
                    object.data = null;
                    object.emoji = "";
                }
                if (message.packId != null && message.hasOwnProperty("packId"))
                    object.packId = options.bytes === String ? $util.base64.encode(message.packId, 0, message.packId.length) : options.bytes === Array ? Array.prototype.slice.call(message.packId) : message.packId;
                if (message.packKey != null && message.hasOwnProperty("packKey"))
                    object.packKey = options.bytes === String ? $util.base64.encode(message.packKey, 0, message.packKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.packKey) : message.packKey;
                if (message.stickerId != null && message.hasOwnProperty("stickerId"))
                    object.stickerId = message.stickerId;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.signalservice.AttachmentPointer.toObject(message.data, options);
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    object.emoji = message.emoji;
                return object;
            };

            /**
             * Converts this Sticker to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Sticker
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sticker.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sticker
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Sticker
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sticker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Sticker";
            };

            return Sticker;
        })();

        DataMessage.Reaction = (function() {

            /**
             * Properties of a Reaction.
             * @memberof signalservice.DataMessage
             * @interface IReaction
             * @property {string|null} [emoji] Reaction emoji
             * @property {boolean|null} [remove] Reaction remove
             * @property {string|null} [targetAuthorAci] Reaction targetAuthorAci
             * @property {number|Long|null} [targetTimestamp] Reaction targetTimestamp
             */

            /**
             * Constructs a new Reaction.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Reaction.
             * @implements IReaction
             * @constructor
             * @param {signalservice.DataMessage.IReaction=} [properties] Properties to set
             */
            function Reaction(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reaction emoji.
             * @member {string} emoji
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.emoji = "";

            /**
             * Reaction remove.
             * @member {boolean} remove
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.remove = false;

            /**
             * Reaction targetAuthorAci.
             * @member {string} targetAuthorAci
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.targetAuthorAci = "";

            /**
             * Reaction targetTimestamp.
             * @member {number|Long} targetTimestamp
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             */
            Reaction.prototype.targetTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Reaction instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.IReaction=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Reaction} Reaction instance
             */
            Reaction.create = function create(properties) {
                return new Reaction(properties);
            };

            /**
             * Encodes the specified Reaction message. Does not implicitly {@link signalservice.DataMessage.Reaction.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.IReaction} message Reaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.emoji);
                if (message.remove != null && Object.hasOwnProperty.call(message, "remove"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.remove);
                if (message.targetAuthorAci != null && Object.hasOwnProperty.call(message, "targetAuthorAci"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetAuthorAci);
                if (message.targetTimestamp != null && Object.hasOwnProperty.call(message, "targetTimestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetTimestamp);
                return writer;
            };

            /**
             * Encodes the specified Reaction message, length delimited. Does not implicitly {@link signalservice.DataMessage.Reaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.IReaction} message Reaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Reaction message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Reaction} Reaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Reaction();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.emoji = reader.string();
                            break;
                        }
                    case 2: {
                            message.remove = reader.bool();
                            break;
                        }
                    case 4: {
                            message.targetAuthorAci = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetTimestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Reaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Reaction} Reaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Reaction message.
             * @function verify
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Reaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    if (!$util.isString(message.emoji))
                        return "emoji: string expected";
                if (message.remove != null && message.hasOwnProperty("remove"))
                    if (typeof message.remove !== "boolean")
                        return "remove: boolean expected";
                if (message.targetAuthorAci != null && message.hasOwnProperty("targetAuthorAci"))
                    if (!$util.isString(message.targetAuthorAci))
                        return "targetAuthorAci: string expected";
                if (message.targetTimestamp != null && message.hasOwnProperty("targetTimestamp"))
                    if (!$util.isInteger(message.targetTimestamp) && !(message.targetTimestamp && $util.isInteger(message.targetTimestamp.low) && $util.isInteger(message.targetTimestamp.high)))
                        return "targetTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Reaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Reaction} Reaction
             */
            Reaction.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Reaction)
                    return object;
                let message = new $root.signalservice.DataMessage.Reaction();
                if (object.emoji != null)
                    message.emoji = String(object.emoji);
                if (object.remove != null)
                    message.remove = Boolean(object.remove);
                if (object.targetAuthorAci != null)
                    message.targetAuthorAci = String(object.targetAuthorAci);
                if (object.targetTimestamp != null)
                    if ($util.Long)
                        (message.targetTimestamp = $util.Long.fromValue(object.targetTimestamp)).unsigned = true;
                    else if (typeof object.targetTimestamp === "string")
                        message.targetTimestamp = parseInt(object.targetTimestamp, 10);
                    else if (typeof object.targetTimestamp === "number")
                        message.targetTimestamp = object.targetTimestamp;
                    else if (typeof object.targetTimestamp === "object")
                        message.targetTimestamp = new $util.LongBits(object.targetTimestamp.low >>> 0, object.targetTimestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Reaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {signalservice.DataMessage.Reaction} message Reaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Reaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.emoji = "";
                    object.remove = false;
                    object.targetAuthorAci = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.emoji != null && message.hasOwnProperty("emoji"))
                    object.emoji = message.emoji;
                if (message.remove != null && message.hasOwnProperty("remove"))
                    object.remove = message.remove;
                if (message.targetAuthorAci != null && message.hasOwnProperty("targetAuthorAci"))
                    object.targetAuthorAci = message.targetAuthorAci;
                if (message.targetTimestamp != null && message.hasOwnProperty("targetTimestamp"))
                    if (typeof message.targetTimestamp === "number")
                        object.targetTimestamp = options.longs === String ? String(message.targetTimestamp) : message.targetTimestamp;
                    else
                        object.targetTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.targetTimestamp) : options.longs === Number ? new $util.LongBits(message.targetTimestamp.low >>> 0, message.targetTimestamp.high >>> 0).toNumber(true) : message.targetTimestamp;
                return object;
            };

            /**
             * Converts this Reaction to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Reaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Reaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Reaction
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Reaction
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Reaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Reaction";
            };

            return Reaction;
        })();

        DataMessage.Delete = (function() {

            /**
             * Properties of a Delete.
             * @memberof signalservice.DataMessage
             * @interface IDelete
             * @property {number|Long|null} [targetSentTimestamp] Delete targetSentTimestamp
             */

            /**
             * Constructs a new Delete.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a Delete.
             * @implements IDelete
             * @constructor
             * @param {signalservice.DataMessage.IDelete=} [properties] Properties to set
             */
            function Delete(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Delete targetSentTimestamp.
             * @member {number|Long} targetSentTimestamp
             * @memberof signalservice.DataMessage.Delete
             * @instance
             */
            Delete.prototype.targetSentTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Delete instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.IDelete=} [properties] Properties to set
             * @returns {signalservice.DataMessage.Delete} Delete instance
             */
            Delete.create = function create(properties) {
                return new Delete(properties);
            };

            /**
             * Encodes the specified Delete message. Does not implicitly {@link signalservice.DataMessage.Delete.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.IDelete} message Delete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Delete.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetSentTimestamp != null && Object.hasOwnProperty.call(message, "targetSentTimestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.targetSentTimestamp);
                return writer;
            };

            /**
             * Encodes the specified Delete message, length delimited. Does not implicitly {@link signalservice.DataMessage.Delete.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.IDelete} message Delete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Delete.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Delete message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.Delete} Delete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Delete.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.Delete();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.targetSentTimestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Delete message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.Delete} Delete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Delete.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Delete message.
             * @function verify
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Delete.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetSentTimestamp != null && message.hasOwnProperty("targetSentTimestamp"))
                    if (!$util.isInteger(message.targetSentTimestamp) && !(message.targetSentTimestamp && $util.isInteger(message.targetSentTimestamp.low) && $util.isInteger(message.targetSentTimestamp.high)))
                        return "targetSentTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Delete message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.Delete} Delete
             */
            Delete.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.Delete)
                    return object;
                let message = new $root.signalservice.DataMessage.Delete();
                if (object.targetSentTimestamp != null)
                    if ($util.Long)
                        (message.targetSentTimestamp = $util.Long.fromValue(object.targetSentTimestamp)).unsigned = true;
                    else if (typeof object.targetSentTimestamp === "string")
                        message.targetSentTimestamp = parseInt(object.targetSentTimestamp, 10);
                    else if (typeof object.targetSentTimestamp === "number")
                        message.targetSentTimestamp = object.targetSentTimestamp;
                    else if (typeof object.targetSentTimestamp === "object")
                        message.targetSentTimestamp = new $util.LongBits(object.targetSentTimestamp.low >>> 0, object.targetSentTimestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Delete message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {signalservice.DataMessage.Delete} message Delete
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Delete.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetSentTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetSentTimestamp = options.longs === String ? "0" : 0;
                if (message.targetSentTimestamp != null && message.hasOwnProperty("targetSentTimestamp"))
                    if (typeof message.targetSentTimestamp === "number")
                        object.targetSentTimestamp = options.longs === String ? String(message.targetSentTimestamp) : message.targetSentTimestamp;
                    else
                        object.targetSentTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.targetSentTimestamp) : options.longs === Number ? new $util.LongBits(message.targetSentTimestamp.low >>> 0, message.targetSentTimestamp.high >>> 0).toNumber(true) : message.targetSentTimestamp;
                return object;
            };

            /**
             * Converts this Delete to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.Delete
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Delete.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Delete
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.Delete
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Delete.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.Delete";
            };

            return Delete;
        })();

        DataMessage.BodyRange = (function() {

            /**
             * Properties of a BodyRange.
             * @memberof signalservice.DataMessage
             * @interface IBodyRange
             * @property {number|null} [start] BodyRange start
             * @property {number|null} [length] BodyRange length
             * @property {string|null} [mentionAci] BodyRange mentionAci
             * @property {signalservice.DataMessage.BodyRange.Style|null} [style] BodyRange style
             */

            /**
             * Constructs a new BodyRange.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a BodyRange.
             * @implements IBodyRange
             * @constructor
             * @param {signalservice.DataMessage.IBodyRange=} [properties] Properties to set
             */
            function BodyRange(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BodyRange start.
             * @member {number} start
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.start = 0;

            /**
             * BodyRange length.
             * @member {number} length
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.length = 0;

            /**
             * BodyRange mentionAci.
             * @member {string|null|undefined} mentionAci
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.mentionAci = null;

            /**
             * BodyRange style.
             * @member {signalservice.DataMessage.BodyRange.Style|null|undefined} style
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            BodyRange.prototype.style = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BodyRange associatedValue.
             * @member {"mentionAci"|"style"|undefined} associatedValue
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             */
            Object.defineProperty(BodyRange.prototype, "associatedValue", {
                get: $util.oneOfGetter($oneOfFields = ["mentionAci", "style"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BodyRange instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.IBodyRange=} [properties] Properties to set
             * @returns {signalservice.DataMessage.BodyRange} BodyRange instance
             */
            BodyRange.create = function create(properties) {
                return new BodyRange(properties);
            };

            /**
             * Encodes the specified BodyRange message. Does not implicitly {@link signalservice.DataMessage.BodyRange.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.IBodyRange} message BodyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BodyRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.start);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.length);
                if (message.mentionAci != null && Object.hasOwnProperty.call(message, "mentionAci"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mentionAci);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.style);
                return writer;
            };

            /**
             * Encodes the specified BodyRange message, length delimited. Does not implicitly {@link signalservice.DataMessage.BodyRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.IBodyRange} message BodyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BodyRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BodyRange message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.BodyRange} BodyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BodyRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.BodyRange();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.start = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.length = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.mentionAci = reader.string();
                            break;
                        }
                    case 4: {
                            message.style = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BodyRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.BodyRange} BodyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BodyRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BodyRange message.
             * @function verify
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BodyRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start))
                        return "start: integer expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                if (message.mentionAci != null && message.hasOwnProperty("mentionAci")) {
                    properties.associatedValue = 1;
                    if (!$util.isString(message.mentionAci))
                        return "mentionAci: string expected";
                }
                if (message.style != null && message.hasOwnProperty("style")) {
                    if (properties.associatedValue === 1)
                        return "associatedValue: multiple values";
                    properties.associatedValue = 1;
                    switch (message.style) {
                    default:
                        return "style: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                }
                return null;
            };

            /**
             * Creates a BodyRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.BodyRange} BodyRange
             */
            BodyRange.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.BodyRange)
                    return object;
                let message = new $root.signalservice.DataMessage.BodyRange();
                if (object.start != null)
                    message.start = object.start >>> 0;
                if (object.length != null)
                    message.length = object.length >>> 0;
                if (object.mentionAci != null)
                    message.mentionAci = String(object.mentionAci);
                switch (object.style) {
                default:
                    if (typeof object.style === "number") {
                        message.style = object.style;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.style = 0;
                    break;
                case "BOLD":
                case 1:
                    message.style = 1;
                    break;
                case "ITALIC":
                case 2:
                    message.style = 2;
                    break;
                case "SPOILER":
                case 3:
                    message.style = 3;
                    break;
                case "STRIKETHROUGH":
                case 4:
                    message.style = 4;
                    break;
                case "MONOSPACE":
                case 5:
                    message.style = 5;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a BodyRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {signalservice.DataMessage.BodyRange} message BodyRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BodyRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.start = 0;
                    object.length = 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = message.start;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                if (message.mentionAci != null && message.hasOwnProperty("mentionAci")) {
                    object.mentionAci = message.mentionAci;
                    if (options.oneofs)
                        object.associatedValue = "mentionAci";
                }
                if (message.style != null && message.hasOwnProperty("style")) {
                    object.style = options.enums === String ? $root.signalservice.DataMessage.BodyRange.Style[message.style] === undefined ? message.style : $root.signalservice.DataMessage.BodyRange.Style[message.style] : message.style;
                    if (options.oneofs)
                        object.associatedValue = "style";
                }
                return object;
            };

            /**
             * Converts this BodyRange to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.BodyRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BodyRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BodyRange
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.BodyRange
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BodyRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.BodyRange";
            };

            /**
             * Style enum.
             * @name signalservice.DataMessage.BodyRange.Style
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} BOLD=1 BOLD value
             * @property {number} ITALIC=2 ITALIC value
             * @property {number} SPOILER=3 SPOILER value
             * @property {number} STRIKETHROUGH=4 STRIKETHROUGH value
             * @property {number} MONOSPACE=5 MONOSPACE value
             */
            BodyRange.Style = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "BOLD"] = 1;
                values[valuesById[2] = "ITALIC"] = 2;
                values[valuesById[3] = "SPOILER"] = 3;
                values[valuesById[4] = "STRIKETHROUGH"] = 4;
                values[valuesById[5] = "MONOSPACE"] = 5;
                return values;
            })();

            return BodyRange;
        })();

        DataMessage.GroupCallUpdate = (function() {

            /**
             * Properties of a GroupCallUpdate.
             * @memberof signalservice.DataMessage
             * @interface IGroupCallUpdate
             * @property {string|null} [eraId] GroupCallUpdate eraId
             */

            /**
             * Constructs a new GroupCallUpdate.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a GroupCallUpdate.
             * @implements IGroupCallUpdate
             * @constructor
             * @param {signalservice.DataMessage.IGroupCallUpdate=} [properties] Properties to set
             */
            function GroupCallUpdate(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupCallUpdate eraId.
             * @member {string} eraId
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @instance
             */
            GroupCallUpdate.prototype.eraId = "";

            /**
             * Creates a new GroupCallUpdate instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.IGroupCallUpdate=} [properties] Properties to set
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate instance
             */
            GroupCallUpdate.create = function create(properties) {
                return new GroupCallUpdate(properties);
            };

            /**
             * Encodes the specified GroupCallUpdate message. Does not implicitly {@link signalservice.DataMessage.GroupCallUpdate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.IGroupCallUpdate} message GroupCallUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCallUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eraId != null && Object.hasOwnProperty.call(message, "eraId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.eraId);
                return writer;
            };

            /**
             * Encodes the specified GroupCallUpdate message, length delimited. Does not implicitly {@link signalservice.DataMessage.GroupCallUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.IGroupCallUpdate} message GroupCallUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCallUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupCallUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCallUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.GroupCallUpdate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.eraId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupCallUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCallUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupCallUpdate message.
             * @function verify
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupCallUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eraId != null && message.hasOwnProperty("eraId"))
                    if (!$util.isString(message.eraId))
                        return "eraId: string expected";
                return null;
            };

            /**
             * Creates a GroupCallUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.GroupCallUpdate} GroupCallUpdate
             */
            GroupCallUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.GroupCallUpdate)
                    return object;
                let message = new $root.signalservice.DataMessage.GroupCallUpdate();
                if (object.eraId != null)
                    message.eraId = String(object.eraId);
                return message;
            };

            /**
             * Creates a plain object from a GroupCallUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {signalservice.DataMessage.GroupCallUpdate} message GroupCallUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupCallUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.eraId = "";
                if (message.eraId != null && message.hasOwnProperty("eraId"))
                    object.eraId = message.eraId;
                return object;
            };

            /**
             * Converts this GroupCallUpdate to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupCallUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupCallUpdate
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.GroupCallUpdate
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupCallUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.GroupCallUpdate";
            };

            return GroupCallUpdate;
        })();

        DataMessage.StoryContext = (function() {

            /**
             * Properties of a StoryContext.
             * @memberof signalservice.DataMessage
             * @interface IStoryContext
             * @property {string|null} [authorAci] StoryContext authorAci
             * @property {number|Long|null} [sentTimestamp] StoryContext sentTimestamp
             */

            /**
             * Constructs a new StoryContext.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a StoryContext.
             * @implements IStoryContext
             * @constructor
             * @param {signalservice.DataMessage.IStoryContext=} [properties] Properties to set
             */
            function StoryContext(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoryContext authorAci.
             * @member {string} authorAci
             * @memberof signalservice.DataMessage.StoryContext
             * @instance
             */
            StoryContext.prototype.authorAci = "";

            /**
             * StoryContext sentTimestamp.
             * @member {number|Long} sentTimestamp
             * @memberof signalservice.DataMessage.StoryContext
             * @instance
             */
            StoryContext.prototype.sentTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new StoryContext instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.IStoryContext=} [properties] Properties to set
             * @returns {signalservice.DataMessage.StoryContext} StoryContext instance
             */
            StoryContext.create = function create(properties) {
                return new StoryContext(properties);
            };

            /**
             * Encodes the specified StoryContext message. Does not implicitly {@link signalservice.DataMessage.StoryContext.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.IStoryContext} message StoryContext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoryContext.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.authorAci != null && Object.hasOwnProperty.call(message, "authorAci"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.authorAci);
                if (message.sentTimestamp != null && Object.hasOwnProperty.call(message, "sentTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sentTimestamp);
                return writer;
            };

            /**
             * Encodes the specified StoryContext message, length delimited. Does not implicitly {@link signalservice.DataMessage.StoryContext.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.IStoryContext} message StoryContext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoryContext.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoryContext message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.StoryContext} StoryContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoryContext.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.StoryContext();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.authorAci = reader.string();
                            break;
                        }
                    case 2: {
                            message.sentTimestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoryContext message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.StoryContext} StoryContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoryContext.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoryContext message.
             * @function verify
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoryContext.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.authorAci != null && message.hasOwnProperty("authorAci"))
                    if (!$util.isString(message.authorAci))
                        return "authorAci: string expected";
                if (message.sentTimestamp != null && message.hasOwnProperty("sentTimestamp"))
                    if (!$util.isInteger(message.sentTimestamp) && !(message.sentTimestamp && $util.isInteger(message.sentTimestamp.low) && $util.isInteger(message.sentTimestamp.high)))
                        return "sentTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a StoryContext message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.StoryContext} StoryContext
             */
            StoryContext.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.StoryContext)
                    return object;
                let message = new $root.signalservice.DataMessage.StoryContext();
                if (object.authorAci != null)
                    message.authorAci = String(object.authorAci);
                if (object.sentTimestamp != null)
                    if ($util.Long)
                        (message.sentTimestamp = $util.Long.fromValue(object.sentTimestamp)).unsigned = true;
                    else if (typeof object.sentTimestamp === "string")
                        message.sentTimestamp = parseInt(object.sentTimestamp, 10);
                    else if (typeof object.sentTimestamp === "number")
                        message.sentTimestamp = object.sentTimestamp;
                    else if (typeof object.sentTimestamp === "object")
                        message.sentTimestamp = new $util.LongBits(object.sentTimestamp.low >>> 0, object.sentTimestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a StoryContext message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {signalservice.DataMessage.StoryContext} message StoryContext
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoryContext.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.authorAci = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sentTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sentTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.authorAci != null && message.hasOwnProperty("authorAci"))
                    object.authorAci = message.authorAci;
                if (message.sentTimestamp != null && message.hasOwnProperty("sentTimestamp"))
                    if (typeof message.sentTimestamp === "number")
                        object.sentTimestamp = options.longs === String ? String(message.sentTimestamp) : message.sentTimestamp;
                    else
                        object.sentTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimestamp) : options.longs === Number ? new $util.LongBits(message.sentTimestamp.low >>> 0, message.sentTimestamp.high >>> 0).toNumber(true) : message.sentTimestamp;
                return object;
            };

            /**
             * Converts this StoryContext to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.StoryContext
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoryContext.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StoryContext
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.StoryContext
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StoryContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.StoryContext";
            };

            return StoryContext;
        })();

        /**
         * ProtocolVersion enum.
         * @name signalservice.DataMessage.ProtocolVersion
         * @enum {number}
         * @property {number} INITIAL=0 INITIAL value
         * @property {number} MESSAGE_TIMERS=1 MESSAGE_TIMERS value
         * @property {number} VIEW_ONCE=2 VIEW_ONCE value
         * @property {number} VIEW_ONCE_VIDEO=3 VIEW_ONCE_VIDEO value
         * @property {number} REACTIONS=4 REACTIONS value
         * @property {number} CDN_SELECTOR_ATTACHMENTS=5 CDN_SELECTOR_ATTACHMENTS value
         * @property {number} MENTIONS=6 MENTIONS value
         * @property {number} PAYMENTS=7 PAYMENTS value
         * @property {number} CURRENT=7 CURRENT value
         */
        DataMessage.ProtocolVersion = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INITIAL"] = 0;
            values[valuesById[1] = "MESSAGE_TIMERS"] = 1;
            values[valuesById[2] = "VIEW_ONCE"] = 2;
            values[valuesById[3] = "VIEW_ONCE_VIDEO"] = 3;
            values[valuesById[4] = "REACTIONS"] = 4;
            values[valuesById[5] = "CDN_SELECTOR_ATTACHMENTS"] = 5;
            values[valuesById[6] = "MENTIONS"] = 6;
            values[valuesById[7] = "PAYMENTS"] = 7;
            values["CURRENT"] = 7;
            return values;
        })();

        DataMessage.GiftBadge = (function() {

            /**
             * Properties of a GiftBadge.
             * @memberof signalservice.DataMessage
             * @interface IGiftBadge
             * @property {Uint8Array|null} [receiptCredentialPresentation] GiftBadge receiptCredentialPresentation
             */

            /**
             * Constructs a new GiftBadge.
             * @memberof signalservice.DataMessage
             * @classdesc Represents a GiftBadge.
             * @implements IGiftBadge
             * @constructor
             * @param {signalservice.DataMessage.IGiftBadge=} [properties] Properties to set
             */
            function GiftBadge(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GiftBadge receiptCredentialPresentation.
             * @member {Uint8Array} receiptCredentialPresentation
             * @memberof signalservice.DataMessage.GiftBadge
             * @instance
             */
            GiftBadge.prototype.receiptCredentialPresentation = $util.newBuffer([]);

            /**
             * Creates a new GiftBadge instance using the specified properties.
             * @function create
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.IGiftBadge=} [properties] Properties to set
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge instance
             */
            GiftBadge.create = function create(properties) {
                return new GiftBadge(properties);
            };

            /**
             * Encodes the specified GiftBadge message. Does not implicitly {@link signalservice.DataMessage.GiftBadge.verify|verify} messages.
             * @function encode
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.IGiftBadge} message GiftBadge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftBadge.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.receiptCredentialPresentation != null && Object.hasOwnProperty.call(message, "receiptCredentialPresentation"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.receiptCredentialPresentation);
                return writer;
            };

            /**
             * Encodes the specified GiftBadge message, length delimited. Does not implicitly {@link signalservice.DataMessage.GiftBadge.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.IGiftBadge} message GiftBadge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftBadge.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GiftBadge message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftBadge.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.DataMessage.GiftBadge();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.receiptCredentialPresentation = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GiftBadge message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftBadge.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GiftBadge message.
             * @function verify
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GiftBadge.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.receiptCredentialPresentation != null && message.hasOwnProperty("receiptCredentialPresentation"))
                    if (!(message.receiptCredentialPresentation && typeof message.receiptCredentialPresentation.length === "number" || $util.isString(message.receiptCredentialPresentation)))
                        return "receiptCredentialPresentation: buffer expected";
                return null;
            };

            /**
             * Creates a GiftBadge message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.DataMessage.GiftBadge} GiftBadge
             */
            GiftBadge.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.DataMessage.GiftBadge)
                    return object;
                let message = new $root.signalservice.DataMessage.GiftBadge();
                if (object.receiptCredentialPresentation != null)
                    if (typeof object.receiptCredentialPresentation === "string")
                        $util.base64.decode(object.receiptCredentialPresentation, message.receiptCredentialPresentation = $util.newBuffer($util.base64.length(object.receiptCredentialPresentation)), 0);
                    else if (object.receiptCredentialPresentation.length >= 0)
                        message.receiptCredentialPresentation = object.receiptCredentialPresentation;
                return message;
            };

            /**
             * Creates a plain object from a GiftBadge message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {signalservice.DataMessage.GiftBadge} message GiftBadge
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GiftBadge.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.receiptCredentialPresentation = "";
                    else {
                        object.receiptCredentialPresentation = [];
                        if (options.bytes !== Array)
                            object.receiptCredentialPresentation = $util.newBuffer(object.receiptCredentialPresentation);
                    }
                if (message.receiptCredentialPresentation != null && message.hasOwnProperty("receiptCredentialPresentation"))
                    object.receiptCredentialPresentation = options.bytes === String ? $util.base64.encode(message.receiptCredentialPresentation, 0, message.receiptCredentialPresentation.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiptCredentialPresentation) : message.receiptCredentialPresentation;
                return object;
            };

            /**
             * Converts this GiftBadge to JSON.
             * @function toJSON
             * @memberof signalservice.DataMessage.GiftBadge
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GiftBadge.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GiftBadge
             * @function getTypeUrl
             * @memberof signalservice.DataMessage.GiftBadge
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GiftBadge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.DataMessage.GiftBadge";
            };

            return GiftBadge;
        })();

        return DataMessage;
    })();

    signalservice.NullMessage = (function() {

        /**
         * Properties of a NullMessage.
         * @memberof signalservice
         * @interface INullMessage
         * @property {Uint8Array|null} [padding] NullMessage padding
         */

        /**
         * Constructs a new NullMessage.
         * @memberof signalservice
         * @classdesc Represents a NullMessage.
         * @implements INullMessage
         * @constructor
         * @param {signalservice.INullMessage=} [properties] Properties to set
         */
        function NullMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NullMessage padding.
         * @member {Uint8Array} padding
         * @memberof signalservice.NullMessage
         * @instance
         */
        NullMessage.prototype.padding = $util.newBuffer([]);

        /**
         * Creates a new NullMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.INullMessage=} [properties] Properties to set
         * @returns {signalservice.NullMessage} NullMessage instance
         */
        NullMessage.create = function create(properties) {
            return new NullMessage(properties);
        };

        /**
         * Encodes the specified NullMessage message. Does not implicitly {@link signalservice.NullMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.INullMessage} message NullMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NullMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.padding);
            return writer;
        };

        /**
         * Encodes the specified NullMessage message, length delimited. Does not implicitly {@link signalservice.NullMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.INullMessage} message NullMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NullMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NullMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.NullMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.NullMessage} NullMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NullMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.NullMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.padding = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NullMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.NullMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.NullMessage} NullMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NullMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NullMessage message.
         * @function verify
         * @memberof signalservice.NullMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NullMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.padding != null && message.hasOwnProperty("padding"))
                if (!(message.padding && typeof message.padding.length === "number" || $util.isString(message.padding)))
                    return "padding: buffer expected";
            return null;
        };

        /**
         * Creates a NullMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.NullMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.NullMessage} NullMessage
         */
        NullMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.NullMessage)
                return object;
            let message = new $root.signalservice.NullMessage();
            if (object.padding != null)
                if (typeof object.padding === "string")
                    $util.base64.decode(object.padding, message.padding = $util.newBuffer($util.base64.length(object.padding)), 0);
                else if (object.padding.length >= 0)
                    message.padding = object.padding;
            return message;
        };

        /**
         * Creates a plain object from a NullMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.NullMessage
         * @static
         * @param {signalservice.NullMessage} message NullMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NullMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.padding = "";
                else {
                    object.padding = [];
                    if (options.bytes !== Array)
                        object.padding = $util.newBuffer(object.padding);
                }
            if (message.padding != null && message.hasOwnProperty("padding"))
                object.padding = options.bytes === String ? $util.base64.encode(message.padding, 0, message.padding.length) : options.bytes === Array ? Array.prototype.slice.call(message.padding) : message.padding;
            return object;
        };

        /**
         * Converts this NullMessage to JSON.
         * @function toJSON
         * @memberof signalservice.NullMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NullMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NullMessage
         * @function getTypeUrl
         * @memberof signalservice.NullMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NullMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.NullMessage";
        };

        return NullMessage;
    })();

    signalservice.ReceiptMessage = (function() {

        /**
         * Properties of a ReceiptMessage.
         * @memberof signalservice
         * @interface IReceiptMessage
         * @property {signalservice.ReceiptMessage.Type|null} [type] ReceiptMessage type
         * @property {Array.<number|Long>|null} [timestamp] ReceiptMessage timestamp
         */

        /**
         * Constructs a new ReceiptMessage.
         * @memberof signalservice
         * @classdesc Represents a ReceiptMessage.
         * @implements IReceiptMessage
         * @constructor
         * @param {signalservice.IReceiptMessage=} [properties] Properties to set
         */
        function ReceiptMessage(properties) {
            this.timestamp = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReceiptMessage type.
         * @member {signalservice.ReceiptMessage.Type} type
         * @memberof signalservice.ReceiptMessage
         * @instance
         */
        ReceiptMessage.prototype.type = 0;

        /**
         * ReceiptMessage timestamp.
         * @member {Array.<number|Long>} timestamp
         * @memberof signalservice.ReceiptMessage
         * @instance
         */
        ReceiptMessage.prototype.timestamp = $util.emptyArray;

        /**
         * Creates a new ReceiptMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.IReceiptMessage=} [properties] Properties to set
         * @returns {signalservice.ReceiptMessage} ReceiptMessage instance
         */
        ReceiptMessage.create = function create(properties) {
            return new ReceiptMessage(properties);
        };

        /**
         * Encodes the specified ReceiptMessage message. Does not implicitly {@link signalservice.ReceiptMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.IReceiptMessage} message ReceiptMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReceiptMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.timestamp != null && message.timestamp.length)
                for (let i = 0; i < message.timestamp.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp[i]);
            return writer;
        };

        /**
         * Encodes the specified ReceiptMessage message, length delimited. Does not implicitly {@link signalservice.ReceiptMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.IReceiptMessage} message ReceiptMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReceiptMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReceiptMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ReceiptMessage} ReceiptMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiptMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ReceiptMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.timestamp && message.timestamp.length))
                            message.timestamp = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.timestamp.push(reader.uint64());
                        } else
                            message.timestamp.push(reader.uint64());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReceiptMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ReceiptMessage} ReceiptMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReceiptMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReceiptMessage message.
         * @function verify
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReceiptMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                if (!Array.isArray(message.timestamp))
                    return "timestamp: array expected";
                for (let i = 0; i < message.timestamp.length; ++i)
                    if (!$util.isInteger(message.timestamp[i]) && !(message.timestamp[i] && $util.isInteger(message.timestamp[i].low) && $util.isInteger(message.timestamp[i].high)))
                        return "timestamp: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a ReceiptMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ReceiptMessage} ReceiptMessage
         */
        ReceiptMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ReceiptMessage)
                return object;
            let message = new $root.signalservice.ReceiptMessage();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "DELIVERY":
            case 0:
                message.type = 0;
                break;
            case "READ":
            case 1:
                message.type = 1;
                break;
            case "VIEWED":
            case 2:
                message.type = 2;
                break;
            }
            if (object.timestamp) {
                if (!Array.isArray(object.timestamp))
                    throw TypeError(".signalservice.ReceiptMessage.timestamp: array expected");
                message.timestamp = [];
                for (let i = 0; i < object.timestamp.length; ++i)
                    if ($util.Long)
                        (message.timestamp[i] = $util.Long.fromValue(object.timestamp[i])).unsigned = true;
                    else if (typeof object.timestamp[i] === "string")
                        message.timestamp[i] = parseInt(object.timestamp[i], 10);
                    else if (typeof object.timestamp[i] === "number")
                        message.timestamp[i] = object.timestamp[i];
                    else if (typeof object.timestamp[i] === "object")
                        message.timestamp[i] = new $util.LongBits(object.timestamp[i].low >>> 0, object.timestamp[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReceiptMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {signalservice.ReceiptMessage} message ReceiptMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReceiptMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.timestamp = [];
            if (options.defaults)
                object.type = options.enums === String ? "DELIVERY" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.ReceiptMessage.Type[message.type] === undefined ? message.type : $root.signalservice.ReceiptMessage.Type[message.type] : message.type;
            if (message.timestamp && message.timestamp.length) {
                object.timestamp = [];
                for (let j = 0; j < message.timestamp.length; ++j)
                    if (typeof message.timestamp[j] === "number")
                        object.timestamp[j] = options.longs === String ? String(message.timestamp[j]) : message.timestamp[j];
                    else
                        object.timestamp[j] = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp[j]) : options.longs === Number ? new $util.LongBits(message.timestamp[j].low >>> 0, message.timestamp[j].high >>> 0).toNumber(true) : message.timestamp[j];
            }
            return object;
        };

        /**
         * Converts this ReceiptMessage to JSON.
         * @function toJSON
         * @memberof signalservice.ReceiptMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReceiptMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReceiptMessage
         * @function getTypeUrl
         * @memberof signalservice.ReceiptMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReceiptMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.ReceiptMessage";
        };

        /**
         * Type enum.
         * @name signalservice.ReceiptMessage.Type
         * @enum {number}
         * @property {number} DELIVERY=0 DELIVERY value
         * @property {number} READ=1 READ value
         * @property {number} VIEWED=2 VIEWED value
         */
        ReceiptMessage.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DELIVERY"] = 0;
            values[valuesById[1] = "READ"] = 1;
            values[valuesById[2] = "VIEWED"] = 2;
            return values;
        })();

        return ReceiptMessage;
    })();

    signalservice.TypingMessage = (function() {

        /**
         * Properties of a TypingMessage.
         * @memberof signalservice
         * @interface ITypingMessage
         * @property {number|Long|null} [timestamp] TypingMessage timestamp
         * @property {signalservice.TypingMessage.Action|null} [action] TypingMessage action
         * @property {Uint8Array|null} [groupId] TypingMessage groupId
         */

        /**
         * Constructs a new TypingMessage.
         * @memberof signalservice
         * @classdesc Represents a TypingMessage.
         * @implements ITypingMessage
         * @constructor
         * @param {signalservice.ITypingMessage=} [properties] Properties to set
         */
        function TypingMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TypingMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof signalservice.TypingMessage
         * @instance
         */
        TypingMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TypingMessage action.
         * @member {signalservice.TypingMessage.Action} action
         * @memberof signalservice.TypingMessage
         * @instance
         */
        TypingMessage.prototype.action = 0;

        /**
         * TypingMessage groupId.
         * @member {Uint8Array} groupId
         * @memberof signalservice.TypingMessage
         * @instance
         */
        TypingMessage.prototype.groupId = $util.newBuffer([]);

        /**
         * Creates a new TypingMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.ITypingMessage=} [properties] Properties to set
         * @returns {signalservice.TypingMessage} TypingMessage instance
         */
        TypingMessage.create = function create(properties) {
            return new TypingMessage(properties);
        };

        /**
         * Encodes the specified TypingMessage message. Does not implicitly {@link signalservice.TypingMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.ITypingMessage} message TypingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupId);
            return writer;
        };

        /**
         * Encodes the specified TypingMessage message, length delimited. Does not implicitly {@link signalservice.TypingMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.ITypingMessage} message TypingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TypingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.TypingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.TypingMessage} TypingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.TypingMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                case 2: {
                        message.action = reader.int32();
                        break;
                    }
                case 3: {
                        message.groupId = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TypingMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.TypingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.TypingMessage} TypingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TypingMessage message.
         * @function verify
         * @memberof signalservice.TypingMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TypingMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!(message.groupId && typeof message.groupId.length === "number" || $util.isString(message.groupId)))
                    return "groupId: buffer expected";
            return null;
        };

        /**
         * Creates a TypingMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.TypingMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.TypingMessage} TypingMessage
         */
        TypingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.TypingMessage)
                return object;
            let message = new $root.signalservice.TypingMessage();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            switch (object.action) {
            default:
                if (typeof object.action === "number") {
                    message.action = object.action;
                    break;
                }
                break;
            case "STARTED":
            case 0:
                message.action = 0;
                break;
            case "STOPPED":
            case 1:
                message.action = 1;
                break;
            }
            if (object.groupId != null)
                if (typeof object.groupId === "string")
                    $util.base64.decode(object.groupId, message.groupId = $util.newBuffer($util.base64.length(object.groupId)), 0);
                else if (object.groupId.length >= 0)
                    message.groupId = object.groupId;
            return message;
        };

        /**
         * Creates a plain object from a TypingMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.TypingMessage
         * @static
         * @param {signalservice.TypingMessage} message TypingMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TypingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.action = options.enums === String ? "STARTED" : 0;
                if (options.bytes === String)
                    object.groupId = "";
                else {
                    object.groupId = [];
                    if (options.bytes !== Array)
                        object.groupId = $util.newBuffer(object.groupId);
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.signalservice.TypingMessage.Action[message.action] === undefined ? message.action : $root.signalservice.TypingMessage.Action[message.action] : message.action;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = options.bytes === String ? $util.base64.encode(message.groupId, 0, message.groupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupId) : message.groupId;
            return object;
        };

        /**
         * Converts this TypingMessage to JSON.
         * @function toJSON
         * @memberof signalservice.TypingMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TypingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TypingMessage
         * @function getTypeUrl
         * @memberof signalservice.TypingMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TypingMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.TypingMessage";
        };

        /**
         * Action enum.
         * @name signalservice.TypingMessage.Action
         * @enum {number}
         * @property {number} STARTED=0 STARTED value
         * @property {number} STOPPED=1 STOPPED value
         */
        TypingMessage.Action = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STARTED"] = 0;
            values[valuesById[1] = "STOPPED"] = 1;
            return values;
        })();

        return TypingMessage;
    })();

    signalservice.StoryMessage = (function() {

        /**
         * Properties of a StoryMessage.
         * @memberof signalservice
         * @interface IStoryMessage
         * @property {Uint8Array|null} [profileKey] StoryMessage profileKey
         * @property {signalservice.IGroupContextV2|null} [group] StoryMessage group
         * @property {signalservice.IAttachmentPointer|null} [fileAttachment] StoryMessage fileAttachment
         * @property {signalservice.ITextAttachment|null} [textAttachment] StoryMessage textAttachment
         * @property {boolean|null} [allowsReplies] StoryMessage allowsReplies
         * @property {Array.<signalservice.DataMessage.IBodyRange>|null} [bodyRanges] StoryMessage bodyRanges
         */

        /**
         * Constructs a new StoryMessage.
         * @memberof signalservice
         * @classdesc Represents a StoryMessage.
         * @implements IStoryMessage
         * @constructor
         * @param {signalservice.IStoryMessage=} [properties] Properties to set
         */
        function StoryMessage(properties) {
            this.bodyRanges = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StoryMessage profileKey.
         * @member {Uint8Array} profileKey
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.profileKey = $util.newBuffer([]);

        /**
         * StoryMessage group.
         * @member {signalservice.IGroupContextV2|null|undefined} group
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.group = null;

        /**
         * StoryMessage fileAttachment.
         * @member {signalservice.IAttachmentPointer|null|undefined} fileAttachment
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.fileAttachment = null;

        /**
         * StoryMessage textAttachment.
         * @member {signalservice.ITextAttachment|null|undefined} textAttachment
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.textAttachment = null;

        /**
         * StoryMessage allowsReplies.
         * @member {boolean} allowsReplies
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.allowsReplies = false;

        /**
         * StoryMessage bodyRanges.
         * @member {Array.<signalservice.DataMessage.IBodyRange>} bodyRanges
         * @memberof signalservice.StoryMessage
         * @instance
         */
        StoryMessage.prototype.bodyRanges = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * StoryMessage attachment.
         * @member {"fileAttachment"|"textAttachment"|undefined} attachment
         * @memberof signalservice.StoryMessage
         * @instance
         */
        Object.defineProperty(StoryMessage.prototype, "attachment", {
            get: $util.oneOfGetter($oneOfFields = ["fileAttachment", "textAttachment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new StoryMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.IStoryMessage=} [properties] Properties to set
         * @returns {signalservice.StoryMessage} StoryMessage instance
         */
        StoryMessage.create = function create(properties) {
            return new StoryMessage(properties);
        };

        /**
         * Encodes the specified StoryMessage message. Does not implicitly {@link signalservice.StoryMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.IStoryMessage} message StoryMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoryMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.profileKey != null && Object.hasOwnProperty.call(message, "profileKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.profileKey);
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                $root.signalservice.GroupContextV2.encode(message.group, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.fileAttachment != null && Object.hasOwnProperty.call(message, "fileAttachment"))
                $root.signalservice.AttachmentPointer.encode(message.fileAttachment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.textAttachment != null && Object.hasOwnProperty.call(message, "textAttachment"))
                $root.signalservice.TextAttachment.encode(message.textAttachment, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.allowsReplies != null && Object.hasOwnProperty.call(message, "allowsReplies"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.allowsReplies);
            if (message.bodyRanges != null && message.bodyRanges.length)
                for (let i = 0; i < message.bodyRanges.length; ++i)
                    $root.signalservice.DataMessage.BodyRange.encode(message.bodyRanges[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StoryMessage message, length delimited. Does not implicitly {@link signalservice.StoryMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.IStoryMessage} message StoryMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoryMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StoryMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.StoryMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.StoryMessage} StoryMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoryMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.StoryMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.profileKey = reader.bytes();
                        break;
                    }
                case 2: {
                        message.group = $root.signalservice.GroupContextV2.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.fileAttachment = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.textAttachment = $root.signalservice.TextAttachment.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.allowsReplies = reader.bool();
                        break;
                    }
                case 6: {
                        if (!(message.bodyRanges && message.bodyRanges.length))
                            message.bodyRanges = [];
                        message.bodyRanges.push($root.signalservice.DataMessage.BodyRange.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StoryMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.StoryMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.StoryMessage} StoryMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoryMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StoryMessage message.
         * @function verify
         * @memberof signalservice.StoryMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StoryMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                if (!(message.profileKey && typeof message.profileKey.length === "number" || $util.isString(message.profileKey)))
                    return "profileKey: buffer expected";
            if (message.group != null && message.hasOwnProperty("group")) {
                let error = $root.signalservice.GroupContextV2.verify(message.group);
                if (error)
                    return "group." + error;
            }
            if (message.fileAttachment != null && message.hasOwnProperty("fileAttachment")) {
                properties.attachment = 1;
                {
                    let error = $root.signalservice.AttachmentPointer.verify(message.fileAttachment);
                    if (error)
                        return "fileAttachment." + error;
                }
            }
            if (message.textAttachment != null && message.hasOwnProperty("textAttachment")) {
                if (properties.attachment === 1)
                    return "attachment: multiple values";
                properties.attachment = 1;
                {
                    let error = $root.signalservice.TextAttachment.verify(message.textAttachment);
                    if (error)
                        return "textAttachment." + error;
                }
            }
            if (message.allowsReplies != null && message.hasOwnProperty("allowsReplies"))
                if (typeof message.allowsReplies !== "boolean")
                    return "allowsReplies: boolean expected";
            if (message.bodyRanges != null && message.hasOwnProperty("bodyRanges")) {
                if (!Array.isArray(message.bodyRanges))
                    return "bodyRanges: array expected";
                for (let i = 0; i < message.bodyRanges.length; ++i) {
                    let error = $root.signalservice.DataMessage.BodyRange.verify(message.bodyRanges[i]);
                    if (error)
                        return "bodyRanges." + error;
                }
            }
            return null;
        };

        /**
         * Creates a StoryMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.StoryMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.StoryMessage} StoryMessage
         */
        StoryMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.StoryMessage)
                return object;
            let message = new $root.signalservice.StoryMessage();
            if (object.profileKey != null)
                if (typeof object.profileKey === "string")
                    $util.base64.decode(object.profileKey, message.profileKey = $util.newBuffer($util.base64.length(object.profileKey)), 0);
                else if (object.profileKey.length >= 0)
                    message.profileKey = object.profileKey;
            if (object.group != null) {
                if (typeof object.group !== "object")
                    throw TypeError(".signalservice.StoryMessage.group: object expected");
                message.group = $root.signalservice.GroupContextV2.fromObject(object.group);
            }
            if (object.fileAttachment != null) {
                if (typeof object.fileAttachment !== "object")
                    throw TypeError(".signalservice.StoryMessage.fileAttachment: object expected");
                message.fileAttachment = $root.signalservice.AttachmentPointer.fromObject(object.fileAttachment);
            }
            if (object.textAttachment != null) {
                if (typeof object.textAttachment !== "object")
                    throw TypeError(".signalservice.StoryMessage.textAttachment: object expected");
                message.textAttachment = $root.signalservice.TextAttachment.fromObject(object.textAttachment);
            }
            if (object.allowsReplies != null)
                message.allowsReplies = Boolean(object.allowsReplies);
            if (object.bodyRanges) {
                if (!Array.isArray(object.bodyRanges))
                    throw TypeError(".signalservice.StoryMessage.bodyRanges: array expected");
                message.bodyRanges = [];
                for (let i = 0; i < object.bodyRanges.length; ++i) {
                    if (typeof object.bodyRanges[i] !== "object")
                        throw TypeError(".signalservice.StoryMessage.bodyRanges: object expected");
                    message.bodyRanges[i] = $root.signalservice.DataMessage.BodyRange.fromObject(object.bodyRanges[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a StoryMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.StoryMessage
         * @static
         * @param {signalservice.StoryMessage} message StoryMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StoryMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.bodyRanges = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.profileKey = "";
                else {
                    object.profileKey = [];
                    if (options.bytes !== Array)
                        object.profileKey = $util.newBuffer(object.profileKey);
                }
                object.group = null;
                object.allowsReplies = false;
            }
            if (message.profileKey != null && message.hasOwnProperty("profileKey"))
                object.profileKey = options.bytes === String ? $util.base64.encode(message.profileKey, 0, message.profileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.profileKey) : message.profileKey;
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = $root.signalservice.GroupContextV2.toObject(message.group, options);
            if (message.fileAttachment != null && message.hasOwnProperty("fileAttachment")) {
                object.fileAttachment = $root.signalservice.AttachmentPointer.toObject(message.fileAttachment, options);
                if (options.oneofs)
                    object.attachment = "fileAttachment";
            }
            if (message.textAttachment != null && message.hasOwnProperty("textAttachment")) {
                object.textAttachment = $root.signalservice.TextAttachment.toObject(message.textAttachment, options);
                if (options.oneofs)
                    object.attachment = "textAttachment";
            }
            if (message.allowsReplies != null && message.hasOwnProperty("allowsReplies"))
                object.allowsReplies = message.allowsReplies;
            if (message.bodyRanges && message.bodyRanges.length) {
                object.bodyRanges = [];
                for (let j = 0; j < message.bodyRanges.length; ++j)
                    object.bodyRanges[j] = $root.signalservice.DataMessage.BodyRange.toObject(message.bodyRanges[j], options);
            }
            return object;
        };

        /**
         * Converts this StoryMessage to JSON.
         * @function toJSON
         * @memberof signalservice.StoryMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StoryMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StoryMessage
         * @function getTypeUrl
         * @memberof signalservice.StoryMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StoryMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.StoryMessage";
        };

        return StoryMessage;
    })();

    signalservice.TextAttachment = (function() {

        /**
         * Properties of a TextAttachment.
         * @memberof signalservice
         * @interface ITextAttachment
         * @property {string|null} [text] TextAttachment text
         * @property {signalservice.TextAttachment.Style|null} [textStyle] TextAttachment textStyle
         * @property {number|null} [textForegroundColor] TextAttachment textForegroundColor
         * @property {number|null} [textBackgroundColor] TextAttachment textBackgroundColor
         * @property {signalservice.DataMessage.IPreview|null} [preview] TextAttachment preview
         * @property {signalservice.TextAttachment.IGradient|null} [gradient] TextAttachment gradient
         * @property {number|null} [color] TextAttachment color
         */

        /**
         * Constructs a new TextAttachment.
         * @memberof signalservice
         * @classdesc Represents a TextAttachment.
         * @implements ITextAttachment
         * @constructor
         * @param {signalservice.ITextAttachment=} [properties] Properties to set
         */
        function TextAttachment(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextAttachment text.
         * @member {string} text
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.text = "";

        /**
         * TextAttachment textStyle.
         * @member {signalservice.TextAttachment.Style} textStyle
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.textStyle = 0;

        /**
         * TextAttachment textForegroundColor.
         * @member {number} textForegroundColor
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.textForegroundColor = 0;

        /**
         * TextAttachment textBackgroundColor.
         * @member {number} textBackgroundColor
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.textBackgroundColor = 0;

        /**
         * TextAttachment preview.
         * @member {signalservice.DataMessage.IPreview|null|undefined} preview
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.preview = null;

        /**
         * TextAttachment gradient.
         * @member {signalservice.TextAttachment.IGradient|null|undefined} gradient
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.gradient = null;

        /**
         * TextAttachment color.
         * @member {number|null|undefined} color
         * @memberof signalservice.TextAttachment
         * @instance
         */
        TextAttachment.prototype.color = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TextAttachment background.
         * @member {"gradient"|"color"|undefined} background
         * @memberof signalservice.TextAttachment
         * @instance
         */
        Object.defineProperty(TextAttachment.prototype, "background", {
            get: $util.oneOfGetter($oneOfFields = ["gradient", "color"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TextAttachment instance using the specified properties.
         * @function create
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.ITextAttachment=} [properties] Properties to set
         * @returns {signalservice.TextAttachment} TextAttachment instance
         */
        TextAttachment.create = function create(properties) {
            return new TextAttachment(properties);
        };

        /**
         * Encodes the specified TextAttachment message. Does not implicitly {@link signalservice.TextAttachment.verify|verify} messages.
         * @function encode
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.ITextAttachment} message TextAttachment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextAttachment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.textStyle != null && Object.hasOwnProperty.call(message, "textStyle"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.textStyle);
            if (message.textForegroundColor != null && Object.hasOwnProperty.call(message, "textForegroundColor"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.textForegroundColor);
            if (message.textBackgroundColor != null && Object.hasOwnProperty.call(message, "textBackgroundColor"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.textBackgroundColor);
            if (message.preview != null && Object.hasOwnProperty.call(message, "preview"))
                $root.signalservice.DataMessage.Preview.encode(message.preview, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.gradient != null && Object.hasOwnProperty.call(message, "gradient"))
                $root.signalservice.TextAttachment.Gradient.encode(message.gradient, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.color);
            return writer;
        };

        /**
         * Encodes the specified TextAttachment message, length delimited. Does not implicitly {@link signalservice.TextAttachment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.ITextAttachment} message TextAttachment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextAttachment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextAttachment message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.TextAttachment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.TextAttachment} TextAttachment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextAttachment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.TextAttachment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.string();
                        break;
                    }
                case 2: {
                        message.textStyle = reader.int32();
                        break;
                    }
                case 3: {
                        message.textForegroundColor = reader.uint32();
                        break;
                    }
                case 4: {
                        message.textBackgroundColor = reader.uint32();
                        break;
                    }
                case 5: {
                        message.preview = $root.signalservice.DataMessage.Preview.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.gradient = $root.signalservice.TextAttachment.Gradient.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.color = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextAttachment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.TextAttachment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.TextAttachment} TextAttachment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextAttachment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextAttachment message.
         * @function verify
         * @memberof signalservice.TextAttachment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextAttachment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.textStyle != null && message.hasOwnProperty("textStyle"))
                switch (message.textStyle) {
                default:
                    return "textStyle: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.textForegroundColor != null && message.hasOwnProperty("textForegroundColor"))
                if (!$util.isInteger(message.textForegroundColor))
                    return "textForegroundColor: integer expected";
            if (message.textBackgroundColor != null && message.hasOwnProperty("textBackgroundColor"))
                if (!$util.isInteger(message.textBackgroundColor))
                    return "textBackgroundColor: integer expected";
            if (message.preview != null && message.hasOwnProperty("preview")) {
                let error = $root.signalservice.DataMessage.Preview.verify(message.preview);
                if (error)
                    return "preview." + error;
            }
            if (message.gradient != null && message.hasOwnProperty("gradient")) {
                properties.background = 1;
                {
                    let error = $root.signalservice.TextAttachment.Gradient.verify(message.gradient);
                    if (error)
                        return "gradient." + error;
                }
            }
            if (message.color != null && message.hasOwnProperty("color")) {
                if (properties.background === 1)
                    return "background: multiple values";
                properties.background = 1;
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            }
            return null;
        };

        /**
         * Creates a TextAttachment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.TextAttachment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.TextAttachment} TextAttachment
         */
        TextAttachment.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.TextAttachment)
                return object;
            let message = new $root.signalservice.TextAttachment();
            if (object.text != null)
                message.text = String(object.text);
            switch (object.textStyle) {
            default:
                if (typeof object.textStyle === "number") {
                    message.textStyle = object.textStyle;
                    break;
                }
                break;
            case "DEFAULT":
            case 0:
                message.textStyle = 0;
                break;
            case "REGULAR":
            case 1:
                message.textStyle = 1;
                break;
            case "BOLD":
            case 2:
                message.textStyle = 2;
                break;
            case "SERIF":
            case 3:
                message.textStyle = 3;
                break;
            case "SCRIPT":
            case 4:
                message.textStyle = 4;
                break;
            case "CONDENSED":
            case 5:
                message.textStyle = 5;
                break;
            }
            if (object.textForegroundColor != null)
                message.textForegroundColor = object.textForegroundColor >>> 0;
            if (object.textBackgroundColor != null)
                message.textBackgroundColor = object.textBackgroundColor >>> 0;
            if (object.preview != null) {
                if (typeof object.preview !== "object")
                    throw TypeError(".signalservice.TextAttachment.preview: object expected");
                message.preview = $root.signalservice.DataMessage.Preview.fromObject(object.preview);
            }
            if (object.gradient != null) {
                if (typeof object.gradient !== "object")
                    throw TypeError(".signalservice.TextAttachment.gradient: object expected");
                message.gradient = $root.signalservice.TextAttachment.Gradient.fromObject(object.gradient);
            }
            if (object.color != null)
                message.color = object.color >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TextAttachment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.TextAttachment
         * @static
         * @param {signalservice.TextAttachment} message TextAttachment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextAttachment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.text = "";
                object.textStyle = options.enums === String ? "DEFAULT" : 0;
                object.textForegroundColor = 0;
                object.textBackgroundColor = 0;
                object.preview = null;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.textStyle != null && message.hasOwnProperty("textStyle"))
                object.textStyle = options.enums === String ? $root.signalservice.TextAttachment.Style[message.textStyle] === undefined ? message.textStyle : $root.signalservice.TextAttachment.Style[message.textStyle] : message.textStyle;
            if (message.textForegroundColor != null && message.hasOwnProperty("textForegroundColor"))
                object.textForegroundColor = message.textForegroundColor;
            if (message.textBackgroundColor != null && message.hasOwnProperty("textBackgroundColor"))
                object.textBackgroundColor = message.textBackgroundColor;
            if (message.preview != null && message.hasOwnProperty("preview"))
                object.preview = $root.signalservice.DataMessage.Preview.toObject(message.preview, options);
            if (message.gradient != null && message.hasOwnProperty("gradient")) {
                object.gradient = $root.signalservice.TextAttachment.Gradient.toObject(message.gradient, options);
                if (options.oneofs)
                    object.background = "gradient";
            }
            if (message.color != null && message.hasOwnProperty("color")) {
                object.color = message.color;
                if (options.oneofs)
                    object.background = "color";
            }
            return object;
        };

        /**
         * Converts this TextAttachment to JSON.
         * @function toJSON
         * @memberof signalservice.TextAttachment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextAttachment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TextAttachment
         * @function getTypeUrl
         * @memberof signalservice.TextAttachment
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TextAttachment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.TextAttachment";
        };

        /**
         * Style enum.
         * @name signalservice.TextAttachment.Style
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} REGULAR=1 REGULAR value
         * @property {number} BOLD=2 BOLD value
         * @property {number} SERIF=3 SERIF value
         * @property {number} SCRIPT=4 SCRIPT value
         * @property {number} CONDENSED=5 CONDENSED value
         */
        TextAttachment.Style = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "REGULAR"] = 1;
            values[valuesById[2] = "BOLD"] = 2;
            values[valuesById[3] = "SERIF"] = 3;
            values[valuesById[4] = "SCRIPT"] = 4;
            values[valuesById[5] = "CONDENSED"] = 5;
            return values;
        })();

        TextAttachment.Gradient = (function() {

            /**
             * Properties of a Gradient.
             * @memberof signalservice.TextAttachment
             * @interface IGradient
             * @property {number|null} [startColor] Gradient startColor
             * @property {number|null} [endColor] Gradient endColor
             * @property {number|null} [angle] Gradient angle
             * @property {Array.<number>|null} [colors] Gradient colors
             * @property {Array.<number>|null} [positions] Gradient positions
             */

            /**
             * Constructs a new Gradient.
             * @memberof signalservice.TextAttachment
             * @classdesc Represents a Gradient.
             * @implements IGradient
             * @constructor
             * @param {signalservice.TextAttachment.IGradient=} [properties] Properties to set
             */
            function Gradient(properties) {
                this.colors = [];
                this.positions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Gradient startColor.
             * @member {number} startColor
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.startColor = 0;

            /**
             * Gradient endColor.
             * @member {number} endColor
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.endColor = 0;

            /**
             * Gradient angle.
             * @member {number} angle
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.angle = 0;

            /**
             * Gradient colors.
             * @member {Array.<number>} colors
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.colors = $util.emptyArray;

            /**
             * Gradient positions.
             * @member {Array.<number>} positions
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             */
            Gradient.prototype.positions = $util.emptyArray;

            /**
             * Creates a new Gradient instance using the specified properties.
             * @function create
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.IGradient=} [properties] Properties to set
             * @returns {signalservice.TextAttachment.Gradient} Gradient instance
             */
            Gradient.create = function create(properties) {
                return new Gradient(properties);
            };

            /**
             * Encodes the specified Gradient message. Does not implicitly {@link signalservice.TextAttachment.Gradient.verify|verify} messages.
             * @function encode
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.IGradient} message Gradient message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Gradient.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startColor != null && Object.hasOwnProperty.call(message, "startColor"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.startColor);
                if (message.endColor != null && Object.hasOwnProperty.call(message, "endColor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.endColor);
                if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.angle);
                if (message.colors != null && message.colors.length)
                    for (let i = 0; i < message.colors.length; ++i)
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.colors[i]);
                if (message.positions != null && message.positions.length)
                    for (let i = 0; i < message.positions.length; ++i)
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.positions[i]);
                return writer;
            };

            /**
             * Encodes the specified Gradient message, length delimited. Does not implicitly {@link signalservice.TextAttachment.Gradient.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.IGradient} message Gradient message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Gradient.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Gradient message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.TextAttachment.Gradient} Gradient
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Gradient.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.TextAttachment.Gradient();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.startColor = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.endColor = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.angle = reader.uint32();
                            break;
                        }
                    case 4: {
                            if (!(message.colors && message.colors.length))
                                message.colors = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.colors.push(reader.uint32());
                            } else
                                message.colors.push(reader.uint32());
                            break;
                        }
                    case 5: {
                            if (!(message.positions && message.positions.length))
                                message.positions = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.positions.push(reader.float());
                            } else
                                message.positions.push(reader.float());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Gradient message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.TextAttachment.Gradient} Gradient
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Gradient.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Gradient message.
             * @function verify
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Gradient.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startColor != null && message.hasOwnProperty("startColor"))
                    if (!$util.isInteger(message.startColor))
                        return "startColor: integer expected";
                if (message.endColor != null && message.hasOwnProperty("endColor"))
                    if (!$util.isInteger(message.endColor))
                        return "endColor: integer expected";
                if (message.angle != null && message.hasOwnProperty("angle"))
                    if (!$util.isInteger(message.angle))
                        return "angle: integer expected";
                if (message.colors != null && message.hasOwnProperty("colors")) {
                    if (!Array.isArray(message.colors))
                        return "colors: array expected";
                    for (let i = 0; i < message.colors.length; ++i)
                        if (!$util.isInteger(message.colors[i]))
                            return "colors: integer[] expected";
                }
                if (message.positions != null && message.hasOwnProperty("positions")) {
                    if (!Array.isArray(message.positions))
                        return "positions: array expected";
                    for (let i = 0; i < message.positions.length; ++i)
                        if (typeof message.positions[i] !== "number")
                            return "positions: number[] expected";
                }
                return null;
            };

            /**
             * Creates a Gradient message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.TextAttachment.Gradient} Gradient
             */
            Gradient.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.TextAttachment.Gradient)
                    return object;
                let message = new $root.signalservice.TextAttachment.Gradient();
                if (object.startColor != null)
                    message.startColor = object.startColor >>> 0;
                if (object.endColor != null)
                    message.endColor = object.endColor >>> 0;
                if (object.angle != null)
                    message.angle = object.angle >>> 0;
                if (object.colors) {
                    if (!Array.isArray(object.colors))
                        throw TypeError(".signalservice.TextAttachment.Gradient.colors: array expected");
                    message.colors = [];
                    for (let i = 0; i < object.colors.length; ++i)
                        message.colors[i] = object.colors[i] >>> 0;
                }
                if (object.positions) {
                    if (!Array.isArray(object.positions))
                        throw TypeError(".signalservice.TextAttachment.Gradient.positions: array expected");
                    message.positions = [];
                    for (let i = 0; i < object.positions.length; ++i)
                        message.positions[i] = Number(object.positions[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Gradient message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {signalservice.TextAttachment.Gradient} message Gradient
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Gradient.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.colors = [];
                    object.positions = [];
                }
                if (options.defaults) {
                    object.startColor = 0;
                    object.endColor = 0;
                    object.angle = 0;
                }
                if (message.startColor != null && message.hasOwnProperty("startColor"))
                    object.startColor = message.startColor;
                if (message.endColor != null && message.hasOwnProperty("endColor"))
                    object.endColor = message.endColor;
                if (message.angle != null && message.hasOwnProperty("angle"))
                    object.angle = message.angle;
                if (message.colors && message.colors.length) {
                    object.colors = [];
                    for (let j = 0; j < message.colors.length; ++j)
                        object.colors[j] = message.colors[j];
                }
                if (message.positions && message.positions.length) {
                    object.positions = [];
                    for (let j = 0; j < message.positions.length; ++j)
                        object.positions[j] = options.json && !isFinite(message.positions[j]) ? String(message.positions[j]) : message.positions[j];
                }
                return object;
            };

            /**
             * Converts this Gradient to JSON.
             * @function toJSON
             * @memberof signalservice.TextAttachment.Gradient
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Gradient.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Gradient
             * @function getTypeUrl
             * @memberof signalservice.TextAttachment.Gradient
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Gradient.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.TextAttachment.Gradient";
            };

            return Gradient;
        })();

        return TextAttachment;
    })();

    signalservice.Verified = (function() {

        /**
         * Properties of a Verified.
         * @memberof signalservice
         * @interface IVerified
         * @property {string|null} [destination] Verified destination
         * @property {string|null} [destinationAci] Verified destinationAci
         * @property {Uint8Array|null} [identityKey] Verified identityKey
         * @property {signalservice.Verified.State|null} [state] Verified state
         * @property {Uint8Array|null} [nullMessage] Verified nullMessage
         */

        /**
         * Constructs a new Verified.
         * @memberof signalservice
         * @classdesc Represents a Verified.
         * @implements IVerified
         * @constructor
         * @param {signalservice.IVerified=} [properties] Properties to set
         */
        function Verified(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Verified destination.
         * @member {string} destination
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.destination = "";

        /**
         * Verified destinationAci.
         * @member {string} destinationAci
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.destinationAci = "";

        /**
         * Verified identityKey.
         * @member {Uint8Array} identityKey
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.identityKey = $util.newBuffer([]);

        /**
         * Verified state.
         * @member {signalservice.Verified.State} state
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.state = 0;

        /**
         * Verified nullMessage.
         * @member {Uint8Array} nullMessage
         * @memberof signalservice.Verified
         * @instance
         */
        Verified.prototype.nullMessage = $util.newBuffer([]);

        /**
         * Creates a new Verified instance using the specified properties.
         * @function create
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.IVerified=} [properties] Properties to set
         * @returns {signalservice.Verified} Verified instance
         */
        Verified.create = function create(properties) {
            return new Verified(properties);
        };

        /**
         * Encodes the specified Verified message. Does not implicitly {@link signalservice.Verified.verify|verify} messages.
         * @function encode
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.IVerified} message Verified message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Verified.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.identityKey);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            if (message.nullMessage != null && Object.hasOwnProperty.call(message, "nullMessage"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nullMessage);
            if (message.destinationAci != null && Object.hasOwnProperty.call(message, "destinationAci"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.destinationAci);
            return writer;
        };

        /**
         * Encodes the specified Verified message, length delimited. Does not implicitly {@link signalservice.Verified.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.IVerified} message Verified message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Verified.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Verified message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.Verified
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.Verified} Verified
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Verified.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.Verified();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.destination = reader.string();
                        break;
                    }
                case 5: {
                        message.destinationAci = reader.string();
                        break;
                    }
                case 2: {
                        message.identityKey = reader.bytes();
                        break;
                    }
                case 3: {
                        message.state = reader.int32();
                        break;
                    }
                case 4: {
                        message.nullMessage = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Verified message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.Verified
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.Verified} Verified
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Verified.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Verified message.
         * @function verify
         * @memberof signalservice.Verified
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Verified.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!$util.isString(message.destination))
                    return "destination: string expected";
            if (message.destinationAci != null && message.hasOwnProperty("destinationAci"))
                if (!$util.isString(message.destinationAci))
                    return "destinationAci: string expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.nullMessage != null && message.hasOwnProperty("nullMessage"))
                if (!(message.nullMessage && typeof message.nullMessage.length === "number" || $util.isString(message.nullMessage)))
                    return "nullMessage: buffer expected";
            return null;
        };

        /**
         * Creates a Verified message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.Verified
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.Verified} Verified
         */
        Verified.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.Verified)
                return object;
            let message = new $root.signalservice.Verified();
            if (object.destination != null)
                message.destination = String(object.destination);
            if (object.destinationAci != null)
                message.destinationAci = String(object.destinationAci);
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length >= 0)
                    message.identityKey = object.identityKey;
            switch (object.state) {
            default:
                if (typeof object.state === "number") {
                    message.state = object.state;
                    break;
                }
                break;
            case "DEFAULT":
            case 0:
                message.state = 0;
                break;
            case "VERIFIED":
            case 1:
                message.state = 1;
                break;
            case "UNVERIFIED":
            case 2:
                message.state = 2;
                break;
            }
            if (object.nullMessage != null)
                if (typeof object.nullMessage === "string")
                    $util.base64.decode(object.nullMessage, message.nullMessage = $util.newBuffer($util.base64.length(object.nullMessage)), 0);
                else if (object.nullMessage.length >= 0)
                    message.nullMessage = object.nullMessage;
            return message;
        };

        /**
         * Creates a plain object from a Verified message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.Verified
         * @static
         * @param {signalservice.Verified} message Verified
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Verified.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.destination = "";
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                object.state = options.enums === String ? "DEFAULT" : 0;
                if (options.bytes === String)
                    object.nullMessage = "";
                else {
                    object.nullMessage = [];
                    if (options.bytes !== Array)
                        object.nullMessage = $util.newBuffer(object.nullMessage);
                }
                object.destinationAci = "";
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = message.destination;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.signalservice.Verified.State[message.state] === undefined ? message.state : $root.signalservice.Verified.State[message.state] : message.state;
            if (message.nullMessage != null && message.hasOwnProperty("nullMessage"))
                object.nullMessage = options.bytes === String ? $util.base64.encode(message.nullMessage, 0, message.nullMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.nullMessage) : message.nullMessage;
            if (message.destinationAci != null && message.hasOwnProperty("destinationAci"))
                object.destinationAci = message.destinationAci;
            return object;
        };

        /**
         * Converts this Verified to JSON.
         * @function toJSON
         * @memberof signalservice.Verified
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Verified.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Verified
         * @function getTypeUrl
         * @memberof signalservice.Verified
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Verified.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.Verified";
        };

        /**
         * State enum.
         * @name signalservice.Verified.State
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} VERIFIED=1 VERIFIED value
         * @property {number} UNVERIFIED=2 UNVERIFIED value
         */
        Verified.State = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "VERIFIED"] = 1;
            values[valuesById[2] = "UNVERIFIED"] = 2;
            return values;
        })();

        return Verified;
    })();

    signalservice.SyncMessage = (function() {

        /**
         * Properties of a SyncMessage.
         * @memberof signalservice
         * @interface ISyncMessage
         * @property {signalservice.SyncMessage.ISent|null} [sent] SyncMessage sent
         * @property {signalservice.SyncMessage.IContacts|null} [contacts] SyncMessage contacts
         * @property {signalservice.SyncMessage.IRequest|null} [request] SyncMessage request
         * @property {Array.<signalservice.SyncMessage.IRead>|null} [read] SyncMessage read
         * @property {signalservice.SyncMessage.IBlocked|null} [blocked] SyncMessage blocked
         * @property {signalservice.IVerified|null} [verified] SyncMessage verified
         * @property {signalservice.SyncMessage.IConfiguration|null} [configuration] SyncMessage configuration
         * @property {Uint8Array|null} [padding] SyncMessage padding
         * @property {Array.<signalservice.SyncMessage.IStickerPackOperation>|null} [stickerPackOperation] SyncMessage stickerPackOperation
         * @property {signalservice.SyncMessage.IViewOnceOpen|null} [viewOnceOpen] SyncMessage viewOnceOpen
         * @property {signalservice.SyncMessage.IFetchLatest|null} [fetchLatest] SyncMessage fetchLatest
         * @property {signalservice.SyncMessage.IKeys|null} [keys] SyncMessage keys
         * @property {signalservice.SyncMessage.IMessageRequestResponse|null} [messageRequestResponse] SyncMessage messageRequestResponse
         * @property {Array.<signalservice.SyncMessage.IViewed>|null} [viewed] SyncMessage viewed
         * @property {signalservice.SyncMessage.IPniChangeNumber|null} [pniChangeNumber] SyncMessage pniChangeNumber
         * @property {signalservice.SyncMessage.ICallEvent|null} [callEvent] SyncMessage callEvent
         * @property {signalservice.SyncMessage.ICallLinkUpdate|null} [callLinkUpdate] SyncMessage callLinkUpdate
         * @property {signalservice.SyncMessage.ICallLogEvent|null} [callLogEvent] SyncMessage callLogEvent
         * @property {signalservice.SyncMessage.IDeleteForMe|null} [deleteForMe] SyncMessage deleteForMe
         */

        /**
         * Constructs a new SyncMessage.
         * @memberof signalservice
         * @classdesc Represents a SyncMessage.
         * @implements ISyncMessage
         * @constructor
         * @param {signalservice.ISyncMessage=} [properties] Properties to set
         */
        function SyncMessage(properties) {
            this.read = [];
            this.stickerPackOperation = [];
            this.viewed = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncMessage sent.
         * @member {signalservice.SyncMessage.ISent|null|undefined} sent
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.sent = null;

        /**
         * SyncMessage contacts.
         * @member {signalservice.SyncMessage.IContacts|null|undefined} contacts
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.contacts = null;

        /**
         * SyncMessage request.
         * @member {signalservice.SyncMessage.IRequest|null|undefined} request
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.request = null;

        /**
         * SyncMessage read.
         * @member {Array.<signalservice.SyncMessage.IRead>} read
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.read = $util.emptyArray;

        /**
         * SyncMessage blocked.
         * @member {signalservice.SyncMessage.IBlocked|null|undefined} blocked
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.blocked = null;

        /**
         * SyncMessage verified.
         * @member {signalservice.IVerified|null|undefined} verified
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.verified = null;

        /**
         * SyncMessage configuration.
         * @member {signalservice.SyncMessage.IConfiguration|null|undefined} configuration
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.configuration = null;

        /**
         * SyncMessage padding.
         * @member {Uint8Array} padding
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.padding = $util.newBuffer([]);

        /**
         * SyncMessage stickerPackOperation.
         * @member {Array.<signalservice.SyncMessage.IStickerPackOperation>} stickerPackOperation
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.stickerPackOperation = $util.emptyArray;

        /**
         * SyncMessage viewOnceOpen.
         * @member {signalservice.SyncMessage.IViewOnceOpen|null|undefined} viewOnceOpen
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.viewOnceOpen = null;

        /**
         * SyncMessage fetchLatest.
         * @member {signalservice.SyncMessage.IFetchLatest|null|undefined} fetchLatest
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.fetchLatest = null;

        /**
         * SyncMessage keys.
         * @member {signalservice.SyncMessage.IKeys|null|undefined} keys
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.keys = null;

        /**
         * SyncMessage messageRequestResponse.
         * @member {signalservice.SyncMessage.IMessageRequestResponse|null|undefined} messageRequestResponse
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.messageRequestResponse = null;

        /**
         * SyncMessage viewed.
         * @member {Array.<signalservice.SyncMessage.IViewed>} viewed
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.viewed = $util.emptyArray;

        /**
         * SyncMessage pniChangeNumber.
         * @member {signalservice.SyncMessage.IPniChangeNumber|null|undefined} pniChangeNumber
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.pniChangeNumber = null;

        /**
         * SyncMessage callEvent.
         * @member {signalservice.SyncMessage.ICallEvent|null|undefined} callEvent
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.callEvent = null;

        /**
         * SyncMessage callLinkUpdate.
         * @member {signalservice.SyncMessage.ICallLinkUpdate|null|undefined} callLinkUpdate
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.callLinkUpdate = null;

        /**
         * SyncMessage callLogEvent.
         * @member {signalservice.SyncMessage.ICallLogEvent|null|undefined} callLogEvent
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.callLogEvent = null;

        /**
         * SyncMessage deleteForMe.
         * @member {signalservice.SyncMessage.IDeleteForMe|null|undefined} deleteForMe
         * @memberof signalservice.SyncMessage
         * @instance
         */
        SyncMessage.prototype.deleteForMe = null;

        /**
         * Creates a new SyncMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.ISyncMessage=} [properties] Properties to set
         * @returns {signalservice.SyncMessage} SyncMessage instance
         */
        SyncMessage.create = function create(properties) {
            return new SyncMessage(properties);
        };

        /**
         * Encodes the specified SyncMessage message. Does not implicitly {@link signalservice.SyncMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.ISyncMessage} message SyncMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sent != null && Object.hasOwnProperty.call(message, "sent"))
                $root.signalservice.SyncMessage.Sent.encode(message.sent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.contacts != null && Object.hasOwnProperty.call(message, "contacts"))
                $root.signalservice.SyncMessage.Contacts.encode(message.contacts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                $root.signalservice.SyncMessage.Request.encode(message.request, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.read != null && message.read.length)
                for (let i = 0; i < message.read.length; ++i)
                    $root.signalservice.SyncMessage.Read.encode(message.read[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                $root.signalservice.SyncMessage.Blocked.encode(message.blocked, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.verified != null && Object.hasOwnProperty.call(message, "verified"))
                $root.signalservice.Verified.encode(message.verified, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.padding);
            if (message.configuration != null && Object.hasOwnProperty.call(message, "configuration"))
                $root.signalservice.SyncMessage.Configuration.encode(message.configuration, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.stickerPackOperation != null && message.stickerPackOperation.length)
                for (let i = 0; i < message.stickerPackOperation.length; ++i)
                    $root.signalservice.SyncMessage.StickerPackOperation.encode(message.stickerPackOperation[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.viewOnceOpen != null && Object.hasOwnProperty.call(message, "viewOnceOpen"))
                $root.signalservice.SyncMessage.ViewOnceOpen.encode(message.viewOnceOpen, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.fetchLatest != null && Object.hasOwnProperty.call(message, "fetchLatest"))
                $root.signalservice.SyncMessage.FetchLatest.encode(message.fetchLatest, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
                $root.signalservice.SyncMessage.Keys.encode(message.keys, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.messageRequestResponse != null && Object.hasOwnProperty.call(message, "messageRequestResponse"))
                $root.signalservice.SyncMessage.MessageRequestResponse.encode(message.messageRequestResponse, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.viewed != null && message.viewed.length)
                for (let i = 0; i < message.viewed.length; ++i)
                    $root.signalservice.SyncMessage.Viewed.encode(message.viewed[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.pniChangeNumber != null && Object.hasOwnProperty.call(message, "pniChangeNumber"))
                $root.signalservice.SyncMessage.PniChangeNumber.encode(message.pniChangeNumber, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.callEvent != null && Object.hasOwnProperty.call(message, "callEvent"))
                $root.signalservice.SyncMessage.CallEvent.encode(message.callEvent, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.callLinkUpdate != null && Object.hasOwnProperty.call(message, "callLinkUpdate"))
                $root.signalservice.SyncMessage.CallLinkUpdate.encode(message.callLinkUpdate, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.callLogEvent != null && Object.hasOwnProperty.call(message, "callLogEvent"))
                $root.signalservice.SyncMessage.CallLogEvent.encode(message.callLogEvent, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.deleteForMe != null && Object.hasOwnProperty.call(message, "deleteForMe"))
                $root.signalservice.SyncMessage.DeleteForMe.encode(message.deleteForMe, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncMessage message, length delimited. Does not implicitly {@link signalservice.SyncMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.ISyncMessage} message SyncMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.SyncMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.SyncMessage} SyncMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.sent = $root.signalservice.SyncMessage.Sent.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.contacts = $root.signalservice.SyncMessage.Contacts.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.request = $root.signalservice.SyncMessage.Request.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.read && message.read.length))
                            message.read = [];
                        message.read.push($root.signalservice.SyncMessage.Read.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.blocked = $root.signalservice.SyncMessage.Blocked.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.verified = $root.signalservice.Verified.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.configuration = $root.signalservice.SyncMessage.Configuration.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.padding = reader.bytes();
                        break;
                    }
                case 10: {
                        if (!(message.stickerPackOperation && message.stickerPackOperation.length))
                            message.stickerPackOperation = [];
                        message.stickerPackOperation.push($root.signalservice.SyncMessage.StickerPackOperation.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        message.viewOnceOpen = $root.signalservice.SyncMessage.ViewOnceOpen.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.fetchLatest = $root.signalservice.SyncMessage.FetchLatest.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.keys = $root.signalservice.SyncMessage.Keys.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.messageRequestResponse = $root.signalservice.SyncMessage.MessageRequestResponse.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        if (!(message.viewed && message.viewed.length))
                            message.viewed = [];
                        message.viewed.push($root.signalservice.SyncMessage.Viewed.decode(reader, reader.uint32()));
                        break;
                    }
                case 18: {
                        message.pniChangeNumber = $root.signalservice.SyncMessage.PniChangeNumber.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.callEvent = $root.signalservice.SyncMessage.CallEvent.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.callLinkUpdate = $root.signalservice.SyncMessage.CallLinkUpdate.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.callLogEvent = $root.signalservice.SyncMessage.CallLogEvent.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.deleteForMe = $root.signalservice.SyncMessage.DeleteForMe.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.SyncMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.SyncMessage} SyncMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncMessage message.
         * @function verify
         * @memberof signalservice.SyncMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sent != null && message.hasOwnProperty("sent")) {
                let error = $root.signalservice.SyncMessage.Sent.verify(message.sent);
                if (error)
                    return "sent." + error;
            }
            if (message.contacts != null && message.hasOwnProperty("contacts")) {
                let error = $root.signalservice.SyncMessage.Contacts.verify(message.contacts);
                if (error)
                    return "contacts." + error;
            }
            if (message.request != null && message.hasOwnProperty("request")) {
                let error = $root.signalservice.SyncMessage.Request.verify(message.request);
                if (error)
                    return "request." + error;
            }
            if (message.read != null && message.hasOwnProperty("read")) {
                if (!Array.isArray(message.read))
                    return "read: array expected";
                for (let i = 0; i < message.read.length; ++i) {
                    let error = $root.signalservice.SyncMessage.Read.verify(message.read[i]);
                    if (error)
                        return "read." + error;
                }
            }
            if (message.blocked != null && message.hasOwnProperty("blocked")) {
                let error = $root.signalservice.SyncMessage.Blocked.verify(message.blocked);
                if (error)
                    return "blocked." + error;
            }
            if (message.verified != null && message.hasOwnProperty("verified")) {
                let error = $root.signalservice.Verified.verify(message.verified);
                if (error)
                    return "verified." + error;
            }
            if (message.configuration != null && message.hasOwnProperty("configuration")) {
                let error = $root.signalservice.SyncMessage.Configuration.verify(message.configuration);
                if (error)
                    return "configuration." + error;
            }
            if (message.padding != null && message.hasOwnProperty("padding"))
                if (!(message.padding && typeof message.padding.length === "number" || $util.isString(message.padding)))
                    return "padding: buffer expected";
            if (message.stickerPackOperation != null && message.hasOwnProperty("stickerPackOperation")) {
                if (!Array.isArray(message.stickerPackOperation))
                    return "stickerPackOperation: array expected";
                for (let i = 0; i < message.stickerPackOperation.length; ++i) {
                    let error = $root.signalservice.SyncMessage.StickerPackOperation.verify(message.stickerPackOperation[i]);
                    if (error)
                        return "stickerPackOperation." + error;
                }
            }
            if (message.viewOnceOpen != null && message.hasOwnProperty("viewOnceOpen")) {
                let error = $root.signalservice.SyncMessage.ViewOnceOpen.verify(message.viewOnceOpen);
                if (error)
                    return "viewOnceOpen." + error;
            }
            if (message.fetchLatest != null && message.hasOwnProperty("fetchLatest")) {
                let error = $root.signalservice.SyncMessage.FetchLatest.verify(message.fetchLatest);
                if (error)
                    return "fetchLatest." + error;
            }
            if (message.keys != null && message.hasOwnProperty("keys")) {
                let error = $root.signalservice.SyncMessage.Keys.verify(message.keys);
                if (error)
                    return "keys." + error;
            }
            if (message.messageRequestResponse != null && message.hasOwnProperty("messageRequestResponse")) {
                let error = $root.signalservice.SyncMessage.MessageRequestResponse.verify(message.messageRequestResponse);
                if (error)
                    return "messageRequestResponse." + error;
            }
            if (message.viewed != null && message.hasOwnProperty("viewed")) {
                if (!Array.isArray(message.viewed))
                    return "viewed: array expected";
                for (let i = 0; i < message.viewed.length; ++i) {
                    let error = $root.signalservice.SyncMessage.Viewed.verify(message.viewed[i]);
                    if (error)
                        return "viewed." + error;
                }
            }
            if (message.pniChangeNumber != null && message.hasOwnProperty("pniChangeNumber")) {
                let error = $root.signalservice.SyncMessage.PniChangeNumber.verify(message.pniChangeNumber);
                if (error)
                    return "pniChangeNumber." + error;
            }
            if (message.callEvent != null && message.hasOwnProperty("callEvent")) {
                let error = $root.signalservice.SyncMessage.CallEvent.verify(message.callEvent);
                if (error)
                    return "callEvent." + error;
            }
            if (message.callLinkUpdate != null && message.hasOwnProperty("callLinkUpdate")) {
                let error = $root.signalservice.SyncMessage.CallLinkUpdate.verify(message.callLinkUpdate);
                if (error)
                    return "callLinkUpdate." + error;
            }
            if (message.callLogEvent != null && message.hasOwnProperty("callLogEvent")) {
                let error = $root.signalservice.SyncMessage.CallLogEvent.verify(message.callLogEvent);
                if (error)
                    return "callLogEvent." + error;
            }
            if (message.deleteForMe != null && message.hasOwnProperty("deleteForMe")) {
                let error = $root.signalservice.SyncMessage.DeleteForMe.verify(message.deleteForMe);
                if (error)
                    return "deleteForMe." + error;
            }
            return null;
        };

        /**
         * Creates a SyncMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.SyncMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.SyncMessage} SyncMessage
         */
        SyncMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.SyncMessage)
                return object;
            let message = new $root.signalservice.SyncMessage();
            if (object.sent != null) {
                if (typeof object.sent !== "object")
                    throw TypeError(".signalservice.SyncMessage.sent: object expected");
                message.sent = $root.signalservice.SyncMessage.Sent.fromObject(object.sent);
            }
            if (object.contacts != null) {
                if (typeof object.contacts !== "object")
                    throw TypeError(".signalservice.SyncMessage.contacts: object expected");
                message.contacts = $root.signalservice.SyncMessage.Contacts.fromObject(object.contacts);
            }
            if (object.request != null) {
                if (typeof object.request !== "object")
                    throw TypeError(".signalservice.SyncMessage.request: object expected");
                message.request = $root.signalservice.SyncMessage.Request.fromObject(object.request);
            }
            if (object.read) {
                if (!Array.isArray(object.read))
                    throw TypeError(".signalservice.SyncMessage.read: array expected");
                message.read = [];
                for (let i = 0; i < object.read.length; ++i) {
                    if (typeof object.read[i] !== "object")
                        throw TypeError(".signalservice.SyncMessage.read: object expected");
                    message.read[i] = $root.signalservice.SyncMessage.Read.fromObject(object.read[i]);
                }
            }
            if (object.blocked != null) {
                if (typeof object.blocked !== "object")
                    throw TypeError(".signalservice.SyncMessage.blocked: object expected");
                message.blocked = $root.signalservice.SyncMessage.Blocked.fromObject(object.blocked);
            }
            if (object.verified != null) {
                if (typeof object.verified !== "object")
                    throw TypeError(".signalservice.SyncMessage.verified: object expected");
                message.verified = $root.signalservice.Verified.fromObject(object.verified);
            }
            if (object.configuration != null) {
                if (typeof object.configuration !== "object")
                    throw TypeError(".signalservice.SyncMessage.configuration: object expected");
                message.configuration = $root.signalservice.SyncMessage.Configuration.fromObject(object.configuration);
            }
            if (object.padding != null)
                if (typeof object.padding === "string")
                    $util.base64.decode(object.padding, message.padding = $util.newBuffer($util.base64.length(object.padding)), 0);
                else if (object.padding.length >= 0)
                    message.padding = object.padding;
            if (object.stickerPackOperation) {
                if (!Array.isArray(object.stickerPackOperation))
                    throw TypeError(".signalservice.SyncMessage.stickerPackOperation: array expected");
                message.stickerPackOperation = [];
                for (let i = 0; i < object.stickerPackOperation.length; ++i) {
                    if (typeof object.stickerPackOperation[i] !== "object")
                        throw TypeError(".signalservice.SyncMessage.stickerPackOperation: object expected");
                    message.stickerPackOperation[i] = $root.signalservice.SyncMessage.StickerPackOperation.fromObject(object.stickerPackOperation[i]);
                }
            }
            if (object.viewOnceOpen != null) {
                if (typeof object.viewOnceOpen !== "object")
                    throw TypeError(".signalservice.SyncMessage.viewOnceOpen: object expected");
                message.viewOnceOpen = $root.signalservice.SyncMessage.ViewOnceOpen.fromObject(object.viewOnceOpen);
            }
            if (object.fetchLatest != null) {
                if (typeof object.fetchLatest !== "object")
                    throw TypeError(".signalservice.SyncMessage.fetchLatest: object expected");
                message.fetchLatest = $root.signalservice.SyncMessage.FetchLatest.fromObject(object.fetchLatest);
            }
            if (object.keys != null) {
                if (typeof object.keys !== "object")
                    throw TypeError(".signalservice.SyncMessage.keys: object expected");
                message.keys = $root.signalservice.SyncMessage.Keys.fromObject(object.keys);
            }
            if (object.messageRequestResponse != null) {
                if (typeof object.messageRequestResponse !== "object")
                    throw TypeError(".signalservice.SyncMessage.messageRequestResponse: object expected");
                message.messageRequestResponse = $root.signalservice.SyncMessage.MessageRequestResponse.fromObject(object.messageRequestResponse);
            }
            if (object.viewed) {
                if (!Array.isArray(object.viewed))
                    throw TypeError(".signalservice.SyncMessage.viewed: array expected");
                message.viewed = [];
                for (let i = 0; i < object.viewed.length; ++i) {
                    if (typeof object.viewed[i] !== "object")
                        throw TypeError(".signalservice.SyncMessage.viewed: object expected");
                    message.viewed[i] = $root.signalservice.SyncMessage.Viewed.fromObject(object.viewed[i]);
                }
            }
            if (object.pniChangeNumber != null) {
                if (typeof object.pniChangeNumber !== "object")
                    throw TypeError(".signalservice.SyncMessage.pniChangeNumber: object expected");
                message.pniChangeNumber = $root.signalservice.SyncMessage.PniChangeNumber.fromObject(object.pniChangeNumber);
            }
            if (object.callEvent != null) {
                if (typeof object.callEvent !== "object")
                    throw TypeError(".signalservice.SyncMessage.callEvent: object expected");
                message.callEvent = $root.signalservice.SyncMessage.CallEvent.fromObject(object.callEvent);
            }
            if (object.callLinkUpdate != null) {
                if (typeof object.callLinkUpdate !== "object")
                    throw TypeError(".signalservice.SyncMessage.callLinkUpdate: object expected");
                message.callLinkUpdate = $root.signalservice.SyncMessage.CallLinkUpdate.fromObject(object.callLinkUpdate);
            }
            if (object.callLogEvent != null) {
                if (typeof object.callLogEvent !== "object")
                    throw TypeError(".signalservice.SyncMessage.callLogEvent: object expected");
                message.callLogEvent = $root.signalservice.SyncMessage.CallLogEvent.fromObject(object.callLogEvent);
            }
            if (object.deleteForMe != null) {
                if (typeof object.deleteForMe !== "object")
                    throw TypeError(".signalservice.SyncMessage.deleteForMe: object expected");
                message.deleteForMe = $root.signalservice.SyncMessage.DeleteForMe.fromObject(object.deleteForMe);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.SyncMessage
         * @static
         * @param {signalservice.SyncMessage} message SyncMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.read = [];
                object.stickerPackOperation = [];
                object.viewed = [];
            }
            if (options.defaults) {
                object.sent = null;
                object.contacts = null;
                object.request = null;
                object.blocked = null;
                object.verified = null;
                if (options.bytes === String)
                    object.padding = "";
                else {
                    object.padding = [];
                    if (options.bytes !== Array)
                        object.padding = $util.newBuffer(object.padding);
                }
                object.configuration = null;
                object.viewOnceOpen = null;
                object.fetchLatest = null;
                object.keys = null;
                object.messageRequestResponse = null;
                object.pniChangeNumber = null;
                object.callEvent = null;
                object.callLinkUpdate = null;
                object.callLogEvent = null;
                object.deleteForMe = null;
            }
            if (message.sent != null && message.hasOwnProperty("sent"))
                object.sent = $root.signalservice.SyncMessage.Sent.toObject(message.sent, options);
            if (message.contacts != null && message.hasOwnProperty("contacts"))
                object.contacts = $root.signalservice.SyncMessage.Contacts.toObject(message.contacts, options);
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = $root.signalservice.SyncMessage.Request.toObject(message.request, options);
            if (message.read && message.read.length) {
                object.read = [];
                for (let j = 0; j < message.read.length; ++j)
                    object.read[j] = $root.signalservice.SyncMessage.Read.toObject(message.read[j], options);
            }
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = $root.signalservice.SyncMessage.Blocked.toObject(message.blocked, options);
            if (message.verified != null && message.hasOwnProperty("verified"))
                object.verified = $root.signalservice.Verified.toObject(message.verified, options);
            if (message.padding != null && message.hasOwnProperty("padding"))
                object.padding = options.bytes === String ? $util.base64.encode(message.padding, 0, message.padding.length) : options.bytes === Array ? Array.prototype.slice.call(message.padding) : message.padding;
            if (message.configuration != null && message.hasOwnProperty("configuration"))
                object.configuration = $root.signalservice.SyncMessage.Configuration.toObject(message.configuration, options);
            if (message.stickerPackOperation && message.stickerPackOperation.length) {
                object.stickerPackOperation = [];
                for (let j = 0; j < message.stickerPackOperation.length; ++j)
                    object.stickerPackOperation[j] = $root.signalservice.SyncMessage.StickerPackOperation.toObject(message.stickerPackOperation[j], options);
            }
            if (message.viewOnceOpen != null && message.hasOwnProperty("viewOnceOpen"))
                object.viewOnceOpen = $root.signalservice.SyncMessage.ViewOnceOpen.toObject(message.viewOnceOpen, options);
            if (message.fetchLatest != null && message.hasOwnProperty("fetchLatest"))
                object.fetchLatest = $root.signalservice.SyncMessage.FetchLatest.toObject(message.fetchLatest, options);
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = $root.signalservice.SyncMessage.Keys.toObject(message.keys, options);
            if (message.messageRequestResponse != null && message.hasOwnProperty("messageRequestResponse"))
                object.messageRequestResponse = $root.signalservice.SyncMessage.MessageRequestResponse.toObject(message.messageRequestResponse, options);
            if (message.viewed && message.viewed.length) {
                object.viewed = [];
                for (let j = 0; j < message.viewed.length; ++j)
                    object.viewed[j] = $root.signalservice.SyncMessage.Viewed.toObject(message.viewed[j], options);
            }
            if (message.pniChangeNumber != null && message.hasOwnProperty("pniChangeNumber"))
                object.pniChangeNumber = $root.signalservice.SyncMessage.PniChangeNumber.toObject(message.pniChangeNumber, options);
            if (message.callEvent != null && message.hasOwnProperty("callEvent"))
                object.callEvent = $root.signalservice.SyncMessage.CallEvent.toObject(message.callEvent, options);
            if (message.callLinkUpdate != null && message.hasOwnProperty("callLinkUpdate"))
                object.callLinkUpdate = $root.signalservice.SyncMessage.CallLinkUpdate.toObject(message.callLinkUpdate, options);
            if (message.callLogEvent != null && message.hasOwnProperty("callLogEvent"))
                object.callLogEvent = $root.signalservice.SyncMessage.CallLogEvent.toObject(message.callLogEvent, options);
            if (message.deleteForMe != null && message.hasOwnProperty("deleteForMe"))
                object.deleteForMe = $root.signalservice.SyncMessage.DeleteForMe.toObject(message.deleteForMe, options);
            return object;
        };

        /**
         * Converts this SyncMessage to JSON.
         * @function toJSON
         * @memberof signalservice.SyncMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncMessage
         * @function getTypeUrl
         * @memberof signalservice.SyncMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SyncMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.SyncMessage";
        };

        SyncMessage.Sent = (function() {

            /**
             * Properties of a Sent.
             * @memberof signalservice.SyncMessage
             * @interface ISent
             * @property {string|null} [destination] Sent destination
             * @property {string|null} [destinationServiceId] Sent destinationServiceId
             * @property {number|Long|null} [timestamp] Sent timestamp
             * @property {signalservice.IDataMessage|null} [message] Sent message
             * @property {number|Long|null} [expirationStartTimestamp] Sent expirationStartTimestamp
             * @property {Array.<signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus>|null} [unidentifiedStatus] Sent unidentifiedStatus
             * @property {boolean|null} [isRecipientUpdate] Sent isRecipientUpdate
             * @property {signalservice.IStoryMessage|null} [storyMessage] Sent storyMessage
             * @property {Array.<signalservice.SyncMessage.Sent.IStoryMessageRecipient>|null} [storyMessageRecipients] Sent storyMessageRecipients
             * @property {signalservice.IEditMessage|null} [editMessage] Sent editMessage
             */

            /**
             * Constructs a new Sent.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Sent.
             * @implements ISent
             * @constructor
             * @param {signalservice.SyncMessage.ISent=} [properties] Properties to set
             */
            function Sent(properties) {
                this.unidentifiedStatus = [];
                this.storyMessageRecipients = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sent destination.
             * @member {string} destination
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.destination = "";

            /**
             * Sent destinationServiceId.
             * @member {string} destinationServiceId
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.destinationServiceId = "";

            /**
             * Sent timestamp.
             * @member {number|Long} timestamp
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Sent message.
             * @member {signalservice.IDataMessage|null|undefined} message
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.message = null;

            /**
             * Sent expirationStartTimestamp.
             * @member {number|Long} expirationStartTimestamp
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.expirationStartTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Sent unidentifiedStatus.
             * @member {Array.<signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus>} unidentifiedStatus
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.unidentifiedStatus = $util.emptyArray;

            /**
             * Sent isRecipientUpdate.
             * @member {boolean} isRecipientUpdate
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.isRecipientUpdate = false;

            /**
             * Sent storyMessage.
             * @member {signalservice.IStoryMessage|null|undefined} storyMessage
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.storyMessage = null;

            /**
             * Sent storyMessageRecipients.
             * @member {Array.<signalservice.SyncMessage.Sent.IStoryMessageRecipient>} storyMessageRecipients
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.storyMessageRecipients = $util.emptyArray;

            /**
             * Sent editMessage.
             * @member {signalservice.IEditMessage|null|undefined} editMessage
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             */
            Sent.prototype.editMessage = null;

            /**
             * Creates a new Sent instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.ISent=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Sent} Sent instance
             */
            Sent.create = function create(properties) {
                return new Sent(properties);
            };

            /**
             * Encodes the specified Sent message. Does not implicitly {@link signalservice.SyncMessage.Sent.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.ISent} message Sent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.signalservice.DataMessage.encode(message.message, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.expirationStartTimestamp != null && Object.hasOwnProperty.call(message, "expirationStartTimestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.expirationStartTimestamp);
                if (message.unidentifiedStatus != null && message.unidentifiedStatus.length)
                    for (let i = 0; i < message.unidentifiedStatus.length; ++i)
                        $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.encode(message.unidentifiedStatus[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.isRecipientUpdate != null && Object.hasOwnProperty.call(message, "isRecipientUpdate"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isRecipientUpdate);
                if (message.destinationServiceId != null && Object.hasOwnProperty.call(message, "destinationServiceId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.destinationServiceId);
                if (message.storyMessage != null && Object.hasOwnProperty.call(message, "storyMessage"))
                    $root.signalservice.StoryMessage.encode(message.storyMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.storyMessageRecipients != null && message.storyMessageRecipients.length)
                    for (let i = 0; i < message.storyMessageRecipients.length; ++i)
                        $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.encode(message.storyMessageRecipients[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.editMessage != null && Object.hasOwnProperty.call(message, "editMessage"))
                    $root.signalservice.EditMessage.encode(message.editMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Sent message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Sent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.ISent} message Sent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sent message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Sent} Sent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Sent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.destination = reader.string();
                            break;
                        }
                    case 7: {
                            message.destinationServiceId = reader.string();
                            break;
                        }
                    case 2: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.message = $root.signalservice.DataMessage.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.expirationStartTimestamp = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.unidentifiedStatus && message.unidentifiedStatus.length))
                                message.unidentifiedStatus = [];
                            message.unidentifiedStatus.push($root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            message.isRecipientUpdate = reader.bool();
                            break;
                        }
                    case 8: {
                            message.storyMessage = $root.signalservice.StoryMessage.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            if (!(message.storyMessageRecipients && message.storyMessageRecipients.length))
                                message.storyMessageRecipients = [];
                            message.storyMessageRecipients.push($root.signalservice.SyncMessage.Sent.StoryMessageRecipient.decode(reader, reader.uint32()));
                            break;
                        }
                    case 10: {
                            message.editMessage = $root.signalservice.EditMessage.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Sent} Sent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sent message.
             * @function verify
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destination != null && message.hasOwnProperty("destination"))
                    if (!$util.isString(message.destination))
                        return "destination: string expected";
                if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                    if (!$util.isString(message.destinationServiceId))
                        return "destinationServiceId: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.signalservice.DataMessage.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                if (message.expirationStartTimestamp != null && message.hasOwnProperty("expirationStartTimestamp"))
                    if (!$util.isInteger(message.expirationStartTimestamp) && !(message.expirationStartTimestamp && $util.isInteger(message.expirationStartTimestamp.low) && $util.isInteger(message.expirationStartTimestamp.high)))
                        return "expirationStartTimestamp: integer|Long expected";
                if (message.unidentifiedStatus != null && message.hasOwnProperty("unidentifiedStatus")) {
                    if (!Array.isArray(message.unidentifiedStatus))
                        return "unidentifiedStatus: array expected";
                    for (let i = 0; i < message.unidentifiedStatus.length; ++i) {
                        let error = $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.verify(message.unidentifiedStatus[i]);
                        if (error)
                            return "unidentifiedStatus." + error;
                    }
                }
                if (message.isRecipientUpdate != null && message.hasOwnProperty("isRecipientUpdate"))
                    if (typeof message.isRecipientUpdate !== "boolean")
                        return "isRecipientUpdate: boolean expected";
                if (message.storyMessage != null && message.hasOwnProperty("storyMessage")) {
                    let error = $root.signalservice.StoryMessage.verify(message.storyMessage);
                    if (error)
                        return "storyMessage." + error;
                }
                if (message.storyMessageRecipients != null && message.hasOwnProperty("storyMessageRecipients")) {
                    if (!Array.isArray(message.storyMessageRecipients))
                        return "storyMessageRecipients: array expected";
                    for (let i = 0; i < message.storyMessageRecipients.length; ++i) {
                        let error = $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.verify(message.storyMessageRecipients[i]);
                        if (error)
                            return "storyMessageRecipients." + error;
                    }
                }
                if (message.editMessage != null && message.hasOwnProperty("editMessage")) {
                    let error = $root.signalservice.EditMessage.verify(message.editMessage);
                    if (error)
                        return "editMessage." + error;
                }
                return null;
            };

            /**
             * Creates a Sent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Sent} Sent
             */
            Sent.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Sent)
                    return object;
                let message = new $root.signalservice.SyncMessage.Sent();
                if (object.destination != null)
                    message.destination = String(object.destination);
                if (object.destinationServiceId != null)
                    message.destinationServiceId = String(object.destinationServiceId);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".signalservice.SyncMessage.Sent.message: object expected");
                    message.message = $root.signalservice.DataMessage.fromObject(object.message);
                }
                if (object.expirationStartTimestamp != null)
                    if ($util.Long)
                        (message.expirationStartTimestamp = $util.Long.fromValue(object.expirationStartTimestamp)).unsigned = true;
                    else if (typeof object.expirationStartTimestamp === "string")
                        message.expirationStartTimestamp = parseInt(object.expirationStartTimestamp, 10);
                    else if (typeof object.expirationStartTimestamp === "number")
                        message.expirationStartTimestamp = object.expirationStartTimestamp;
                    else if (typeof object.expirationStartTimestamp === "object")
                        message.expirationStartTimestamp = new $util.LongBits(object.expirationStartTimestamp.low >>> 0, object.expirationStartTimestamp.high >>> 0).toNumber(true);
                if (object.unidentifiedStatus) {
                    if (!Array.isArray(object.unidentifiedStatus))
                        throw TypeError(".signalservice.SyncMessage.Sent.unidentifiedStatus: array expected");
                    message.unidentifiedStatus = [];
                    for (let i = 0; i < object.unidentifiedStatus.length; ++i) {
                        if (typeof object.unidentifiedStatus[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.Sent.unidentifiedStatus: object expected");
                        message.unidentifiedStatus[i] = $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.fromObject(object.unidentifiedStatus[i]);
                    }
                }
                if (object.isRecipientUpdate != null)
                    message.isRecipientUpdate = Boolean(object.isRecipientUpdate);
                if (object.storyMessage != null) {
                    if (typeof object.storyMessage !== "object")
                        throw TypeError(".signalservice.SyncMessage.Sent.storyMessage: object expected");
                    message.storyMessage = $root.signalservice.StoryMessage.fromObject(object.storyMessage);
                }
                if (object.storyMessageRecipients) {
                    if (!Array.isArray(object.storyMessageRecipients))
                        throw TypeError(".signalservice.SyncMessage.Sent.storyMessageRecipients: array expected");
                    message.storyMessageRecipients = [];
                    for (let i = 0; i < object.storyMessageRecipients.length; ++i) {
                        if (typeof object.storyMessageRecipients[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.Sent.storyMessageRecipients: object expected");
                        message.storyMessageRecipients[i] = $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.fromObject(object.storyMessageRecipients[i]);
                    }
                }
                if (object.editMessage != null) {
                    if (typeof object.editMessage !== "object")
                        throw TypeError(".signalservice.SyncMessage.Sent.editMessage: object expected");
                    message.editMessage = $root.signalservice.EditMessage.fromObject(object.editMessage);
                }
                return message;
            };

            /**
             * Creates a plain object from a Sent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {signalservice.SyncMessage.Sent} message Sent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.unidentifiedStatus = [];
                    object.storyMessageRecipients = [];
                }
                if (options.defaults) {
                    object.destination = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.message = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.expirationStartTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expirationStartTimestamp = options.longs === String ? "0" : 0;
                    object.isRecipientUpdate = false;
                    object.destinationServiceId = "";
                    object.storyMessage = null;
                    object.editMessage = null;
                }
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.signalservice.DataMessage.toObject(message.message, options);
                if (message.expirationStartTimestamp != null && message.hasOwnProperty("expirationStartTimestamp"))
                    if (typeof message.expirationStartTimestamp === "number")
                        object.expirationStartTimestamp = options.longs === String ? String(message.expirationStartTimestamp) : message.expirationStartTimestamp;
                    else
                        object.expirationStartTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expirationStartTimestamp) : options.longs === Number ? new $util.LongBits(message.expirationStartTimestamp.low >>> 0, message.expirationStartTimestamp.high >>> 0).toNumber(true) : message.expirationStartTimestamp;
                if (message.unidentifiedStatus && message.unidentifiedStatus.length) {
                    object.unidentifiedStatus = [];
                    for (let j = 0; j < message.unidentifiedStatus.length; ++j)
                        object.unidentifiedStatus[j] = $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.toObject(message.unidentifiedStatus[j], options);
                }
                if (message.isRecipientUpdate != null && message.hasOwnProperty("isRecipientUpdate"))
                    object.isRecipientUpdate = message.isRecipientUpdate;
                if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                    object.destinationServiceId = message.destinationServiceId;
                if (message.storyMessage != null && message.hasOwnProperty("storyMessage"))
                    object.storyMessage = $root.signalservice.StoryMessage.toObject(message.storyMessage, options);
                if (message.storyMessageRecipients && message.storyMessageRecipients.length) {
                    object.storyMessageRecipients = [];
                    for (let j = 0; j < message.storyMessageRecipients.length; ++j)
                        object.storyMessageRecipients[j] = $root.signalservice.SyncMessage.Sent.StoryMessageRecipient.toObject(message.storyMessageRecipients[j], options);
                }
                if (message.editMessage != null && message.hasOwnProperty("editMessage"))
                    object.editMessage = $root.signalservice.EditMessage.toObject(message.editMessage, options);
                return object;
            };

            /**
             * Converts this Sent to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Sent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sent
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Sent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Sent";
            };

            Sent.UnidentifiedDeliveryStatus = (function() {

                /**
                 * Properties of an UnidentifiedDeliveryStatus.
                 * @memberof signalservice.SyncMessage.Sent
                 * @interface IUnidentifiedDeliveryStatus
                 * @property {string|null} [destination] UnidentifiedDeliveryStatus destination
                 * @property {string|null} [destinationServiceId] UnidentifiedDeliveryStatus destinationServiceId
                 * @property {boolean|null} [unidentified] UnidentifiedDeliveryStatus unidentified
                 * @property {Uint8Array|null} [destinationPniIdentityKey] UnidentifiedDeliveryStatus destinationPniIdentityKey
                 */

                /**
                 * Constructs a new UnidentifiedDeliveryStatus.
                 * @memberof signalservice.SyncMessage.Sent
                 * @classdesc Represents an UnidentifiedDeliveryStatus.
                 * @implements IUnidentifiedDeliveryStatus
                 * @constructor
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus=} [properties] Properties to set
                 */
                function UnidentifiedDeliveryStatus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UnidentifiedDeliveryStatus destination.
                 * @member {string} destination
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.destination = "";

                /**
                 * UnidentifiedDeliveryStatus destinationServiceId.
                 * @member {string} destinationServiceId
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.destinationServiceId = "";

                /**
                 * UnidentifiedDeliveryStatus unidentified.
                 * @member {boolean} unidentified
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.unidentified = false;

                /**
                 * UnidentifiedDeliveryStatus destinationPniIdentityKey.
                 * @member {Uint8Array} destinationPniIdentityKey
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 */
                UnidentifiedDeliveryStatus.prototype.destinationPniIdentityKey = $util.newBuffer([]);

                /**
                 * Creates a new UnidentifiedDeliveryStatus instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus instance
                 */
                UnidentifiedDeliveryStatus.create = function create(properties) {
                    return new UnidentifiedDeliveryStatus(properties);
                };

                /**
                 * Encodes the specified UnidentifiedDeliveryStatus message. Does not implicitly {@link signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus} message UnidentifiedDeliveryStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnidentifiedDeliveryStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                    if (message.unidentified != null && Object.hasOwnProperty.call(message, "unidentified"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.unidentified);
                    if (message.destinationServiceId != null && Object.hasOwnProperty.call(message, "destinationServiceId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationServiceId);
                    if (message.destinationPniIdentityKey != null && Object.hasOwnProperty.call(message, "destinationPniIdentityKey"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.destinationPniIdentityKey);
                    return writer;
                };

                /**
                 * Encodes the specified UnidentifiedDeliveryStatus message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IUnidentifiedDeliveryStatus} message UnidentifiedDeliveryStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnidentifiedDeliveryStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UnidentifiedDeliveryStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnidentifiedDeliveryStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.destination = reader.string();
                                break;
                            }
                        case 3: {
                                message.destinationServiceId = reader.string();
                                break;
                            }
                        case 2: {
                                message.unidentified = reader.bool();
                                break;
                            }
                        case 5: {
                                message.destinationPniIdentityKey = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UnidentifiedDeliveryStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnidentifiedDeliveryStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UnidentifiedDeliveryStatus message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnidentifiedDeliveryStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.destination != null && message.hasOwnProperty("destination"))
                        if (!$util.isString(message.destination))
                            return "destination: string expected";
                    if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                        if (!$util.isString(message.destinationServiceId))
                            return "destinationServiceId: string expected";
                    if (message.unidentified != null && message.hasOwnProperty("unidentified"))
                        if (typeof message.unidentified !== "boolean")
                            return "unidentified: boolean expected";
                    if (message.destinationPniIdentityKey != null && message.hasOwnProperty("destinationPniIdentityKey"))
                        if (!(message.destinationPniIdentityKey && typeof message.destinationPniIdentityKey.length === "number" || $util.isString(message.destinationPniIdentityKey)))
                            return "destinationPniIdentityKey: buffer expected";
                    return null;
                };

                /**
                 * Creates an UnidentifiedDeliveryStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} UnidentifiedDeliveryStatus
                 */
                UnidentifiedDeliveryStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus)
                        return object;
                    let message = new $root.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus();
                    if (object.destination != null)
                        message.destination = String(object.destination);
                    if (object.destinationServiceId != null)
                        message.destinationServiceId = String(object.destinationServiceId);
                    if (object.unidentified != null)
                        message.unidentified = Boolean(object.unidentified);
                    if (object.destinationPniIdentityKey != null)
                        if (typeof object.destinationPniIdentityKey === "string")
                            $util.base64.decode(object.destinationPniIdentityKey, message.destinationPniIdentityKey = $util.newBuffer($util.base64.length(object.destinationPniIdentityKey)), 0);
                        else if (object.destinationPniIdentityKey.length >= 0)
                            message.destinationPniIdentityKey = object.destinationPniIdentityKey;
                    return message;
                };

                /**
                 * Creates a plain object from an UnidentifiedDeliveryStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus} message UnidentifiedDeliveryStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnidentifiedDeliveryStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.destination = "";
                        object.unidentified = false;
                        object.destinationServiceId = "";
                        if (options.bytes === String)
                            object.destinationPniIdentityKey = "";
                        else {
                            object.destinationPniIdentityKey = [];
                            if (options.bytes !== Array)
                                object.destinationPniIdentityKey = $util.newBuffer(object.destinationPniIdentityKey);
                        }
                    }
                    if (message.destination != null && message.hasOwnProperty("destination"))
                        object.destination = message.destination;
                    if (message.unidentified != null && message.hasOwnProperty("unidentified"))
                        object.unidentified = message.unidentified;
                    if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                        object.destinationServiceId = message.destinationServiceId;
                    if (message.destinationPniIdentityKey != null && message.hasOwnProperty("destinationPniIdentityKey"))
                        object.destinationPniIdentityKey = options.bytes === String ? $util.base64.encode(message.destinationPniIdentityKey, 0, message.destinationPniIdentityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.destinationPniIdentityKey) : message.destinationPniIdentityKey;
                    return object;
                };

                /**
                 * Converts this UnidentifiedDeliveryStatus to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnidentifiedDeliveryStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for UnidentifiedDeliveryStatus
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                UnidentifiedDeliveryStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus";
                };

                return UnidentifiedDeliveryStatus;
            })();

            Sent.StoryMessageRecipient = (function() {

                /**
                 * Properties of a StoryMessageRecipient.
                 * @memberof signalservice.SyncMessage.Sent
                 * @interface IStoryMessageRecipient
                 * @property {string|null} [destinationServiceId] StoryMessageRecipient destinationServiceId
                 * @property {Array.<string>|null} [distributionListIds] StoryMessageRecipient distributionListIds
                 * @property {boolean|null} [isAllowedToReply] StoryMessageRecipient isAllowedToReply
                 */

                /**
                 * Constructs a new StoryMessageRecipient.
                 * @memberof signalservice.SyncMessage.Sent
                 * @classdesc Represents a StoryMessageRecipient.
                 * @implements IStoryMessageRecipient
                 * @constructor
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient=} [properties] Properties to set
                 */
                function StoryMessageRecipient(properties) {
                    this.distributionListIds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StoryMessageRecipient destinationServiceId.
                 * @member {string} destinationServiceId
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 */
                StoryMessageRecipient.prototype.destinationServiceId = "";

                /**
                 * StoryMessageRecipient distributionListIds.
                 * @member {Array.<string>} distributionListIds
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 */
                StoryMessageRecipient.prototype.distributionListIds = $util.emptyArray;

                /**
                 * StoryMessageRecipient isAllowedToReply.
                 * @member {boolean} isAllowedToReply
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 */
                StoryMessageRecipient.prototype.isAllowedToReply = false;

                /**
                 * Creates a new StoryMessageRecipient instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient instance
                 */
                StoryMessageRecipient.create = function create(properties) {
                    return new StoryMessageRecipient(properties);
                };

                /**
                 * Encodes the specified StoryMessageRecipient message. Does not implicitly {@link signalservice.SyncMessage.Sent.StoryMessageRecipient.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient} message StoryMessageRecipient message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StoryMessageRecipient.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.destinationServiceId != null && Object.hasOwnProperty.call(message, "destinationServiceId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.destinationServiceId);
                    if (message.distributionListIds != null && message.distributionListIds.length)
                        for (let i = 0; i < message.distributionListIds.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.distributionListIds[i]);
                    if (message.isAllowedToReply != null && Object.hasOwnProperty.call(message, "isAllowedToReply"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAllowedToReply);
                    return writer;
                };

                /**
                 * Encodes the specified StoryMessageRecipient message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Sent.StoryMessageRecipient.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.IStoryMessageRecipient} message StoryMessageRecipient message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StoryMessageRecipient.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StoryMessageRecipient message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StoryMessageRecipient.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Sent.StoryMessageRecipient();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.destinationServiceId = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.distributionListIds && message.distributionListIds.length))
                                    message.distributionListIds = [];
                                message.distributionListIds.push(reader.string());
                                break;
                            }
                        case 3: {
                                message.isAllowedToReply = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StoryMessageRecipient message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StoryMessageRecipient.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StoryMessageRecipient message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StoryMessageRecipient.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                        if (!$util.isString(message.destinationServiceId))
                            return "destinationServiceId: string expected";
                    if (message.distributionListIds != null && message.hasOwnProperty("distributionListIds")) {
                        if (!Array.isArray(message.distributionListIds))
                            return "distributionListIds: array expected";
                        for (let i = 0; i < message.distributionListIds.length; ++i)
                            if (!$util.isString(message.distributionListIds[i]))
                                return "distributionListIds: string[] expected";
                    }
                    if (message.isAllowedToReply != null && message.hasOwnProperty("isAllowedToReply"))
                        if (typeof message.isAllowedToReply !== "boolean")
                            return "isAllowedToReply: boolean expected";
                    return null;
                };

                /**
                 * Creates a StoryMessageRecipient message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.Sent.StoryMessageRecipient} StoryMessageRecipient
                 */
                StoryMessageRecipient.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.Sent.StoryMessageRecipient)
                        return object;
                    let message = new $root.signalservice.SyncMessage.Sent.StoryMessageRecipient();
                    if (object.destinationServiceId != null)
                        message.destinationServiceId = String(object.destinationServiceId);
                    if (object.distributionListIds) {
                        if (!Array.isArray(object.distributionListIds))
                            throw TypeError(".signalservice.SyncMessage.Sent.StoryMessageRecipient.distributionListIds: array expected");
                        message.distributionListIds = [];
                        for (let i = 0; i < object.distributionListIds.length; ++i)
                            message.distributionListIds[i] = String(object.distributionListIds[i]);
                    }
                    if (object.isAllowedToReply != null)
                        message.isAllowedToReply = Boolean(object.isAllowedToReply);
                    return message;
                };

                /**
                 * Creates a plain object from a StoryMessageRecipient message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {signalservice.SyncMessage.Sent.StoryMessageRecipient} message StoryMessageRecipient
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StoryMessageRecipient.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.distributionListIds = [];
                    if (options.defaults) {
                        object.destinationServiceId = "";
                        object.isAllowedToReply = false;
                    }
                    if (message.destinationServiceId != null && message.hasOwnProperty("destinationServiceId"))
                        object.destinationServiceId = message.destinationServiceId;
                    if (message.distributionListIds && message.distributionListIds.length) {
                        object.distributionListIds = [];
                        for (let j = 0; j < message.distributionListIds.length; ++j)
                            object.distributionListIds[j] = message.distributionListIds[j];
                    }
                    if (message.isAllowedToReply != null && message.hasOwnProperty("isAllowedToReply"))
                        object.isAllowedToReply = message.isAllowedToReply;
                    return object;
                };

                /**
                 * Converts this StoryMessageRecipient to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StoryMessageRecipient.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StoryMessageRecipient
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.Sent.StoryMessageRecipient
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StoryMessageRecipient.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.Sent.StoryMessageRecipient";
                };

                return StoryMessageRecipient;
            })();

            return Sent;
        })();

        SyncMessage.Contacts = (function() {

            /**
             * Properties of a Contacts.
             * @memberof signalservice.SyncMessage
             * @interface IContacts
             * @property {signalservice.IAttachmentPointer|null} [blob] Contacts blob
             * @property {boolean|null} [complete] Contacts complete
             */

            /**
             * Constructs a new Contacts.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Contacts.
             * @implements IContacts
             * @constructor
             * @param {signalservice.SyncMessage.IContacts=} [properties] Properties to set
             */
            function Contacts(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contacts blob.
             * @member {signalservice.IAttachmentPointer|null|undefined} blob
             * @memberof signalservice.SyncMessage.Contacts
             * @instance
             */
            Contacts.prototype.blob = null;

            /**
             * Contacts complete.
             * @member {boolean} complete
             * @memberof signalservice.SyncMessage.Contacts
             * @instance
             */
            Contacts.prototype.complete = false;

            /**
             * Creates a new Contacts instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.IContacts=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Contacts} Contacts instance
             */
            Contacts.create = function create(properties) {
                return new Contacts(properties);
            };

            /**
             * Encodes the specified Contacts message. Does not implicitly {@link signalservice.SyncMessage.Contacts.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.IContacts} message Contacts message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contacts.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                    $root.signalservice.AttachmentPointer.encode(message.blob, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.complete != null && Object.hasOwnProperty.call(message, "complete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.complete);
                return writer;
            };

            /**
             * Encodes the specified Contacts message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Contacts.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.IContacts} message Contacts message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contacts.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contacts message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Contacts} Contacts
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contacts.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Contacts();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.blob = $root.signalservice.AttachmentPointer.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.complete = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contacts message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Contacts} Contacts
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contacts.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contacts message.
             * @function verify
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contacts.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blob != null && message.hasOwnProperty("blob")) {
                    let error = $root.signalservice.AttachmentPointer.verify(message.blob);
                    if (error)
                        return "blob." + error;
                }
                if (message.complete != null && message.hasOwnProperty("complete"))
                    if (typeof message.complete !== "boolean")
                        return "complete: boolean expected";
                return null;
            };

            /**
             * Creates a Contacts message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Contacts} Contacts
             */
            Contacts.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Contacts)
                    return object;
                let message = new $root.signalservice.SyncMessage.Contacts();
                if (object.blob != null) {
                    if (typeof object.blob !== "object")
                        throw TypeError(".signalservice.SyncMessage.Contacts.blob: object expected");
                    message.blob = $root.signalservice.AttachmentPointer.fromObject(object.blob);
                }
                if (object.complete != null)
                    message.complete = Boolean(object.complete);
                return message;
            };

            /**
             * Creates a plain object from a Contacts message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {signalservice.SyncMessage.Contacts} message Contacts
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contacts.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.blob = null;
                    object.complete = false;
                }
                if (message.blob != null && message.hasOwnProperty("blob"))
                    object.blob = $root.signalservice.AttachmentPointer.toObject(message.blob, options);
                if (message.complete != null && message.hasOwnProperty("complete"))
                    object.complete = message.complete;
                return object;
            };

            /**
             * Converts this Contacts to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Contacts
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contacts.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Contacts
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Contacts
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Contacts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Contacts";
            };

            return Contacts;
        })();

        SyncMessage.Blocked = (function() {

            /**
             * Properties of a Blocked.
             * @memberof signalservice.SyncMessage
             * @interface IBlocked
             * @property {Array.<string>|null} [numbers] Blocked numbers
             * @property {Array.<string>|null} [acis] Blocked acis
             * @property {Array.<Uint8Array>|null} [groupIds] Blocked groupIds
             */

            /**
             * Constructs a new Blocked.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Blocked.
             * @implements IBlocked
             * @constructor
             * @param {signalservice.SyncMessage.IBlocked=} [properties] Properties to set
             */
            function Blocked(properties) {
                this.numbers = [];
                this.acis = [];
                this.groupIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Blocked numbers.
             * @member {Array.<string>} numbers
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             */
            Blocked.prototype.numbers = $util.emptyArray;

            /**
             * Blocked acis.
             * @member {Array.<string>} acis
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             */
            Blocked.prototype.acis = $util.emptyArray;

            /**
             * Blocked groupIds.
             * @member {Array.<Uint8Array>} groupIds
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             */
            Blocked.prototype.groupIds = $util.emptyArray;

            /**
             * Creates a new Blocked instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.IBlocked=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Blocked} Blocked instance
             */
            Blocked.create = function create(properties) {
                return new Blocked(properties);
            };

            /**
             * Encodes the specified Blocked message. Does not implicitly {@link signalservice.SyncMessage.Blocked.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.IBlocked} message Blocked message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Blocked.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.numbers != null && message.numbers.length)
                    for (let i = 0; i < message.numbers.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.numbers[i]);
                if (message.groupIds != null && message.groupIds.length)
                    for (let i = 0; i < message.groupIds.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.groupIds[i]);
                if (message.acis != null && message.acis.length)
                    for (let i = 0; i < message.acis.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.acis[i]);
                return writer;
            };

            /**
             * Encodes the specified Blocked message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Blocked.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.IBlocked} message Blocked message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Blocked.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Blocked message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Blocked} Blocked
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Blocked.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Blocked();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.numbers && message.numbers.length))
                                message.numbers = [];
                            message.numbers.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.acis && message.acis.length))
                                message.acis = [];
                            message.acis.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.groupIds && message.groupIds.length))
                                message.groupIds = [];
                            message.groupIds.push(reader.bytes());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Blocked message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Blocked} Blocked
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Blocked.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Blocked message.
             * @function verify
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Blocked.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.numbers != null && message.hasOwnProperty("numbers")) {
                    if (!Array.isArray(message.numbers))
                        return "numbers: array expected";
                    for (let i = 0; i < message.numbers.length; ++i)
                        if (!$util.isString(message.numbers[i]))
                            return "numbers: string[] expected";
                }
                if (message.acis != null && message.hasOwnProperty("acis")) {
                    if (!Array.isArray(message.acis))
                        return "acis: array expected";
                    for (let i = 0; i < message.acis.length; ++i)
                        if (!$util.isString(message.acis[i]))
                            return "acis: string[] expected";
                }
                if (message.groupIds != null && message.hasOwnProperty("groupIds")) {
                    if (!Array.isArray(message.groupIds))
                        return "groupIds: array expected";
                    for (let i = 0; i < message.groupIds.length; ++i)
                        if (!(message.groupIds[i] && typeof message.groupIds[i].length === "number" || $util.isString(message.groupIds[i])))
                            return "groupIds: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a Blocked message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Blocked} Blocked
             */
            Blocked.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Blocked)
                    return object;
                let message = new $root.signalservice.SyncMessage.Blocked();
                if (object.numbers) {
                    if (!Array.isArray(object.numbers))
                        throw TypeError(".signalservice.SyncMessage.Blocked.numbers: array expected");
                    message.numbers = [];
                    for (let i = 0; i < object.numbers.length; ++i)
                        message.numbers[i] = String(object.numbers[i]);
                }
                if (object.acis) {
                    if (!Array.isArray(object.acis))
                        throw TypeError(".signalservice.SyncMessage.Blocked.acis: array expected");
                    message.acis = [];
                    for (let i = 0; i < object.acis.length; ++i)
                        message.acis[i] = String(object.acis[i]);
                }
                if (object.groupIds) {
                    if (!Array.isArray(object.groupIds))
                        throw TypeError(".signalservice.SyncMessage.Blocked.groupIds: array expected");
                    message.groupIds = [];
                    for (let i = 0; i < object.groupIds.length; ++i)
                        if (typeof object.groupIds[i] === "string")
                            $util.base64.decode(object.groupIds[i], message.groupIds[i] = $util.newBuffer($util.base64.length(object.groupIds[i])), 0);
                        else if (object.groupIds[i].length >= 0)
                            message.groupIds[i] = object.groupIds[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a Blocked message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {signalservice.SyncMessage.Blocked} message Blocked
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Blocked.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.numbers = [];
                    object.groupIds = [];
                    object.acis = [];
                }
                if (message.numbers && message.numbers.length) {
                    object.numbers = [];
                    for (let j = 0; j < message.numbers.length; ++j)
                        object.numbers[j] = message.numbers[j];
                }
                if (message.groupIds && message.groupIds.length) {
                    object.groupIds = [];
                    for (let j = 0; j < message.groupIds.length; ++j)
                        object.groupIds[j] = options.bytes === String ? $util.base64.encode(message.groupIds[j], 0, message.groupIds[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.groupIds[j]) : message.groupIds[j];
                }
                if (message.acis && message.acis.length) {
                    object.acis = [];
                    for (let j = 0; j < message.acis.length; ++j)
                        object.acis[j] = message.acis[j];
                }
                return object;
            };

            /**
             * Converts this Blocked to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Blocked
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Blocked.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Blocked
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Blocked
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Blocked.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Blocked";
            };

            return Blocked;
        })();

        SyncMessage.Request = (function() {

            /**
             * Properties of a Request.
             * @memberof signalservice.SyncMessage
             * @interface IRequest
             * @property {signalservice.SyncMessage.Request.Type|null} [type] Request type
             */

            /**
             * Constructs a new Request.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Request.
             * @implements IRequest
             * @constructor
             * @param {signalservice.SyncMessage.IRequest=} [properties] Properties to set
             */
            function Request(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Request type.
             * @member {signalservice.SyncMessage.Request.Type} type
             * @memberof signalservice.SyncMessage.Request
             * @instance
             */
            Request.prototype.type = 0;

            /**
             * Creates a new Request instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.IRequest=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Request} Request instance
             */
            Request.create = function create(properties) {
                return new Request(properties);
            };

            /**
             * Encodes the specified Request message. Does not implicitly {@link signalservice.SyncMessage.Request.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Request message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Request();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Request message.
             * @function verify
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Request)
                    return object;
                let message = new $root.signalservice.SyncMessage.Request();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "CONTACTS":
                case 1:
                    message.type = 1;
                    break;
                case "BLOCKED":
                case 3:
                    message.type = 3;
                    break;
                case "CONFIGURATION":
                case 4:
                    message.type = 4;
                    break;
                case "KEYS":
                case 5:
                    message.type = 5;
                    break;
                case "PNI_IDENTITY":
                case 6:
                    message.type = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {signalservice.SyncMessage.Request} message Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.Request.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.Request.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Request to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Request
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Request
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Request";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.Request.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CONTACTS=1 CONTACTS value
             * @property {number} BLOCKED=3 BLOCKED value
             * @property {number} CONFIGURATION=4 CONFIGURATION value
             * @property {number} KEYS=5 KEYS value
             * @property {number} PNI_IDENTITY=6 PNI_IDENTITY value
             */
            Request.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CONTACTS"] = 1;
                values[valuesById[3] = "BLOCKED"] = 3;
                values[valuesById[4] = "CONFIGURATION"] = 4;
                values[valuesById[5] = "KEYS"] = 5;
                values[valuesById[6] = "PNI_IDENTITY"] = 6;
                return values;
            })();

            return Request;
        })();

        SyncMessage.Keys = (function() {

            /**
             * Properties of a Keys.
             * @memberof signalservice.SyncMessage
             * @interface IKeys
             * @property {Uint8Array|null} [storageService] Keys storageService
             * @property {Uint8Array|null} [master] Keys master
             */

            /**
             * Constructs a new Keys.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Keys.
             * @implements IKeys
             * @constructor
             * @param {signalservice.SyncMessage.IKeys=} [properties] Properties to set
             */
            function Keys(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Keys storageService.
             * @member {Uint8Array} storageService
             * @memberof signalservice.SyncMessage.Keys
             * @instance
             */
            Keys.prototype.storageService = $util.newBuffer([]);

            /**
             * Keys master.
             * @member {Uint8Array} master
             * @memberof signalservice.SyncMessage.Keys
             * @instance
             */
            Keys.prototype.master = $util.newBuffer([]);

            /**
             * Creates a new Keys instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.IKeys=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Keys} Keys instance
             */
            Keys.create = function create(properties) {
                return new Keys(properties);
            };

            /**
             * Encodes the specified Keys message. Does not implicitly {@link signalservice.SyncMessage.Keys.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.storageService != null && Object.hasOwnProperty.call(message, "storageService"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.storageService);
                if (message.master != null && Object.hasOwnProperty.call(message, "master"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.master);
                return writer;
            };

            /**
             * Encodes the specified Keys message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Keys.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Keys message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Keys();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.storageService = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.master = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Keys message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Keys message.
             * @function verify
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Keys.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.storageService != null && message.hasOwnProperty("storageService"))
                    if (!(message.storageService && typeof message.storageService.length === "number" || $util.isString(message.storageService)))
                        return "storageService: buffer expected";
                if (message.master != null && message.hasOwnProperty("master"))
                    if (!(message.master && typeof message.master.length === "number" || $util.isString(message.master)))
                        return "master: buffer expected";
                return null;
            };

            /**
             * Creates a Keys message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Keys} Keys
             */
            Keys.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Keys)
                    return object;
                let message = new $root.signalservice.SyncMessage.Keys();
                if (object.storageService != null)
                    if (typeof object.storageService === "string")
                        $util.base64.decode(object.storageService, message.storageService = $util.newBuffer($util.base64.length(object.storageService)), 0);
                    else if (object.storageService.length >= 0)
                        message.storageService = object.storageService;
                if (object.master != null)
                    if (typeof object.master === "string")
                        $util.base64.decode(object.master, message.master = $util.newBuffer($util.base64.length(object.master)), 0);
                    else if (object.master.length >= 0)
                        message.master = object.master;
                return message;
            };

            /**
             * Creates a plain object from a Keys message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {signalservice.SyncMessage.Keys} message Keys
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Keys.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.storageService = "";
                    else {
                        object.storageService = [];
                        if (options.bytes !== Array)
                            object.storageService = $util.newBuffer(object.storageService);
                    }
                    if (options.bytes === String)
                        object.master = "";
                    else {
                        object.master = [];
                        if (options.bytes !== Array)
                            object.master = $util.newBuffer(object.master);
                    }
                }
                if (message.storageService != null && message.hasOwnProperty("storageService"))
                    object.storageService = options.bytes === String ? $util.base64.encode(message.storageService, 0, message.storageService.length) : options.bytes === Array ? Array.prototype.slice.call(message.storageService) : message.storageService;
                if (message.master != null && message.hasOwnProperty("master"))
                    object.master = options.bytes === String ? $util.base64.encode(message.master, 0, message.master.length) : options.bytes === Array ? Array.prototype.slice.call(message.master) : message.master;
                return object;
            };

            /**
             * Converts this Keys to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Keys
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Keys.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Keys
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Keys
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Keys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Keys";
            };

            return Keys;
        })();

        SyncMessage.Read = (function() {

            /**
             * Properties of a Read.
             * @memberof signalservice.SyncMessage
             * @interface IRead
             * @property {string|null} [sender] Read sender
             * @property {string|null} [senderAci] Read senderAci
             * @property {number|Long|null} [timestamp] Read timestamp
             */

            /**
             * Constructs a new Read.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Read.
             * @implements IRead
             * @constructor
             * @param {signalservice.SyncMessage.IRead=} [properties] Properties to set
             */
            function Read(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Read sender.
             * @member {string} sender
             * @memberof signalservice.SyncMessage.Read
             * @instance
             */
            Read.prototype.sender = "";

            /**
             * Read senderAci.
             * @member {string} senderAci
             * @memberof signalservice.SyncMessage.Read
             * @instance
             */
            Read.prototype.senderAci = "";

            /**
             * Read timestamp.
             * @member {number|Long} timestamp
             * @memberof signalservice.SyncMessage.Read
             * @instance
             */
            Read.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Read instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.IRead=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Read} Read instance
             */
            Read.create = function create(properties) {
                return new Read(properties);
            };

            /**
             * Encodes the specified Read message. Does not implicitly {@link signalservice.SyncMessage.Read.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.IRead} message Read message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Read.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.senderAci != null && Object.hasOwnProperty.call(message, "senderAci"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderAci);
                return writer;
            };

            /**
             * Encodes the specified Read message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Read.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.IRead} message Read message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Read.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Read message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Read} Read
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Read.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Read();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sender = reader.string();
                            break;
                        }
                    case 3: {
                            message.senderAci = reader.string();
                            break;
                        }
                    case 2: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Read message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Read} Read
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Read.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Read message.
             * @function verify
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Read.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                if (message.senderAci != null && message.hasOwnProperty("senderAci"))
                    if (!$util.isString(message.senderAci))
                        return "senderAci: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Read message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Read} Read
             */
            Read.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Read)
                    return object;
                let message = new $root.signalservice.SyncMessage.Read();
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.senderAci != null)
                    message.senderAci = String(object.senderAci);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Read message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {signalservice.SyncMessage.Read} message Read
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Read.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sender = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.senderAci = "";
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.senderAci != null && message.hasOwnProperty("senderAci"))
                    object.senderAci = message.senderAci;
                return object;
            };

            /**
             * Converts this Read to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Read
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Read.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Read
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Read
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Read.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Read";
            };

            return Read;
        })();

        SyncMessage.Viewed = (function() {

            /**
             * Properties of a Viewed.
             * @memberof signalservice.SyncMessage
             * @interface IViewed
             * @property {string|null} [senderE164] Viewed senderE164
             * @property {string|null} [senderAci] Viewed senderAci
             * @property {number|Long|null} [timestamp] Viewed timestamp
             */

            /**
             * Constructs a new Viewed.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Viewed.
             * @implements IViewed
             * @constructor
             * @param {signalservice.SyncMessage.IViewed=} [properties] Properties to set
             */
            function Viewed(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Viewed senderE164.
             * @member {string} senderE164
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             */
            Viewed.prototype.senderE164 = "";

            /**
             * Viewed senderAci.
             * @member {string} senderAci
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             */
            Viewed.prototype.senderAci = "";

            /**
             * Viewed timestamp.
             * @member {number|Long} timestamp
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             */
            Viewed.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Viewed instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.IViewed=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Viewed} Viewed instance
             */
            Viewed.create = function create(properties) {
                return new Viewed(properties);
            };

            /**
             * Encodes the specified Viewed message. Does not implicitly {@link signalservice.SyncMessage.Viewed.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.IViewed} message Viewed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Viewed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.senderE164 != null && Object.hasOwnProperty.call(message, "senderE164"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderE164);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.senderAci != null && Object.hasOwnProperty.call(message, "senderAci"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderAci);
                return writer;
            };

            /**
             * Encodes the specified Viewed message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Viewed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.IViewed} message Viewed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Viewed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Viewed message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Viewed} Viewed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Viewed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Viewed();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.senderE164 = reader.string();
                            break;
                        }
                    case 3: {
                            message.senderAci = reader.string();
                            break;
                        }
                    case 2: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Viewed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Viewed} Viewed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Viewed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Viewed message.
             * @function verify
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Viewed.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.senderE164 != null && message.hasOwnProperty("senderE164"))
                    if (!$util.isString(message.senderE164))
                        return "senderE164: string expected";
                if (message.senderAci != null && message.hasOwnProperty("senderAci"))
                    if (!$util.isString(message.senderAci))
                        return "senderAci: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Viewed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Viewed} Viewed
             */
            Viewed.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Viewed)
                    return object;
                let message = new $root.signalservice.SyncMessage.Viewed();
                if (object.senderE164 != null)
                    message.senderE164 = String(object.senderE164);
                if (object.senderAci != null)
                    message.senderAci = String(object.senderAci);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Viewed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {signalservice.SyncMessage.Viewed} message Viewed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Viewed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.senderE164 = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.senderAci = "";
                }
                if (message.senderE164 != null && message.hasOwnProperty("senderE164"))
                    object.senderE164 = message.senderE164;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.senderAci != null && message.hasOwnProperty("senderAci"))
                    object.senderAci = message.senderAci;
                return object;
            };

            /**
             * Converts this Viewed to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Viewed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Viewed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Viewed
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Viewed
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Viewed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Viewed";
            };

            return Viewed;
        })();

        SyncMessage.Configuration = (function() {

            /**
             * Properties of a Configuration.
             * @memberof signalservice.SyncMessage
             * @interface IConfiguration
             * @property {boolean|null} [readReceipts] Configuration readReceipts
             * @property {boolean|null} [unidentifiedDeliveryIndicators] Configuration unidentifiedDeliveryIndicators
             * @property {boolean|null} [typingIndicators] Configuration typingIndicators
             * @property {number|null} [provisioningVersion] Configuration provisioningVersion
             * @property {boolean|null} [linkPreviews] Configuration linkPreviews
             */

            /**
             * Constructs a new Configuration.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a Configuration.
             * @implements IConfiguration
             * @constructor
             * @param {signalservice.SyncMessage.IConfiguration=} [properties] Properties to set
             */
            function Configuration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Configuration readReceipts.
             * @member {boolean} readReceipts
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.readReceipts = false;

            /**
             * Configuration unidentifiedDeliveryIndicators.
             * @member {boolean} unidentifiedDeliveryIndicators
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.unidentifiedDeliveryIndicators = false;

            /**
             * Configuration typingIndicators.
             * @member {boolean} typingIndicators
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.typingIndicators = false;

            /**
             * Configuration provisioningVersion.
             * @member {number} provisioningVersion
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.provisioningVersion = 0;

            /**
             * Configuration linkPreviews.
             * @member {boolean} linkPreviews
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             */
            Configuration.prototype.linkPreviews = false;

            /**
             * Creates a new Configuration instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.IConfiguration=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.Configuration} Configuration instance
             */
            Configuration.create = function create(properties) {
                return new Configuration(properties);
            };

            /**
             * Encodes the specified Configuration message. Does not implicitly {@link signalservice.SyncMessage.Configuration.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.IConfiguration} message Configuration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Configuration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.readReceipts != null && Object.hasOwnProperty.call(message, "readReceipts"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.readReceipts);
                if (message.unidentifiedDeliveryIndicators != null && Object.hasOwnProperty.call(message, "unidentifiedDeliveryIndicators"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.unidentifiedDeliveryIndicators);
                if (message.typingIndicators != null && Object.hasOwnProperty.call(message, "typingIndicators"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.typingIndicators);
                if (message.provisioningVersion != null && Object.hasOwnProperty.call(message, "provisioningVersion"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.provisioningVersion);
                if (message.linkPreviews != null && Object.hasOwnProperty.call(message, "linkPreviews"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.linkPreviews);
                return writer;
            };

            /**
             * Encodes the specified Configuration message, length delimited. Does not implicitly {@link signalservice.SyncMessage.Configuration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.IConfiguration} message Configuration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Configuration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Configuration message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.Configuration} Configuration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Configuration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.Configuration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.readReceipts = reader.bool();
                            break;
                        }
                    case 2: {
                            message.unidentifiedDeliveryIndicators = reader.bool();
                            break;
                        }
                    case 3: {
                            message.typingIndicators = reader.bool();
                            break;
                        }
                    case 5: {
                            message.provisioningVersion = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.linkPreviews = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Configuration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.Configuration} Configuration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Configuration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Configuration message.
             * @function verify
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Configuration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                    if (typeof message.readReceipts !== "boolean")
                        return "readReceipts: boolean expected";
                if (message.unidentifiedDeliveryIndicators != null && message.hasOwnProperty("unidentifiedDeliveryIndicators"))
                    if (typeof message.unidentifiedDeliveryIndicators !== "boolean")
                        return "unidentifiedDeliveryIndicators: boolean expected";
                if (message.typingIndicators != null && message.hasOwnProperty("typingIndicators"))
                    if (typeof message.typingIndicators !== "boolean")
                        return "typingIndicators: boolean expected";
                if (message.provisioningVersion != null && message.hasOwnProperty("provisioningVersion"))
                    if (!$util.isInteger(message.provisioningVersion))
                        return "provisioningVersion: integer expected";
                if (message.linkPreviews != null && message.hasOwnProperty("linkPreviews"))
                    if (typeof message.linkPreviews !== "boolean")
                        return "linkPreviews: boolean expected";
                return null;
            };

            /**
             * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.Configuration} Configuration
             */
            Configuration.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.Configuration)
                    return object;
                let message = new $root.signalservice.SyncMessage.Configuration();
                if (object.readReceipts != null)
                    message.readReceipts = Boolean(object.readReceipts);
                if (object.unidentifiedDeliveryIndicators != null)
                    message.unidentifiedDeliveryIndicators = Boolean(object.unidentifiedDeliveryIndicators);
                if (object.typingIndicators != null)
                    message.typingIndicators = Boolean(object.typingIndicators);
                if (object.provisioningVersion != null)
                    message.provisioningVersion = object.provisioningVersion >>> 0;
                if (object.linkPreviews != null)
                    message.linkPreviews = Boolean(object.linkPreviews);
                return message;
            };

            /**
             * Creates a plain object from a Configuration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {signalservice.SyncMessage.Configuration} message Configuration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Configuration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.readReceipts = false;
                    object.unidentifiedDeliveryIndicators = false;
                    object.typingIndicators = false;
                    object.provisioningVersion = 0;
                    object.linkPreviews = false;
                }
                if (message.readReceipts != null && message.hasOwnProperty("readReceipts"))
                    object.readReceipts = message.readReceipts;
                if (message.unidentifiedDeliveryIndicators != null && message.hasOwnProperty("unidentifiedDeliveryIndicators"))
                    object.unidentifiedDeliveryIndicators = message.unidentifiedDeliveryIndicators;
                if (message.typingIndicators != null && message.hasOwnProperty("typingIndicators"))
                    object.typingIndicators = message.typingIndicators;
                if (message.provisioningVersion != null && message.hasOwnProperty("provisioningVersion"))
                    object.provisioningVersion = message.provisioningVersion;
                if (message.linkPreviews != null && message.hasOwnProperty("linkPreviews"))
                    object.linkPreviews = message.linkPreviews;
                return object;
            };

            /**
             * Converts this Configuration to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.Configuration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Configuration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Configuration
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.Configuration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Configuration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.Configuration";
            };

            return Configuration;
        })();

        SyncMessage.StickerPackOperation = (function() {

            /**
             * Properties of a StickerPackOperation.
             * @memberof signalservice.SyncMessage
             * @interface IStickerPackOperation
             * @property {Uint8Array|null} [packId] StickerPackOperation packId
             * @property {Uint8Array|null} [packKey] StickerPackOperation packKey
             * @property {signalservice.SyncMessage.StickerPackOperation.Type|null} [type] StickerPackOperation type
             */

            /**
             * Constructs a new StickerPackOperation.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a StickerPackOperation.
             * @implements IStickerPackOperation
             * @constructor
             * @param {signalservice.SyncMessage.IStickerPackOperation=} [properties] Properties to set
             */
            function StickerPackOperation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StickerPackOperation packId.
             * @member {Uint8Array} packId
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             */
            StickerPackOperation.prototype.packId = $util.newBuffer([]);

            /**
             * StickerPackOperation packKey.
             * @member {Uint8Array} packKey
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             */
            StickerPackOperation.prototype.packKey = $util.newBuffer([]);

            /**
             * StickerPackOperation type.
             * @member {signalservice.SyncMessage.StickerPackOperation.Type} type
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             */
            StickerPackOperation.prototype.type = 0;

            /**
             * Creates a new StickerPackOperation instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.IStickerPackOperation=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation instance
             */
            StickerPackOperation.create = function create(properties) {
                return new StickerPackOperation(properties);
            };

            /**
             * Encodes the specified StickerPackOperation message. Does not implicitly {@link signalservice.SyncMessage.StickerPackOperation.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.IStickerPackOperation} message StickerPackOperation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerPackOperation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packId != null && Object.hasOwnProperty.call(message, "packId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.packId);
                if (message.packKey != null && Object.hasOwnProperty.call(message, "packKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packKey);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified StickerPackOperation message, length delimited. Does not implicitly {@link signalservice.SyncMessage.StickerPackOperation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.IStickerPackOperation} message StickerPackOperation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerPackOperation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StickerPackOperation message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerPackOperation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.StickerPackOperation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.packId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.packKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StickerPackOperation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerPackOperation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StickerPackOperation message.
             * @function verify
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StickerPackOperation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packId != null && message.hasOwnProperty("packId"))
                    if (!(message.packId && typeof message.packId.length === "number" || $util.isString(message.packId)))
                        return "packId: buffer expected";
                if (message.packKey != null && message.hasOwnProperty("packKey"))
                    if (!(message.packKey && typeof message.packKey.length === "number" || $util.isString(message.packKey)))
                        return "packKey: buffer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a StickerPackOperation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.StickerPackOperation} StickerPackOperation
             */
            StickerPackOperation.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.StickerPackOperation)
                    return object;
                let message = new $root.signalservice.SyncMessage.StickerPackOperation();
                if (object.packId != null)
                    if (typeof object.packId === "string")
                        $util.base64.decode(object.packId, message.packId = $util.newBuffer($util.base64.length(object.packId)), 0);
                    else if (object.packId.length >= 0)
                        message.packId = object.packId;
                if (object.packKey != null)
                    if (typeof object.packKey === "string")
                        $util.base64.decode(object.packKey, message.packKey = $util.newBuffer($util.base64.length(object.packKey)), 0);
                    else if (object.packKey.length >= 0)
                        message.packKey = object.packKey;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "INSTALL":
                case 0:
                    message.type = 0;
                    break;
                case "REMOVE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a StickerPackOperation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {signalservice.SyncMessage.StickerPackOperation} message StickerPackOperation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StickerPackOperation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.packId = "";
                    else {
                        object.packId = [];
                        if (options.bytes !== Array)
                            object.packId = $util.newBuffer(object.packId);
                    }
                    if (options.bytes === String)
                        object.packKey = "";
                    else {
                        object.packKey = [];
                        if (options.bytes !== Array)
                            object.packKey = $util.newBuffer(object.packKey);
                    }
                    object.type = options.enums === String ? "INSTALL" : 0;
                }
                if (message.packId != null && message.hasOwnProperty("packId"))
                    object.packId = options.bytes === String ? $util.base64.encode(message.packId, 0, message.packId.length) : options.bytes === Array ? Array.prototype.slice.call(message.packId) : message.packId;
                if (message.packKey != null && message.hasOwnProperty("packKey"))
                    object.packKey = options.bytes === String ? $util.base64.encode(message.packKey, 0, message.packKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.packKey) : message.packKey;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.StickerPackOperation.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.StickerPackOperation.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this StickerPackOperation to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StickerPackOperation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StickerPackOperation
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.StickerPackOperation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StickerPackOperation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.StickerPackOperation";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.StickerPackOperation.Type
             * @enum {number}
             * @property {number} INSTALL=0 INSTALL value
             * @property {number} REMOVE=1 REMOVE value
             */
            StickerPackOperation.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INSTALL"] = 0;
                values[valuesById[1] = "REMOVE"] = 1;
                return values;
            })();

            return StickerPackOperation;
        })();

        SyncMessage.ViewOnceOpen = (function() {

            /**
             * Properties of a ViewOnceOpen.
             * @memberof signalservice.SyncMessage
             * @interface IViewOnceOpen
             * @property {string|null} [sender] ViewOnceOpen sender
             * @property {string|null} [senderAci] ViewOnceOpen senderAci
             * @property {number|Long|null} [timestamp] ViewOnceOpen timestamp
             */

            /**
             * Constructs a new ViewOnceOpen.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a ViewOnceOpen.
             * @implements IViewOnceOpen
             * @constructor
             * @param {signalservice.SyncMessage.IViewOnceOpen=} [properties] Properties to set
             */
            function ViewOnceOpen(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ViewOnceOpen sender.
             * @member {string} sender
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             */
            ViewOnceOpen.prototype.sender = "";

            /**
             * ViewOnceOpen senderAci.
             * @member {string} senderAci
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             */
            ViewOnceOpen.prototype.senderAci = "";

            /**
             * ViewOnceOpen timestamp.
             * @member {number|Long} timestamp
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             */
            ViewOnceOpen.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ViewOnceOpen instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.IViewOnceOpen=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen instance
             */
            ViewOnceOpen.create = function create(properties) {
                return new ViewOnceOpen(properties);
            };

            /**
             * Encodes the specified ViewOnceOpen message. Does not implicitly {@link signalservice.SyncMessage.ViewOnceOpen.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.IViewOnceOpen} message ViewOnceOpen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ViewOnceOpen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.senderAci != null && Object.hasOwnProperty.call(message, "senderAci"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderAci);
                return writer;
            };

            /**
             * Encodes the specified ViewOnceOpen message, length delimited. Does not implicitly {@link signalservice.SyncMessage.ViewOnceOpen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.IViewOnceOpen} message ViewOnceOpen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ViewOnceOpen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ViewOnceOpen message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ViewOnceOpen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.ViewOnceOpen();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sender = reader.string();
                            break;
                        }
                    case 3: {
                            message.senderAci = reader.string();
                            break;
                        }
                    case 2: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ViewOnceOpen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ViewOnceOpen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ViewOnceOpen message.
             * @function verify
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ViewOnceOpen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                if (message.senderAci != null && message.hasOwnProperty("senderAci"))
                    if (!$util.isString(message.senderAci))
                        return "senderAci: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a ViewOnceOpen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.ViewOnceOpen} ViewOnceOpen
             */
            ViewOnceOpen.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.ViewOnceOpen)
                    return object;
                let message = new $root.signalservice.SyncMessage.ViewOnceOpen();
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.senderAci != null)
                    message.senderAci = String(object.senderAci);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ViewOnceOpen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {signalservice.SyncMessage.ViewOnceOpen} message ViewOnceOpen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ViewOnceOpen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sender = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.senderAci = "";
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.senderAci != null && message.hasOwnProperty("senderAci"))
                    object.senderAci = message.senderAci;
                return object;
            };

            /**
             * Converts this ViewOnceOpen to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ViewOnceOpen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ViewOnceOpen
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.ViewOnceOpen
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ViewOnceOpen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.ViewOnceOpen";
            };

            return ViewOnceOpen;
        })();

        SyncMessage.MessageRequestResponse = (function() {

            /**
             * Properties of a MessageRequestResponse.
             * @memberof signalservice.SyncMessage
             * @interface IMessageRequestResponse
             * @property {string|null} [threadE164] MessageRequestResponse threadE164
             * @property {string|null} [threadAci] MessageRequestResponse threadAci
             * @property {Uint8Array|null} [groupId] MessageRequestResponse groupId
             * @property {signalservice.SyncMessage.MessageRequestResponse.Type|null} [type] MessageRequestResponse type
             */

            /**
             * Constructs a new MessageRequestResponse.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a MessageRequestResponse.
             * @implements IMessageRequestResponse
             * @constructor
             * @param {signalservice.SyncMessage.IMessageRequestResponse=} [properties] Properties to set
             */
            function MessageRequestResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageRequestResponse threadE164.
             * @member {string} threadE164
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.threadE164 = "";

            /**
             * MessageRequestResponse threadAci.
             * @member {string} threadAci
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.threadAci = "";

            /**
             * MessageRequestResponse groupId.
             * @member {Uint8Array} groupId
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.groupId = $util.newBuffer([]);

            /**
             * MessageRequestResponse type.
             * @member {signalservice.SyncMessage.MessageRequestResponse.Type} type
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             */
            MessageRequestResponse.prototype.type = 0;

            /**
             * Creates a new MessageRequestResponse instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.IMessageRequestResponse=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse instance
             */
            MessageRequestResponse.create = function create(properties) {
                return new MessageRequestResponse(properties);
            };

            /**
             * Encodes the specified MessageRequestResponse message. Does not implicitly {@link signalservice.SyncMessage.MessageRequestResponse.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.IMessageRequestResponse} message MessageRequestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageRequestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadE164 != null && Object.hasOwnProperty.call(message, "threadE164"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.threadE164);
                if (message.threadAci != null && Object.hasOwnProperty.call(message, "threadAci"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadAci);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified MessageRequestResponse message, length delimited. Does not implicitly {@link signalservice.SyncMessage.MessageRequestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.IMessageRequestResponse} message MessageRequestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageRequestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageRequestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageRequestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.MessageRequestResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadE164 = reader.string();
                            break;
                        }
                    case 2: {
                            message.threadAci = reader.string();
                            break;
                        }
                    case 3: {
                            message.groupId = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageRequestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageRequestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageRequestResponse message.
             * @function verify
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageRequestResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadE164 != null && message.hasOwnProperty("threadE164"))
                    if (!$util.isString(message.threadE164))
                        return "threadE164: string expected";
                if (message.threadAci != null && message.hasOwnProperty("threadAci"))
                    if (!$util.isString(message.threadAci))
                        return "threadAci: string expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!(message.groupId && typeof message.groupId.length === "number" || $util.isString(message.groupId)))
                        return "groupId: buffer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a MessageRequestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.MessageRequestResponse} MessageRequestResponse
             */
            MessageRequestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.MessageRequestResponse)
                    return object;
                let message = new $root.signalservice.SyncMessage.MessageRequestResponse();
                if (object.threadE164 != null)
                    message.threadE164 = String(object.threadE164);
                if (object.threadAci != null)
                    message.threadAci = String(object.threadAci);
                if (object.groupId != null)
                    if (typeof object.groupId === "string")
                        $util.base64.decode(object.groupId, message.groupId = $util.newBuffer($util.base64.length(object.groupId)), 0);
                    else if (object.groupId.length >= 0)
                        message.groupId = object.groupId;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "ACCEPT":
                case 1:
                    message.type = 1;
                    break;
                case "DELETE":
                case 2:
                    message.type = 2;
                    break;
                case "BLOCK":
                case 3:
                    message.type = 3;
                    break;
                case "BLOCK_AND_DELETE":
                case 4:
                    message.type = 4;
                    break;
                case "SPAM":
                case 5:
                    message.type = 5;
                    break;
                case "BLOCK_AND_SPAM":
                case 6:
                    message.type = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageRequestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {signalservice.SyncMessage.MessageRequestResponse} message MessageRequestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageRequestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.threadE164 = "";
                    object.threadAci = "";
                    if (options.bytes === String)
                        object.groupId = "";
                    else {
                        object.groupId = [];
                        if (options.bytes !== Array)
                            object.groupId = $util.newBuffer(object.groupId);
                    }
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.threadE164 != null && message.hasOwnProperty("threadE164"))
                    object.threadE164 = message.threadE164;
                if (message.threadAci != null && message.hasOwnProperty("threadAci"))
                    object.threadAci = message.threadAci;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = options.bytes === String ? $util.base64.encode(message.groupId, 0, message.groupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupId) : message.groupId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.MessageRequestResponse.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.MessageRequestResponse.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this MessageRequestResponse to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageRequestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageRequestResponse
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.MessageRequestResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageRequestResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.MessageRequestResponse";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.MessageRequestResponse.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} ACCEPT=1 ACCEPT value
             * @property {number} DELETE=2 DELETE value
             * @property {number} BLOCK=3 BLOCK value
             * @property {number} BLOCK_AND_DELETE=4 BLOCK_AND_DELETE value
             * @property {number} SPAM=5 SPAM value
             * @property {number} BLOCK_AND_SPAM=6 BLOCK_AND_SPAM value
             */
            MessageRequestResponse.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "ACCEPT"] = 1;
                values[valuesById[2] = "DELETE"] = 2;
                values[valuesById[3] = "BLOCK"] = 3;
                values[valuesById[4] = "BLOCK_AND_DELETE"] = 4;
                values[valuesById[5] = "SPAM"] = 5;
                values[valuesById[6] = "BLOCK_AND_SPAM"] = 6;
                return values;
            })();

            return MessageRequestResponse;
        })();

        SyncMessage.FetchLatest = (function() {

            /**
             * Properties of a FetchLatest.
             * @memberof signalservice.SyncMessage
             * @interface IFetchLatest
             * @property {signalservice.SyncMessage.FetchLatest.Type|null} [type] FetchLatest type
             */

            /**
             * Constructs a new FetchLatest.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a FetchLatest.
             * @implements IFetchLatest
             * @constructor
             * @param {signalservice.SyncMessage.IFetchLatest=} [properties] Properties to set
             */
            function FetchLatest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FetchLatest type.
             * @member {signalservice.SyncMessage.FetchLatest.Type} type
             * @memberof signalservice.SyncMessage.FetchLatest
             * @instance
             */
            FetchLatest.prototype.type = 0;

            /**
             * Creates a new FetchLatest instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.IFetchLatest=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest instance
             */
            FetchLatest.create = function create(properties) {
                return new FetchLatest(properties);
            };

            /**
             * Encodes the specified FetchLatest message. Does not implicitly {@link signalservice.SyncMessage.FetchLatest.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.IFetchLatest} message FetchLatest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchLatest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified FetchLatest message, length delimited. Does not implicitly {@link signalservice.SyncMessage.FetchLatest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.IFetchLatest} message FetchLatest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FetchLatest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FetchLatest message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchLatest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.FetchLatest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FetchLatest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FetchLatest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FetchLatest message.
             * @function verify
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FetchLatest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FetchLatest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.FetchLatest} FetchLatest
             */
            FetchLatest.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.FetchLatest)
                    return object;
                let message = new $root.signalservice.SyncMessage.FetchLatest();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "LOCAL_PROFILE":
                case 1:
                    message.type = 1;
                    break;
                case "STORAGE_MANIFEST":
                case 2:
                    message.type = 2;
                    break;
                case "SUBSCRIPTION_STATUS":
                case 3:
                    message.type = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FetchLatest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {signalservice.SyncMessage.FetchLatest} message FetchLatest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FetchLatest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.FetchLatest.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.FetchLatest.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this FetchLatest to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.FetchLatest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FetchLatest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FetchLatest
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.FetchLatest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FetchLatest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.FetchLatest";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.FetchLatest.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} LOCAL_PROFILE=1 LOCAL_PROFILE value
             * @property {number} STORAGE_MANIFEST=2 STORAGE_MANIFEST value
             * @property {number} SUBSCRIPTION_STATUS=3 SUBSCRIPTION_STATUS value
             */
            FetchLatest.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "LOCAL_PROFILE"] = 1;
                values[valuesById[2] = "STORAGE_MANIFEST"] = 2;
                values[valuesById[3] = "SUBSCRIPTION_STATUS"] = 3;
                return values;
            })();

            return FetchLatest;
        })();

        SyncMessage.PniChangeNumber = (function() {

            /**
             * Properties of a PniChangeNumber.
             * @memberof signalservice.SyncMessage
             * @interface IPniChangeNumber
             * @property {Uint8Array|null} [identityKeyPair] PniChangeNumber identityKeyPair
             * @property {Uint8Array|null} [signedPreKey] PniChangeNumber signedPreKey
             * @property {Uint8Array|null} [lastResortKyberPreKey] PniChangeNumber lastResortKyberPreKey
             * @property {number|null} [registrationId] PniChangeNumber registrationId
             * @property {string|null} [newE164] PniChangeNumber newE164
             */

            /**
             * Constructs a new PniChangeNumber.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a PniChangeNumber.
             * @implements IPniChangeNumber
             * @constructor
             * @param {signalservice.SyncMessage.IPniChangeNumber=} [properties] Properties to set
             */
            function PniChangeNumber(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PniChangeNumber identityKeyPair.
             * @member {Uint8Array} identityKeyPair
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.identityKeyPair = $util.newBuffer([]);

            /**
             * PniChangeNumber signedPreKey.
             * @member {Uint8Array} signedPreKey
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.signedPreKey = $util.newBuffer([]);

            /**
             * PniChangeNumber lastResortKyberPreKey.
             * @member {Uint8Array} lastResortKyberPreKey
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.lastResortKyberPreKey = $util.newBuffer([]);

            /**
             * PniChangeNumber registrationId.
             * @member {number} registrationId
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.registrationId = 0;

            /**
             * PniChangeNumber newE164.
             * @member {string} newE164
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             */
            PniChangeNumber.prototype.newE164 = "";

            /**
             * Creates a new PniChangeNumber instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.IPniChangeNumber=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber instance
             */
            PniChangeNumber.create = function create(properties) {
                return new PniChangeNumber(properties);
            };

            /**
             * Encodes the specified PniChangeNumber message. Does not implicitly {@link signalservice.SyncMessage.PniChangeNumber.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.IPniChangeNumber} message PniChangeNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PniChangeNumber.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.identityKeyPair != null && Object.hasOwnProperty.call(message, "identityKeyPair"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.identityKeyPair);
                if (message.signedPreKey != null && Object.hasOwnProperty.call(message, "signedPreKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signedPreKey);
                if (message.registrationId != null && Object.hasOwnProperty.call(message, "registrationId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.registrationId);
                if (message.newE164 != null && Object.hasOwnProperty.call(message, "newE164"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.newE164);
                if (message.lastResortKyberPreKey != null && Object.hasOwnProperty.call(message, "lastResortKyberPreKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.lastResortKyberPreKey);
                return writer;
            };

            /**
             * Encodes the specified PniChangeNumber message, length delimited. Does not implicitly {@link signalservice.SyncMessage.PniChangeNumber.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.IPniChangeNumber} message PniChangeNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PniChangeNumber.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PniChangeNumber message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PniChangeNumber.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.PniChangeNumber();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.identityKeyPair = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.signedPreKey = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.lastResortKyberPreKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.registrationId = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.newE164 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PniChangeNumber message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PniChangeNumber.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PniChangeNumber message.
             * @function verify
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PniChangeNumber.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.identityKeyPair != null && message.hasOwnProperty("identityKeyPair"))
                    if (!(message.identityKeyPair && typeof message.identityKeyPair.length === "number" || $util.isString(message.identityKeyPair)))
                        return "identityKeyPair: buffer expected";
                if (message.signedPreKey != null && message.hasOwnProperty("signedPreKey"))
                    if (!(message.signedPreKey && typeof message.signedPreKey.length === "number" || $util.isString(message.signedPreKey)))
                        return "signedPreKey: buffer expected";
                if (message.lastResortKyberPreKey != null && message.hasOwnProperty("lastResortKyberPreKey"))
                    if (!(message.lastResortKyberPreKey && typeof message.lastResortKyberPreKey.length === "number" || $util.isString(message.lastResortKyberPreKey)))
                        return "lastResortKyberPreKey: buffer expected";
                if (message.registrationId != null && message.hasOwnProperty("registrationId"))
                    if (!$util.isInteger(message.registrationId))
                        return "registrationId: integer expected";
                if (message.newE164 != null && message.hasOwnProperty("newE164"))
                    if (!$util.isString(message.newE164))
                        return "newE164: string expected";
                return null;
            };

            /**
             * Creates a PniChangeNumber message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.PniChangeNumber} PniChangeNumber
             */
            PniChangeNumber.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.PniChangeNumber)
                    return object;
                let message = new $root.signalservice.SyncMessage.PniChangeNumber();
                if (object.identityKeyPair != null)
                    if (typeof object.identityKeyPair === "string")
                        $util.base64.decode(object.identityKeyPair, message.identityKeyPair = $util.newBuffer($util.base64.length(object.identityKeyPair)), 0);
                    else if (object.identityKeyPair.length >= 0)
                        message.identityKeyPair = object.identityKeyPair;
                if (object.signedPreKey != null)
                    if (typeof object.signedPreKey === "string")
                        $util.base64.decode(object.signedPreKey, message.signedPreKey = $util.newBuffer($util.base64.length(object.signedPreKey)), 0);
                    else if (object.signedPreKey.length >= 0)
                        message.signedPreKey = object.signedPreKey;
                if (object.lastResortKyberPreKey != null)
                    if (typeof object.lastResortKyberPreKey === "string")
                        $util.base64.decode(object.lastResortKyberPreKey, message.lastResortKyberPreKey = $util.newBuffer($util.base64.length(object.lastResortKyberPreKey)), 0);
                    else if (object.lastResortKyberPreKey.length >= 0)
                        message.lastResortKyberPreKey = object.lastResortKyberPreKey;
                if (object.registrationId != null)
                    message.registrationId = object.registrationId >>> 0;
                if (object.newE164 != null)
                    message.newE164 = String(object.newE164);
                return message;
            };

            /**
             * Creates a plain object from a PniChangeNumber message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {signalservice.SyncMessage.PniChangeNumber} message PniChangeNumber
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PniChangeNumber.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.identityKeyPair = "";
                    else {
                        object.identityKeyPair = [];
                        if (options.bytes !== Array)
                            object.identityKeyPair = $util.newBuffer(object.identityKeyPair);
                    }
                    if (options.bytes === String)
                        object.signedPreKey = "";
                    else {
                        object.signedPreKey = [];
                        if (options.bytes !== Array)
                            object.signedPreKey = $util.newBuffer(object.signedPreKey);
                    }
                    object.registrationId = 0;
                    object.newE164 = "";
                    if (options.bytes === String)
                        object.lastResortKyberPreKey = "";
                    else {
                        object.lastResortKyberPreKey = [];
                        if (options.bytes !== Array)
                            object.lastResortKyberPreKey = $util.newBuffer(object.lastResortKyberPreKey);
                    }
                }
                if (message.identityKeyPair != null && message.hasOwnProperty("identityKeyPair"))
                    object.identityKeyPair = options.bytes === String ? $util.base64.encode(message.identityKeyPair, 0, message.identityKeyPair.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKeyPair) : message.identityKeyPair;
                if (message.signedPreKey != null && message.hasOwnProperty("signedPreKey"))
                    object.signedPreKey = options.bytes === String ? $util.base64.encode(message.signedPreKey, 0, message.signedPreKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedPreKey) : message.signedPreKey;
                if (message.registrationId != null && message.hasOwnProperty("registrationId"))
                    object.registrationId = message.registrationId;
                if (message.newE164 != null && message.hasOwnProperty("newE164"))
                    object.newE164 = message.newE164;
                if (message.lastResortKyberPreKey != null && message.hasOwnProperty("lastResortKyberPreKey"))
                    object.lastResortKyberPreKey = options.bytes === String ? $util.base64.encode(message.lastResortKyberPreKey, 0, message.lastResortKyberPreKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastResortKyberPreKey) : message.lastResortKyberPreKey;
                return object;
            };

            /**
             * Converts this PniChangeNumber to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PniChangeNumber.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PniChangeNumber
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.PniChangeNumber
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PniChangeNumber.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.PniChangeNumber";
            };

            return PniChangeNumber;
        })();

        SyncMessage.CallEvent = (function() {

            /**
             * Properties of a CallEvent.
             * @memberof signalservice.SyncMessage
             * @interface ICallEvent
             * @property {Uint8Array|null} [peerId] CallEvent peerId
             * @property {number|Long|null} [callId] CallEvent callId
             * @property {number|Long|null} [timestamp] CallEvent timestamp
             * @property {signalservice.SyncMessage.CallEvent.Type|null} [type] CallEvent type
             * @property {signalservice.SyncMessage.CallEvent.Direction|null} [direction] CallEvent direction
             * @property {signalservice.SyncMessage.CallEvent.Event|null} [event] CallEvent event
             */

            /**
             * Constructs a new CallEvent.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a CallEvent.
             * @implements ICallEvent
             * @constructor
             * @param {signalservice.SyncMessage.ICallEvent=} [properties] Properties to set
             */
            function CallEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CallEvent peerId.
             * @member {Uint8Array} peerId
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             */
            CallEvent.prototype.peerId = $util.newBuffer([]);

            /**
             * CallEvent callId.
             * @member {number|Long} callId
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             */
            CallEvent.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CallEvent timestamp.
             * @member {number|Long} timestamp
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             */
            CallEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CallEvent type.
             * @member {signalservice.SyncMessage.CallEvent.Type} type
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             */
            CallEvent.prototype.type = 0;

            /**
             * CallEvent direction.
             * @member {signalservice.SyncMessage.CallEvent.Direction} direction
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             */
            CallEvent.prototype.direction = 0;

            /**
             * CallEvent event.
             * @member {signalservice.SyncMessage.CallEvent.Event} event
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             */
            CallEvent.prototype.event = 0;

            /**
             * Creates a new CallEvent instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {signalservice.SyncMessage.ICallEvent=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.CallEvent} CallEvent instance
             */
            CallEvent.create = function create(properties) {
                return new CallEvent(properties);
            };

            /**
             * Encodes the specified CallEvent message. Does not implicitly {@link signalservice.SyncMessage.CallEvent.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {signalservice.SyncMessage.ICallEvent} message CallEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.peerId);
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.callId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.direction);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.event);
                return writer;
            };

            /**
             * Encodes the specified CallEvent message, length delimited. Does not implicitly {@link signalservice.SyncMessage.CallEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {signalservice.SyncMessage.ICallEvent} message CallEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CallEvent message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.CallEvent} CallEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.CallEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.peerId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.callId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.type = reader.int32();
                            break;
                        }
                    case 5: {
                            message.direction = reader.int32();
                            break;
                        }
                    case 6: {
                            message.event = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CallEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.CallEvent} CallEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CallEvent message.
             * @function verify
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CallEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerId != null && message.hasOwnProperty("peerId"))
                    if (!(message.peerId && typeof message.peerId.length === "number" || $util.isString(message.peerId)))
                        return "peerId: buffer expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.direction != null && message.hasOwnProperty("direction"))
                    switch (message.direction) {
                    default:
                        return "direction: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.event != null && message.hasOwnProperty("event"))
                    switch (message.event) {
                    default:
                        return "event: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CallEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.CallEvent} CallEvent
             */
            CallEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.CallEvent)
                    return object;
                let message = new $root.signalservice.SyncMessage.CallEvent();
                if (object.peerId != null)
                    if (typeof object.peerId === "string")
                        $util.base64.decode(object.peerId, message.peerId = $util.newBuffer($util.base64.length(object.peerId)), 0);
                    else if (object.peerId.length >= 0)
                        message.peerId = object.peerId;
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "AUDIO_CALL":
                case 1:
                    message.type = 1;
                    break;
                case "VIDEO_CALL":
                case 2:
                    message.type = 2;
                    break;
                case "GROUP_CALL":
                case 3:
                    message.type = 3;
                    break;
                case "AD_HOC_CALL":
                case 4:
                    message.type = 4;
                    break;
                }
                switch (object.direction) {
                default:
                    if (typeof object.direction === "number") {
                        message.direction = object.direction;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.direction = 0;
                    break;
                case "INCOMING":
                case 1:
                    message.direction = 1;
                    break;
                case "OUTGOING":
                case 2:
                    message.direction = 2;
                    break;
                }
                switch (object.event) {
                default:
                    if (typeof object.event === "number") {
                        message.event = object.event;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.event = 0;
                    break;
                case "ACCEPTED":
                case 1:
                    message.event = 1;
                    break;
                case "NOT_ACCEPTED":
                case 2:
                    message.event = 2;
                    break;
                case "DELETE":
                case 3:
                    message.event = 3;
                    break;
                case "OBSERVED":
                case 4:
                    message.event = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CallEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {signalservice.SyncMessage.CallEvent} message CallEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CallEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.peerId = "";
                    else {
                        object.peerId = [];
                        if (options.bytes !== Array)
                            object.peerId = $util.newBuffer(object.peerId);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.direction = options.enums === String ? "UNKNOWN" : 0;
                    object.event = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.peerId != null && message.hasOwnProperty("peerId"))
                    object.peerId = options.bytes === String ? $util.base64.encode(message.peerId, 0, message.peerId.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerId) : message.peerId;
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.CallEvent.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.CallEvent.Type[message.type] : message.type;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = options.enums === String ? $root.signalservice.SyncMessage.CallEvent.Direction[message.direction] === undefined ? message.direction : $root.signalservice.SyncMessage.CallEvent.Direction[message.direction] : message.direction;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = options.enums === String ? $root.signalservice.SyncMessage.CallEvent.Event[message.event] === undefined ? message.event : $root.signalservice.SyncMessage.CallEvent.Event[message.event] : message.event;
                return object;
            };

            /**
             * Converts this CallEvent to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.CallEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CallEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CallEvent
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.CallEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CallEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.CallEvent";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.CallEvent.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} AUDIO_CALL=1 AUDIO_CALL value
             * @property {number} VIDEO_CALL=2 VIDEO_CALL value
             * @property {number} GROUP_CALL=3 GROUP_CALL value
             * @property {number} AD_HOC_CALL=4 AD_HOC_CALL value
             */
            CallEvent.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "AUDIO_CALL"] = 1;
                values[valuesById[2] = "VIDEO_CALL"] = 2;
                values[valuesById[3] = "GROUP_CALL"] = 3;
                values[valuesById[4] = "AD_HOC_CALL"] = 4;
                return values;
            })();

            /**
             * Direction enum.
             * @name signalservice.SyncMessage.CallEvent.Direction
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} INCOMING=1 INCOMING value
             * @property {number} OUTGOING=2 OUTGOING value
             */
            CallEvent.Direction = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "INCOMING"] = 1;
                values[valuesById[2] = "OUTGOING"] = 2;
                return values;
            })();

            /**
             * Event enum.
             * @name signalservice.SyncMessage.CallEvent.Event
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} ACCEPTED=1 ACCEPTED value
             * @property {number} NOT_ACCEPTED=2 NOT_ACCEPTED value
             * @property {number} DELETE=3 DELETE value
             * @property {number} OBSERVED=4 OBSERVED value
             */
            CallEvent.Event = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "ACCEPTED"] = 1;
                values[valuesById[2] = "NOT_ACCEPTED"] = 2;
                values[valuesById[3] = "DELETE"] = 3;
                values[valuesById[4] = "OBSERVED"] = 4;
                return values;
            })();

            return CallEvent;
        })();

        SyncMessage.CallLinkUpdate = (function() {

            /**
             * Properties of a CallLinkUpdate.
             * @memberof signalservice.SyncMessage
             * @interface ICallLinkUpdate
             * @property {Uint8Array|null} [rootKey] CallLinkUpdate rootKey
             * @property {Uint8Array|null} [adminPasskey] CallLinkUpdate adminPasskey
             * @property {signalservice.SyncMessage.CallLinkUpdate.Type|null} [type] CallLinkUpdate type
             */

            /**
             * Constructs a new CallLinkUpdate.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a CallLinkUpdate.
             * @implements ICallLinkUpdate
             * @constructor
             * @param {signalservice.SyncMessage.ICallLinkUpdate=} [properties] Properties to set
             */
            function CallLinkUpdate(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CallLinkUpdate rootKey.
             * @member {Uint8Array} rootKey
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @instance
             */
            CallLinkUpdate.prototype.rootKey = $util.newBuffer([]);

            /**
             * CallLinkUpdate adminPasskey.
             * @member {Uint8Array} adminPasskey
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @instance
             */
            CallLinkUpdate.prototype.adminPasskey = $util.newBuffer([]);

            /**
             * CallLinkUpdate type.
             * @member {signalservice.SyncMessage.CallLinkUpdate.Type} type
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @instance
             */
            CallLinkUpdate.prototype.type = 0;

            /**
             * Creates a new CallLinkUpdate instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {signalservice.SyncMessage.ICallLinkUpdate=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.CallLinkUpdate} CallLinkUpdate instance
             */
            CallLinkUpdate.create = function create(properties) {
                return new CallLinkUpdate(properties);
            };

            /**
             * Encodes the specified CallLinkUpdate message. Does not implicitly {@link signalservice.SyncMessage.CallLinkUpdate.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {signalservice.SyncMessage.ICallLinkUpdate} message CallLinkUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallLinkUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rootKey != null && Object.hasOwnProperty.call(message, "rootKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rootKey);
                if (message.adminPasskey != null && Object.hasOwnProperty.call(message, "adminPasskey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.adminPasskey);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified CallLinkUpdate message, length delimited. Does not implicitly {@link signalservice.SyncMessage.CallLinkUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {signalservice.SyncMessage.ICallLinkUpdate} message CallLinkUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallLinkUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CallLinkUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.CallLinkUpdate} CallLinkUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallLinkUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.CallLinkUpdate();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.rootKey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.adminPasskey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CallLinkUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.CallLinkUpdate} CallLinkUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallLinkUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CallLinkUpdate message.
             * @function verify
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CallLinkUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                    if (!(message.rootKey && typeof message.rootKey.length === "number" || $util.isString(message.rootKey)))
                        return "rootKey: buffer expected";
                if (message.adminPasskey != null && message.hasOwnProperty("adminPasskey"))
                    if (!(message.adminPasskey && typeof message.adminPasskey.length === "number" || $util.isString(message.adminPasskey)))
                        return "adminPasskey: buffer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CallLinkUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.CallLinkUpdate} CallLinkUpdate
             */
            CallLinkUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.CallLinkUpdate)
                    return object;
                let message = new $root.signalservice.SyncMessage.CallLinkUpdate();
                if (object.rootKey != null)
                    if (typeof object.rootKey === "string")
                        $util.base64.decode(object.rootKey, message.rootKey = $util.newBuffer($util.base64.length(object.rootKey)), 0);
                    else if (object.rootKey.length >= 0)
                        message.rootKey = object.rootKey;
                if (object.adminPasskey != null)
                    if (typeof object.adminPasskey === "string")
                        $util.base64.decode(object.adminPasskey, message.adminPasskey = $util.newBuffer($util.base64.length(object.adminPasskey)), 0);
                    else if (object.adminPasskey.length >= 0)
                        message.adminPasskey = object.adminPasskey;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UPDATE":
                case 0:
                    message.type = 0;
                    break;
                case "DELETE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CallLinkUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {signalservice.SyncMessage.CallLinkUpdate} message CallLinkUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CallLinkUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.rootKey = "";
                    else {
                        object.rootKey = [];
                        if (options.bytes !== Array)
                            object.rootKey = $util.newBuffer(object.rootKey);
                    }
                    if (options.bytes === String)
                        object.adminPasskey = "";
                    else {
                        object.adminPasskey = [];
                        if (options.bytes !== Array)
                            object.adminPasskey = $util.newBuffer(object.adminPasskey);
                    }
                    object.type = options.enums === String ? "UPDATE" : 0;
                }
                if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                    object.rootKey = options.bytes === String ? $util.base64.encode(message.rootKey, 0, message.rootKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rootKey) : message.rootKey;
                if (message.adminPasskey != null && message.hasOwnProperty("adminPasskey"))
                    object.adminPasskey = options.bytes === String ? $util.base64.encode(message.adminPasskey, 0, message.adminPasskey.length) : options.bytes === Array ? Array.prototype.slice.call(message.adminPasskey) : message.adminPasskey;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.CallLinkUpdate.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.CallLinkUpdate.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this CallLinkUpdate to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CallLinkUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CallLinkUpdate
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.CallLinkUpdate
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CallLinkUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.CallLinkUpdate";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.CallLinkUpdate.Type
             * @enum {number}
             * @property {number} UPDATE=0 UPDATE value
             * @property {number} DELETE=1 DELETE value
             */
            CallLinkUpdate.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UPDATE"] = 0;
                values[valuesById[1] = "DELETE"] = 1;
                return values;
            })();

            return CallLinkUpdate;
        })();

        SyncMessage.CallLogEvent = (function() {

            /**
             * Properties of a CallLogEvent.
             * @memberof signalservice.SyncMessage
             * @interface ICallLogEvent
             * @property {signalservice.SyncMessage.CallLogEvent.Type|null} [type] CallLogEvent type
             * @property {number|Long|null} [timestamp] CallLogEvent timestamp
             * @property {Uint8Array|null} [peerId] CallLogEvent peerId
             * @property {number|Long|null} [callId] CallLogEvent callId
             */

            /**
             * Constructs a new CallLogEvent.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a CallLogEvent.
             * @implements ICallLogEvent
             * @constructor
             * @param {signalservice.SyncMessage.ICallLogEvent=} [properties] Properties to set
             */
            function CallLogEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CallLogEvent type.
             * @member {signalservice.SyncMessage.CallLogEvent.Type} type
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @instance
             */
            CallLogEvent.prototype.type = 0;

            /**
             * CallLogEvent timestamp.
             * @member {number|Long} timestamp
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @instance
             */
            CallLogEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CallLogEvent peerId.
             * @member {Uint8Array} peerId
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @instance
             */
            CallLogEvent.prototype.peerId = $util.newBuffer([]);

            /**
             * CallLogEvent callId.
             * @member {number|Long} callId
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @instance
             */
            CallLogEvent.prototype.callId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CallLogEvent instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {signalservice.SyncMessage.ICallLogEvent=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.CallLogEvent} CallLogEvent instance
             */
            CallLogEvent.create = function create(properties) {
                return new CallLogEvent(properties);
            };

            /**
             * Encodes the specified CallLogEvent message. Does not implicitly {@link signalservice.SyncMessage.CallLogEvent.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {signalservice.SyncMessage.ICallLogEvent} message CallLogEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallLogEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerId);
                if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.callId);
                return writer;
            };

            /**
             * Encodes the specified CallLogEvent message, length delimited. Does not implicitly {@link signalservice.SyncMessage.CallLogEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {signalservice.SyncMessage.ICallLogEvent} message CallLogEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallLogEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CallLogEvent message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.CallLogEvent} CallLogEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallLogEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.CallLogEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.peerId = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.callId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CallLogEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.CallLogEvent} CallLogEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallLogEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CallLogEvent message.
             * @function verify
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CallLogEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.peerId != null && message.hasOwnProperty("peerId"))
                    if (!(message.peerId && typeof message.peerId.length === "number" || $util.isString(message.peerId)))
                        return "peerId: buffer expected";
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (!$util.isInteger(message.callId) && !(message.callId && $util.isInteger(message.callId.low) && $util.isInteger(message.callId.high)))
                        return "callId: integer|Long expected";
                return null;
            };

            /**
             * Creates a CallLogEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.CallLogEvent} CallLogEvent
             */
            CallLogEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.CallLogEvent)
                    return object;
                let message = new $root.signalservice.SyncMessage.CallLogEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "CLEAR":
                case 0:
                    message.type = 0;
                    break;
                case "MARKED_AS_READ":
                case 1:
                    message.type = 1;
                    break;
                case "MARKED_AS_READ_IN_CONVERSATION":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                if (object.peerId != null)
                    if (typeof object.peerId === "string")
                        $util.base64.decode(object.peerId, message.peerId = $util.newBuffer($util.base64.length(object.peerId)), 0);
                    else if (object.peerId.length >= 0)
                        message.peerId = object.peerId;
                if (object.callId != null)
                    if ($util.Long)
                        (message.callId = $util.Long.fromValue(object.callId)).unsigned = true;
                    else if (typeof object.callId === "string")
                        message.callId = parseInt(object.callId, 10);
                    else if (typeof object.callId === "number")
                        message.callId = object.callId;
                    else if (typeof object.callId === "object")
                        message.callId = new $util.LongBits(object.callId.low >>> 0, object.callId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CallLogEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {signalservice.SyncMessage.CallLogEvent} message CallLogEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CallLogEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "CLEAR" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.peerId = "";
                    else {
                        object.peerId = [];
                        if (options.bytes !== Array)
                            object.peerId = $util.newBuffer(object.peerId);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.callId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callId = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.signalservice.SyncMessage.CallLogEvent.Type[message.type] === undefined ? message.type : $root.signalservice.SyncMessage.CallLogEvent.Type[message.type] : message.type;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.peerId != null && message.hasOwnProperty("peerId"))
                    object.peerId = options.bytes === String ? $util.base64.encode(message.peerId, 0, message.peerId.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerId) : message.peerId;
                if (message.callId != null && message.hasOwnProperty("callId"))
                    if (typeof message.callId === "number")
                        object.callId = options.longs === String ? String(message.callId) : message.callId;
                    else
                        object.callId = options.longs === String ? $util.Long.prototype.toString.call(message.callId) : options.longs === Number ? new $util.LongBits(message.callId.low >>> 0, message.callId.high >>> 0).toNumber(true) : message.callId;
                return object;
            };

            /**
             * Converts this CallLogEvent to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CallLogEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CallLogEvent
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.CallLogEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CallLogEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.CallLogEvent";
            };

            /**
             * Type enum.
             * @name signalservice.SyncMessage.CallLogEvent.Type
             * @enum {number}
             * @property {number} CLEAR=0 CLEAR value
             * @property {number} MARKED_AS_READ=1 MARKED_AS_READ value
             * @property {number} MARKED_AS_READ_IN_CONVERSATION=2 MARKED_AS_READ_IN_CONVERSATION value
             */
            CallLogEvent.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CLEAR"] = 0;
                values[valuesById[1] = "MARKED_AS_READ"] = 1;
                values[valuesById[2] = "MARKED_AS_READ_IN_CONVERSATION"] = 2;
                return values;
            })();

            return CallLogEvent;
        })();

        SyncMessage.DeleteForMe = (function() {

            /**
             * Properties of a DeleteForMe.
             * @memberof signalservice.SyncMessage
             * @interface IDeleteForMe
             * @property {Array.<signalservice.SyncMessage.DeleteForMe.IMessageDeletes>|null} [messageDeletes] DeleteForMe messageDeletes
             * @property {Array.<signalservice.SyncMessage.DeleteForMe.IConversationDelete>|null} [conversationDeletes] DeleteForMe conversationDeletes
             * @property {Array.<signalservice.SyncMessage.DeleteForMe.ILocalOnlyConversationDelete>|null} [localOnlyConversationDeletes] DeleteForMe localOnlyConversationDeletes
             * @property {Array.<signalservice.SyncMessage.DeleteForMe.IAttachmentDelete>|null} [attachmentDeletes] DeleteForMe attachmentDeletes
             */

            /**
             * Constructs a new DeleteForMe.
             * @memberof signalservice.SyncMessage
             * @classdesc Represents a DeleteForMe.
             * @implements IDeleteForMe
             * @constructor
             * @param {signalservice.SyncMessage.IDeleteForMe=} [properties] Properties to set
             */
            function DeleteForMe(properties) {
                this.messageDeletes = [];
                this.conversationDeletes = [];
                this.localOnlyConversationDeletes = [];
                this.attachmentDeletes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteForMe messageDeletes.
             * @member {Array.<signalservice.SyncMessage.DeleteForMe.IMessageDeletes>} messageDeletes
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @instance
             */
            DeleteForMe.prototype.messageDeletes = $util.emptyArray;

            /**
             * DeleteForMe conversationDeletes.
             * @member {Array.<signalservice.SyncMessage.DeleteForMe.IConversationDelete>} conversationDeletes
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @instance
             */
            DeleteForMe.prototype.conversationDeletes = $util.emptyArray;

            /**
             * DeleteForMe localOnlyConversationDeletes.
             * @member {Array.<signalservice.SyncMessage.DeleteForMe.ILocalOnlyConversationDelete>} localOnlyConversationDeletes
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @instance
             */
            DeleteForMe.prototype.localOnlyConversationDeletes = $util.emptyArray;

            /**
             * DeleteForMe attachmentDeletes.
             * @member {Array.<signalservice.SyncMessage.DeleteForMe.IAttachmentDelete>} attachmentDeletes
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @instance
             */
            DeleteForMe.prototype.attachmentDeletes = $util.emptyArray;

            /**
             * Creates a new DeleteForMe instance using the specified properties.
             * @function create
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {signalservice.SyncMessage.IDeleteForMe=} [properties] Properties to set
             * @returns {signalservice.SyncMessage.DeleteForMe} DeleteForMe instance
             */
            DeleteForMe.create = function create(properties) {
                return new DeleteForMe(properties);
            };

            /**
             * Encodes the specified DeleteForMe message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.verify|verify} messages.
             * @function encode
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {signalservice.SyncMessage.IDeleteForMe} message DeleteForMe message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteForMe.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageDeletes != null && message.messageDeletes.length)
                    for (let i = 0; i < message.messageDeletes.length; ++i)
                        $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes.encode(message.messageDeletes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.conversationDeletes != null && message.conversationDeletes.length)
                    for (let i = 0; i < message.conversationDeletes.length; ++i)
                        $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete.encode(message.conversationDeletes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.localOnlyConversationDeletes != null && message.localOnlyConversationDeletes.length)
                    for (let i = 0; i < message.localOnlyConversationDeletes.length; ++i)
                        $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.encode(message.localOnlyConversationDeletes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.attachmentDeletes != null && message.attachmentDeletes.length)
                    for (let i = 0; i < message.attachmentDeletes.length; ++i)
                        $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete.encode(message.attachmentDeletes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteForMe message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {signalservice.SyncMessage.IDeleteForMe} message DeleteForMe message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteForMe.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteForMe message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.SyncMessage.DeleteForMe} DeleteForMe
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteForMe.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messageDeletes && message.messageDeletes.length))
                                message.messageDeletes = [];
                            message.messageDeletes.push($root.signalservice.SyncMessage.DeleteForMe.MessageDeletes.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.conversationDeletes && message.conversationDeletes.length))
                                message.conversationDeletes = [];
                            message.conversationDeletes.push($root.signalservice.SyncMessage.DeleteForMe.ConversationDelete.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.localOnlyConversationDeletes && message.localOnlyConversationDeletes.length))
                                message.localOnlyConversationDeletes = [];
                            message.localOnlyConversationDeletes.push($root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.attachmentDeletes && message.attachmentDeletes.length))
                                message.attachmentDeletes = [];
                            message.attachmentDeletes.push($root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteForMe message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.SyncMessage.DeleteForMe} DeleteForMe
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteForMe.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteForMe message.
             * @function verify
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteForMe.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageDeletes != null && message.hasOwnProperty("messageDeletes")) {
                    if (!Array.isArray(message.messageDeletes))
                        return "messageDeletes: array expected";
                    for (let i = 0; i < message.messageDeletes.length; ++i) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes.verify(message.messageDeletes[i]);
                        if (error)
                            return "messageDeletes." + error;
                    }
                }
                if (message.conversationDeletes != null && message.hasOwnProperty("conversationDeletes")) {
                    if (!Array.isArray(message.conversationDeletes))
                        return "conversationDeletes: array expected";
                    for (let i = 0; i < message.conversationDeletes.length; ++i) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete.verify(message.conversationDeletes[i]);
                        if (error)
                            return "conversationDeletes." + error;
                    }
                }
                if (message.localOnlyConversationDeletes != null && message.hasOwnProperty("localOnlyConversationDeletes")) {
                    if (!Array.isArray(message.localOnlyConversationDeletes))
                        return "localOnlyConversationDeletes: array expected";
                    for (let i = 0; i < message.localOnlyConversationDeletes.length; ++i) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.verify(message.localOnlyConversationDeletes[i]);
                        if (error)
                            return "localOnlyConversationDeletes." + error;
                    }
                }
                if (message.attachmentDeletes != null && message.hasOwnProperty("attachmentDeletes")) {
                    if (!Array.isArray(message.attachmentDeletes))
                        return "attachmentDeletes: array expected";
                    for (let i = 0; i < message.attachmentDeletes.length; ++i) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete.verify(message.attachmentDeletes[i]);
                        if (error)
                            return "attachmentDeletes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DeleteForMe message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.SyncMessage.DeleteForMe} DeleteForMe
             */
            DeleteForMe.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.SyncMessage.DeleteForMe)
                    return object;
                let message = new $root.signalservice.SyncMessage.DeleteForMe();
                if (object.messageDeletes) {
                    if (!Array.isArray(object.messageDeletes))
                        throw TypeError(".signalservice.SyncMessage.DeleteForMe.messageDeletes: array expected");
                    message.messageDeletes = [];
                    for (let i = 0; i < object.messageDeletes.length; ++i) {
                        if (typeof object.messageDeletes[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.messageDeletes: object expected");
                        message.messageDeletes[i] = $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes.fromObject(object.messageDeletes[i]);
                    }
                }
                if (object.conversationDeletes) {
                    if (!Array.isArray(object.conversationDeletes))
                        throw TypeError(".signalservice.SyncMessage.DeleteForMe.conversationDeletes: array expected");
                    message.conversationDeletes = [];
                    for (let i = 0; i < object.conversationDeletes.length; ++i) {
                        if (typeof object.conversationDeletes[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.conversationDeletes: object expected");
                        message.conversationDeletes[i] = $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete.fromObject(object.conversationDeletes[i]);
                    }
                }
                if (object.localOnlyConversationDeletes) {
                    if (!Array.isArray(object.localOnlyConversationDeletes))
                        throw TypeError(".signalservice.SyncMessage.DeleteForMe.localOnlyConversationDeletes: array expected");
                    message.localOnlyConversationDeletes = [];
                    for (let i = 0; i < object.localOnlyConversationDeletes.length; ++i) {
                        if (typeof object.localOnlyConversationDeletes[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.localOnlyConversationDeletes: object expected");
                        message.localOnlyConversationDeletes[i] = $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.fromObject(object.localOnlyConversationDeletes[i]);
                    }
                }
                if (object.attachmentDeletes) {
                    if (!Array.isArray(object.attachmentDeletes))
                        throw TypeError(".signalservice.SyncMessage.DeleteForMe.attachmentDeletes: array expected");
                    message.attachmentDeletes = [];
                    for (let i = 0; i < object.attachmentDeletes.length; ++i) {
                        if (typeof object.attachmentDeletes[i] !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.attachmentDeletes: object expected");
                        message.attachmentDeletes[i] = $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete.fromObject(object.attachmentDeletes[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteForMe message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {signalservice.SyncMessage.DeleteForMe} message DeleteForMe
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteForMe.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.messageDeletes = [];
                    object.conversationDeletes = [];
                    object.localOnlyConversationDeletes = [];
                    object.attachmentDeletes = [];
                }
                if (message.messageDeletes && message.messageDeletes.length) {
                    object.messageDeletes = [];
                    for (let j = 0; j < message.messageDeletes.length; ++j)
                        object.messageDeletes[j] = $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes.toObject(message.messageDeletes[j], options);
                }
                if (message.conversationDeletes && message.conversationDeletes.length) {
                    object.conversationDeletes = [];
                    for (let j = 0; j < message.conversationDeletes.length; ++j)
                        object.conversationDeletes[j] = $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete.toObject(message.conversationDeletes[j], options);
                }
                if (message.localOnlyConversationDeletes && message.localOnlyConversationDeletes.length) {
                    object.localOnlyConversationDeletes = [];
                    for (let j = 0; j < message.localOnlyConversationDeletes.length; ++j)
                        object.localOnlyConversationDeletes[j] = $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.toObject(message.localOnlyConversationDeletes[j], options);
                }
                if (message.attachmentDeletes && message.attachmentDeletes.length) {
                    object.attachmentDeletes = [];
                    for (let j = 0; j < message.attachmentDeletes.length; ++j)
                        object.attachmentDeletes[j] = $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete.toObject(message.attachmentDeletes[j], options);
                }
                return object;
            };

            /**
             * Converts this DeleteForMe to JSON.
             * @function toJSON
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteForMe.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteForMe
             * @function getTypeUrl
             * @memberof signalservice.SyncMessage.DeleteForMe
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteForMe.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe";
            };

            DeleteForMe.ConversationIdentifier = (function() {

                /**
                 * Properties of a ConversationIdentifier.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @interface IConversationIdentifier
                 * @property {string|null} [threadServiceId] ConversationIdentifier threadServiceId
                 * @property {Uint8Array|null} [threadGroupId] ConversationIdentifier threadGroupId
                 * @property {string|null} [threadE164] ConversationIdentifier threadE164
                 */

                /**
                 * Constructs a new ConversationIdentifier.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @classdesc Represents a ConversationIdentifier.
                 * @implements IConversationIdentifier
                 * @constructor
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier=} [properties] Properties to set
                 */
                function ConversationIdentifier(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConversationIdentifier threadServiceId.
                 * @member {string|null|undefined} threadServiceId
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @instance
                 */
                ConversationIdentifier.prototype.threadServiceId = null;

                /**
                 * ConversationIdentifier threadGroupId.
                 * @member {Uint8Array|null|undefined} threadGroupId
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @instance
                 */
                ConversationIdentifier.prototype.threadGroupId = null;

                /**
                 * ConversationIdentifier threadE164.
                 * @member {string|null|undefined} threadE164
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @instance
                 */
                ConversationIdentifier.prototype.threadE164 = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * ConversationIdentifier identifier.
                 * @member {"threadServiceId"|"threadGroupId"|"threadE164"|undefined} identifier
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @instance
                 */
                Object.defineProperty(ConversationIdentifier.prototype, "identifier", {
                    get: $util.oneOfGetter($oneOfFields = ["threadServiceId", "threadGroupId", "threadE164"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ConversationIdentifier instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationIdentifier} ConversationIdentifier instance
                 */
                ConversationIdentifier.create = function create(properties) {
                    return new ConversationIdentifier(properties);
                };

                /**
                 * Encodes the specified ConversationIdentifier message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier} message ConversationIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConversationIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.threadServiceId != null && Object.hasOwnProperty.call(message, "threadServiceId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.threadServiceId);
                    if (message.threadGroupId != null && Object.hasOwnProperty.call(message, "threadGroupId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.threadGroupId);
                    if (message.threadE164 != null && Object.hasOwnProperty.call(message, "threadE164"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.threadE164);
                    return writer;
                };

                /**
                 * Encodes the specified ConversationIdentifier message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier} message ConversationIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConversationIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ConversationIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationIdentifier} ConversationIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConversationIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.threadServiceId = reader.string();
                                break;
                            }
                        case 2: {
                                message.threadGroupId = reader.bytes();
                                break;
                            }
                        case 3: {
                                message.threadE164 = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ConversationIdentifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationIdentifier} ConversationIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConversationIdentifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ConversationIdentifier message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConversationIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.threadServiceId != null && message.hasOwnProperty("threadServiceId")) {
                        properties.identifier = 1;
                        if (!$util.isString(message.threadServiceId))
                            return "threadServiceId: string expected";
                    }
                    if (message.threadGroupId != null && message.hasOwnProperty("threadGroupId")) {
                        if (properties.identifier === 1)
                            return "identifier: multiple values";
                        properties.identifier = 1;
                        if (!(message.threadGroupId && typeof message.threadGroupId.length === "number" || $util.isString(message.threadGroupId)))
                            return "threadGroupId: buffer expected";
                    }
                    if (message.threadE164 != null && message.hasOwnProperty("threadE164")) {
                        if (properties.identifier === 1)
                            return "identifier: multiple values";
                        properties.identifier = 1;
                        if (!$util.isString(message.threadE164))
                            return "threadE164: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a ConversationIdentifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationIdentifier} ConversationIdentifier
                 */
                ConversationIdentifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier)
                        return object;
                    let message = new $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier();
                    if (object.threadServiceId != null)
                        message.threadServiceId = String(object.threadServiceId);
                    if (object.threadGroupId != null)
                        if (typeof object.threadGroupId === "string")
                            $util.base64.decode(object.threadGroupId, message.threadGroupId = $util.newBuffer($util.base64.length(object.threadGroupId)), 0);
                        else if (object.threadGroupId.length >= 0)
                            message.threadGroupId = object.threadGroupId;
                    if (object.threadE164 != null)
                        message.threadE164 = String(object.threadE164);
                    return message;
                };

                /**
                 * Creates a plain object from a ConversationIdentifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.ConversationIdentifier} message ConversationIdentifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConversationIdentifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.threadServiceId != null && message.hasOwnProperty("threadServiceId")) {
                        object.threadServiceId = message.threadServiceId;
                        if (options.oneofs)
                            object.identifier = "threadServiceId";
                    }
                    if (message.threadGroupId != null && message.hasOwnProperty("threadGroupId")) {
                        object.threadGroupId = options.bytes === String ? $util.base64.encode(message.threadGroupId, 0, message.threadGroupId.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadGroupId) : message.threadGroupId;
                        if (options.oneofs)
                            object.identifier = "threadGroupId";
                    }
                    if (message.threadE164 != null && message.hasOwnProperty("threadE164")) {
                        object.threadE164 = message.threadE164;
                        if (options.oneofs)
                            object.identifier = "threadE164";
                    }
                    return object;
                };

                /**
                 * Converts this ConversationIdentifier to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConversationIdentifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ConversationIdentifier
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationIdentifier
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ConversationIdentifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe.ConversationIdentifier";
                };

                return ConversationIdentifier;
            })();

            DeleteForMe.AddressableMessage = (function() {

                /**
                 * Properties of an AddressableMessage.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @interface IAddressableMessage
                 * @property {string|null} [authorServiceId] AddressableMessage authorServiceId
                 * @property {string|null} [authorE164] AddressableMessage authorE164
                 * @property {number|Long|null} [sentTimestamp] AddressableMessage sentTimestamp
                 */

                /**
                 * Constructs a new AddressableMessage.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @classdesc Represents an AddressableMessage.
                 * @implements IAddressableMessage
                 * @constructor
                 * @param {signalservice.SyncMessage.DeleteForMe.IAddressableMessage=} [properties] Properties to set
                 */
                function AddressableMessage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AddressableMessage authorServiceId.
                 * @member {string|null|undefined} authorServiceId
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @instance
                 */
                AddressableMessage.prototype.authorServiceId = null;

                /**
                 * AddressableMessage authorE164.
                 * @member {string|null|undefined} authorE164
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @instance
                 */
                AddressableMessage.prototype.authorE164 = null;

                /**
                 * AddressableMessage sentTimestamp.
                 * @member {number|Long} sentTimestamp
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @instance
                 */
                AddressableMessage.prototype.sentTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * AddressableMessage author.
                 * @member {"authorServiceId"|"authorE164"|undefined} author
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @instance
                 */
                Object.defineProperty(AddressableMessage.prototype, "author", {
                    get: $util.oneOfGetter($oneOfFields = ["authorServiceId", "authorE164"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new AddressableMessage instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IAddressableMessage=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.DeleteForMe.AddressableMessage} AddressableMessage instance
                 */
                AddressableMessage.create = function create(properties) {
                    return new AddressableMessage(properties);
                };

                /**
                 * Encodes the specified AddressableMessage message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.AddressableMessage.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IAddressableMessage} message AddressableMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddressableMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.authorServiceId != null && Object.hasOwnProperty.call(message, "authorServiceId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.authorServiceId);
                    if (message.authorE164 != null && Object.hasOwnProperty.call(message, "authorE164"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.authorE164);
                    if (message.sentTimestamp != null && Object.hasOwnProperty.call(message, "sentTimestamp"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sentTimestamp);
                    return writer;
                };

                /**
                 * Encodes the specified AddressableMessage message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.AddressableMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IAddressableMessage} message AddressableMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddressableMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AddressableMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.DeleteForMe.AddressableMessage} AddressableMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddressableMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.authorServiceId = reader.string();
                                break;
                            }
                        case 2: {
                                message.authorE164 = reader.string();
                                break;
                            }
                        case 3: {
                                message.sentTimestamp = reader.uint64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AddressableMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.DeleteForMe.AddressableMessage} AddressableMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddressableMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AddressableMessage message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AddressableMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.authorServiceId != null && message.hasOwnProperty("authorServiceId")) {
                        properties.author = 1;
                        if (!$util.isString(message.authorServiceId))
                            return "authorServiceId: string expected";
                    }
                    if (message.authorE164 != null && message.hasOwnProperty("authorE164")) {
                        if (properties.author === 1)
                            return "author: multiple values";
                        properties.author = 1;
                        if (!$util.isString(message.authorE164))
                            return "authorE164: string expected";
                    }
                    if (message.sentTimestamp != null && message.hasOwnProperty("sentTimestamp"))
                        if (!$util.isInteger(message.sentTimestamp) && !(message.sentTimestamp && $util.isInteger(message.sentTimestamp.low) && $util.isInteger(message.sentTimestamp.high)))
                            return "sentTimestamp: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an AddressableMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.DeleteForMe.AddressableMessage} AddressableMessage
                 */
                AddressableMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage)
                        return object;
                    let message = new $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage();
                    if (object.authorServiceId != null)
                        message.authorServiceId = String(object.authorServiceId);
                    if (object.authorE164 != null)
                        message.authorE164 = String(object.authorE164);
                    if (object.sentTimestamp != null)
                        if ($util.Long)
                            (message.sentTimestamp = $util.Long.fromValue(object.sentTimestamp)).unsigned = true;
                        else if (typeof object.sentTimestamp === "string")
                            message.sentTimestamp = parseInt(object.sentTimestamp, 10);
                        else if (typeof object.sentTimestamp === "number")
                            message.sentTimestamp = object.sentTimestamp;
                        else if (typeof object.sentTimestamp === "object")
                            message.sentTimestamp = new $util.LongBits(object.sentTimestamp.low >>> 0, object.sentTimestamp.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from an AddressableMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.AddressableMessage} message AddressableMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddressableMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.sentTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sentTimestamp = options.longs === String ? "0" : 0;
                    if (message.authorServiceId != null && message.hasOwnProperty("authorServiceId")) {
                        object.authorServiceId = message.authorServiceId;
                        if (options.oneofs)
                            object.author = "authorServiceId";
                    }
                    if (message.authorE164 != null && message.hasOwnProperty("authorE164")) {
                        object.authorE164 = message.authorE164;
                        if (options.oneofs)
                            object.author = "authorE164";
                    }
                    if (message.sentTimestamp != null && message.hasOwnProperty("sentTimestamp"))
                        if (typeof message.sentTimestamp === "number")
                            object.sentTimestamp = options.longs === String ? String(message.sentTimestamp) : message.sentTimestamp;
                        else
                            object.sentTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimestamp) : options.longs === Number ? new $util.LongBits(message.sentTimestamp.low >>> 0, message.sentTimestamp.high >>> 0).toNumber(true) : message.sentTimestamp;
                    return object;
                };

                /**
                 * Converts this AddressableMessage to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddressableMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AddressableMessage
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.DeleteForMe.AddressableMessage
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AddressableMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe.AddressableMessage";
                };

                return AddressableMessage;
            })();

            DeleteForMe.MessageDeletes = (function() {

                /**
                 * Properties of a MessageDeletes.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @interface IMessageDeletes
                 * @property {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null} [conversation] MessageDeletes conversation
                 * @property {Array.<signalservice.SyncMessage.DeleteForMe.IAddressableMessage>|null} [messages] MessageDeletes messages
                 */

                /**
                 * Constructs a new MessageDeletes.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @classdesc Represents a MessageDeletes.
                 * @implements IMessageDeletes
                 * @constructor
                 * @param {signalservice.SyncMessage.DeleteForMe.IMessageDeletes=} [properties] Properties to set
                 */
                function MessageDeletes(properties) {
                    this.messages = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageDeletes conversation.
                 * @member {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null|undefined} conversation
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @instance
                 */
                MessageDeletes.prototype.conversation = null;

                /**
                 * MessageDeletes messages.
                 * @member {Array.<signalservice.SyncMessage.DeleteForMe.IAddressableMessage>} messages
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @instance
                 */
                MessageDeletes.prototype.messages = $util.emptyArray;

                /**
                 * Creates a new MessageDeletes instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IMessageDeletes=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.DeleteForMe.MessageDeletes} MessageDeletes instance
                 */
                MessageDeletes.create = function create(properties) {
                    return new MessageDeletes(properties);
                };

                /**
                 * Encodes the specified MessageDeletes message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.MessageDeletes.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IMessageDeletes} message MessageDeletes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDeletes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.conversation != null && Object.hasOwnProperty.call(message, "conversation"))
                        $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.encode(message.conversation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.messages != null && message.messages.length)
                        for (let i = 0; i < message.messages.length; ++i)
                            $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageDeletes message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.MessageDeletes.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IMessageDeletes} message MessageDeletes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDeletes.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageDeletes message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.DeleteForMe.MessageDeletes} MessageDeletes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDeletes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.messages && message.messages.length))
                                    message.messages = [];
                                message.messages.push($root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageDeletes message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.DeleteForMe.MessageDeletes} MessageDeletes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDeletes.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageDeletes message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageDeletes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.conversation != null && message.hasOwnProperty("conversation")) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.verify(message.conversation);
                        if (error)
                            return "conversation." + error;
                    }
                    if (message.messages != null && message.hasOwnProperty("messages")) {
                        if (!Array.isArray(message.messages))
                            return "messages: array expected";
                        for (let i = 0; i < message.messages.length; ++i) {
                            let error = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.verify(message.messages[i]);
                            if (error)
                                return "messages." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageDeletes message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.DeleteForMe.MessageDeletes} MessageDeletes
                 */
                MessageDeletes.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes)
                        return object;
                    let message = new $root.signalservice.SyncMessage.DeleteForMe.MessageDeletes();
                    if (object.conversation != null) {
                        if (typeof object.conversation !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.MessageDeletes.conversation: object expected");
                        message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.fromObject(object.conversation);
                    }
                    if (object.messages) {
                        if (!Array.isArray(object.messages))
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.MessageDeletes.messages: array expected");
                        message.messages = [];
                        for (let i = 0; i < object.messages.length; ++i) {
                            if (typeof object.messages[i] !== "object")
                                throw TypeError(".signalservice.SyncMessage.DeleteForMe.MessageDeletes.messages: object expected");
                            message.messages[i] = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.fromObject(object.messages[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageDeletes message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.MessageDeletes} message MessageDeletes
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageDeletes.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.messages = [];
                    if (options.defaults)
                        object.conversation = null;
                    if (message.conversation != null && message.hasOwnProperty("conversation"))
                        object.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.toObject(message.conversation, options);
                    if (message.messages && message.messages.length) {
                        object.messages = [];
                        for (let j = 0; j < message.messages.length; ++j)
                            object.messages[j] = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.toObject(message.messages[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageDeletes to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageDeletes.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageDeletes
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.DeleteForMe.MessageDeletes
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageDeletes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe.MessageDeletes";
                };

                return MessageDeletes;
            })();

            DeleteForMe.AttachmentDelete = (function() {

                /**
                 * Properties of an AttachmentDelete.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @interface IAttachmentDelete
                 * @property {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null} [conversation] AttachmentDelete conversation
                 * @property {signalservice.SyncMessage.DeleteForMe.IAddressableMessage|null} [targetMessage] AttachmentDelete targetMessage
                 * @property {Uint8Array|null} [clientUuid] AttachmentDelete clientUuid
                 * @property {Uint8Array|null} [fallbackDigest] AttachmentDelete fallbackDigest
                 * @property {Uint8Array|null} [fallbackPlaintextHash] AttachmentDelete fallbackPlaintextHash
                 */

                /**
                 * Constructs a new AttachmentDelete.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @classdesc Represents an AttachmentDelete.
                 * @implements IAttachmentDelete
                 * @constructor
                 * @param {signalservice.SyncMessage.DeleteForMe.IAttachmentDelete=} [properties] Properties to set
                 */
                function AttachmentDelete(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AttachmentDelete conversation.
                 * @member {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null|undefined} conversation
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @instance
                 */
                AttachmentDelete.prototype.conversation = null;

                /**
                 * AttachmentDelete targetMessage.
                 * @member {signalservice.SyncMessage.DeleteForMe.IAddressableMessage|null|undefined} targetMessage
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @instance
                 */
                AttachmentDelete.prototype.targetMessage = null;

                /**
                 * AttachmentDelete clientUuid.
                 * @member {Uint8Array} clientUuid
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @instance
                 */
                AttachmentDelete.prototype.clientUuid = $util.newBuffer([]);

                /**
                 * AttachmentDelete fallbackDigest.
                 * @member {Uint8Array} fallbackDigest
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @instance
                 */
                AttachmentDelete.prototype.fallbackDigest = $util.newBuffer([]);

                /**
                 * AttachmentDelete fallbackPlaintextHash.
                 * @member {Uint8Array} fallbackPlaintextHash
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @instance
                 */
                AttachmentDelete.prototype.fallbackPlaintextHash = $util.newBuffer([]);

                /**
                 * Creates a new AttachmentDelete instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IAttachmentDelete=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.DeleteForMe.AttachmentDelete} AttachmentDelete instance
                 */
                AttachmentDelete.create = function create(properties) {
                    return new AttachmentDelete(properties);
                };

                /**
                 * Encodes the specified AttachmentDelete message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.AttachmentDelete.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IAttachmentDelete} message AttachmentDelete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AttachmentDelete.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.conversation != null && Object.hasOwnProperty.call(message, "conversation"))
                        $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.encode(message.conversation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.targetMessage != null && Object.hasOwnProperty.call(message, "targetMessage"))
                        $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.encode(message.targetMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.clientUuid != null && Object.hasOwnProperty.call(message, "clientUuid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.clientUuid);
                    if (message.fallbackDigest != null && Object.hasOwnProperty.call(message, "fallbackDigest"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fallbackDigest);
                    if (message.fallbackPlaintextHash != null && Object.hasOwnProperty.call(message, "fallbackPlaintextHash"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.fallbackPlaintextHash);
                    return writer;
                };

                /**
                 * Encodes the specified AttachmentDelete message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.AttachmentDelete.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IAttachmentDelete} message AttachmentDelete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AttachmentDelete.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AttachmentDelete message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.DeleteForMe.AttachmentDelete} AttachmentDelete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AttachmentDelete.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.targetMessage = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.clientUuid = reader.bytes();
                                break;
                            }
                        case 4: {
                                message.fallbackDigest = reader.bytes();
                                break;
                            }
                        case 5: {
                                message.fallbackPlaintextHash = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AttachmentDelete message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.DeleteForMe.AttachmentDelete} AttachmentDelete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AttachmentDelete.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AttachmentDelete message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AttachmentDelete.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.conversation != null && message.hasOwnProperty("conversation")) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.verify(message.conversation);
                        if (error)
                            return "conversation." + error;
                    }
                    if (message.targetMessage != null && message.hasOwnProperty("targetMessage")) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.verify(message.targetMessage);
                        if (error)
                            return "targetMessage." + error;
                    }
                    if (message.clientUuid != null && message.hasOwnProperty("clientUuid"))
                        if (!(message.clientUuid && typeof message.clientUuid.length === "number" || $util.isString(message.clientUuid)))
                            return "clientUuid: buffer expected";
                    if (message.fallbackDigest != null && message.hasOwnProperty("fallbackDigest"))
                        if (!(message.fallbackDigest && typeof message.fallbackDigest.length === "number" || $util.isString(message.fallbackDigest)))
                            return "fallbackDigest: buffer expected";
                    if (message.fallbackPlaintextHash != null && message.hasOwnProperty("fallbackPlaintextHash"))
                        if (!(message.fallbackPlaintextHash && typeof message.fallbackPlaintextHash.length === "number" || $util.isString(message.fallbackPlaintextHash)))
                            return "fallbackPlaintextHash: buffer expected";
                    return null;
                };

                /**
                 * Creates an AttachmentDelete message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.DeleteForMe.AttachmentDelete} AttachmentDelete
                 */
                AttachmentDelete.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete)
                        return object;
                    let message = new $root.signalservice.SyncMessage.DeleteForMe.AttachmentDelete();
                    if (object.conversation != null) {
                        if (typeof object.conversation !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.AttachmentDelete.conversation: object expected");
                        message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.fromObject(object.conversation);
                    }
                    if (object.targetMessage != null) {
                        if (typeof object.targetMessage !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.AttachmentDelete.targetMessage: object expected");
                        message.targetMessage = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.fromObject(object.targetMessage);
                    }
                    if (object.clientUuid != null)
                        if (typeof object.clientUuid === "string")
                            $util.base64.decode(object.clientUuid, message.clientUuid = $util.newBuffer($util.base64.length(object.clientUuid)), 0);
                        else if (object.clientUuid.length >= 0)
                            message.clientUuid = object.clientUuid;
                    if (object.fallbackDigest != null)
                        if (typeof object.fallbackDigest === "string")
                            $util.base64.decode(object.fallbackDigest, message.fallbackDigest = $util.newBuffer($util.base64.length(object.fallbackDigest)), 0);
                        else if (object.fallbackDigest.length >= 0)
                            message.fallbackDigest = object.fallbackDigest;
                    if (object.fallbackPlaintextHash != null)
                        if (typeof object.fallbackPlaintextHash === "string")
                            $util.base64.decode(object.fallbackPlaintextHash, message.fallbackPlaintextHash = $util.newBuffer($util.base64.length(object.fallbackPlaintextHash)), 0);
                        else if (object.fallbackPlaintextHash.length >= 0)
                            message.fallbackPlaintextHash = object.fallbackPlaintextHash;
                    return message;
                };

                /**
                 * Creates a plain object from an AttachmentDelete message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.AttachmentDelete} message AttachmentDelete
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AttachmentDelete.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.conversation = null;
                        object.targetMessage = null;
                        if (options.bytes === String)
                            object.clientUuid = "";
                        else {
                            object.clientUuid = [];
                            if (options.bytes !== Array)
                                object.clientUuid = $util.newBuffer(object.clientUuid);
                        }
                        if (options.bytes === String)
                            object.fallbackDigest = "";
                        else {
                            object.fallbackDigest = [];
                            if (options.bytes !== Array)
                                object.fallbackDigest = $util.newBuffer(object.fallbackDigest);
                        }
                        if (options.bytes === String)
                            object.fallbackPlaintextHash = "";
                        else {
                            object.fallbackPlaintextHash = [];
                            if (options.bytes !== Array)
                                object.fallbackPlaintextHash = $util.newBuffer(object.fallbackPlaintextHash);
                        }
                    }
                    if (message.conversation != null && message.hasOwnProperty("conversation"))
                        object.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.toObject(message.conversation, options);
                    if (message.targetMessage != null && message.hasOwnProperty("targetMessage"))
                        object.targetMessage = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.toObject(message.targetMessage, options);
                    if (message.clientUuid != null && message.hasOwnProperty("clientUuid"))
                        object.clientUuid = options.bytes === String ? $util.base64.encode(message.clientUuid, 0, message.clientUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientUuid) : message.clientUuid;
                    if (message.fallbackDigest != null && message.hasOwnProperty("fallbackDigest"))
                        object.fallbackDigest = options.bytes === String ? $util.base64.encode(message.fallbackDigest, 0, message.fallbackDigest.length) : options.bytes === Array ? Array.prototype.slice.call(message.fallbackDigest) : message.fallbackDigest;
                    if (message.fallbackPlaintextHash != null && message.hasOwnProperty("fallbackPlaintextHash"))
                        object.fallbackPlaintextHash = options.bytes === String ? $util.base64.encode(message.fallbackPlaintextHash, 0, message.fallbackPlaintextHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.fallbackPlaintextHash) : message.fallbackPlaintextHash;
                    return object;
                };

                /**
                 * Converts this AttachmentDelete to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AttachmentDelete.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AttachmentDelete
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.DeleteForMe.AttachmentDelete
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AttachmentDelete.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe.AttachmentDelete";
                };

                return AttachmentDelete;
            })();

            DeleteForMe.ConversationDelete = (function() {

                /**
                 * Properties of a ConversationDelete.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @interface IConversationDelete
                 * @property {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null} [conversation] ConversationDelete conversation
                 * @property {Array.<signalservice.SyncMessage.DeleteForMe.IAddressableMessage>|null} [mostRecentMessages] ConversationDelete mostRecentMessages
                 * @property {boolean|null} [isFullDelete] ConversationDelete isFullDelete
                 * @property {Array.<signalservice.SyncMessage.DeleteForMe.IAddressableMessage>|null} [mostRecentNonExpiringMessages] ConversationDelete mostRecentNonExpiringMessages
                 */

                /**
                 * Constructs a new ConversationDelete.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @classdesc Represents a ConversationDelete.
                 * @implements IConversationDelete
                 * @constructor
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationDelete=} [properties] Properties to set
                 */
                function ConversationDelete(properties) {
                    this.mostRecentMessages = [];
                    this.mostRecentNonExpiringMessages = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConversationDelete conversation.
                 * @member {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null|undefined} conversation
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @instance
                 */
                ConversationDelete.prototype.conversation = null;

                /**
                 * ConversationDelete mostRecentMessages.
                 * @member {Array.<signalservice.SyncMessage.DeleteForMe.IAddressableMessage>} mostRecentMessages
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @instance
                 */
                ConversationDelete.prototype.mostRecentMessages = $util.emptyArray;

                /**
                 * ConversationDelete isFullDelete.
                 * @member {boolean} isFullDelete
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @instance
                 */
                ConversationDelete.prototype.isFullDelete = false;

                /**
                 * ConversationDelete mostRecentNonExpiringMessages.
                 * @member {Array.<signalservice.SyncMessage.DeleteForMe.IAddressableMessage>} mostRecentNonExpiringMessages
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @instance
                 */
                ConversationDelete.prototype.mostRecentNonExpiringMessages = $util.emptyArray;

                /**
                 * Creates a new ConversationDelete instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationDelete=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationDelete} ConversationDelete instance
                 */
                ConversationDelete.create = function create(properties) {
                    return new ConversationDelete(properties);
                };

                /**
                 * Encodes the specified ConversationDelete message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.ConversationDelete.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationDelete} message ConversationDelete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConversationDelete.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.conversation != null && Object.hasOwnProperty.call(message, "conversation"))
                        $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.encode(message.conversation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.mostRecentMessages != null && message.mostRecentMessages.length)
                        for (let i = 0; i < message.mostRecentMessages.length; ++i)
                            $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.encode(message.mostRecentMessages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.isFullDelete != null && Object.hasOwnProperty.call(message, "isFullDelete"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isFullDelete);
                    if (message.mostRecentNonExpiringMessages != null && message.mostRecentNonExpiringMessages.length)
                        for (let i = 0; i < message.mostRecentNonExpiringMessages.length; ++i)
                            $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.encode(message.mostRecentNonExpiringMessages[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ConversationDelete message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.ConversationDelete.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.IConversationDelete} message ConversationDelete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConversationDelete.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ConversationDelete message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationDelete} ConversationDelete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConversationDelete.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.mostRecentMessages && message.mostRecentMessages.length))
                                    message.mostRecentMessages = [];
                                message.mostRecentMessages.push($root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.isFullDelete = reader.bool();
                                break;
                            }
                        case 4: {
                                if (!(message.mostRecentNonExpiringMessages && message.mostRecentNonExpiringMessages.length))
                                    message.mostRecentNonExpiringMessages = [];
                                message.mostRecentNonExpiringMessages.push($root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ConversationDelete message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationDelete} ConversationDelete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConversationDelete.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ConversationDelete message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConversationDelete.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.conversation != null && message.hasOwnProperty("conversation")) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.verify(message.conversation);
                        if (error)
                            return "conversation." + error;
                    }
                    if (message.mostRecentMessages != null && message.hasOwnProperty("mostRecentMessages")) {
                        if (!Array.isArray(message.mostRecentMessages))
                            return "mostRecentMessages: array expected";
                        for (let i = 0; i < message.mostRecentMessages.length; ++i) {
                            let error = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.verify(message.mostRecentMessages[i]);
                            if (error)
                                return "mostRecentMessages." + error;
                        }
                    }
                    if (message.isFullDelete != null && message.hasOwnProperty("isFullDelete"))
                        if (typeof message.isFullDelete !== "boolean")
                            return "isFullDelete: boolean expected";
                    if (message.mostRecentNonExpiringMessages != null && message.hasOwnProperty("mostRecentNonExpiringMessages")) {
                        if (!Array.isArray(message.mostRecentNonExpiringMessages))
                            return "mostRecentNonExpiringMessages: array expected";
                        for (let i = 0; i < message.mostRecentNonExpiringMessages.length; ++i) {
                            let error = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.verify(message.mostRecentNonExpiringMessages[i]);
                            if (error)
                                return "mostRecentNonExpiringMessages." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ConversationDelete message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.DeleteForMe.ConversationDelete} ConversationDelete
                 */
                ConversationDelete.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete)
                        return object;
                    let message = new $root.signalservice.SyncMessage.DeleteForMe.ConversationDelete();
                    if (object.conversation != null) {
                        if (typeof object.conversation !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.ConversationDelete.conversation: object expected");
                        message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.fromObject(object.conversation);
                    }
                    if (object.mostRecentMessages) {
                        if (!Array.isArray(object.mostRecentMessages))
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.ConversationDelete.mostRecentMessages: array expected");
                        message.mostRecentMessages = [];
                        for (let i = 0; i < object.mostRecentMessages.length; ++i) {
                            if (typeof object.mostRecentMessages[i] !== "object")
                                throw TypeError(".signalservice.SyncMessage.DeleteForMe.ConversationDelete.mostRecentMessages: object expected");
                            message.mostRecentMessages[i] = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.fromObject(object.mostRecentMessages[i]);
                        }
                    }
                    if (object.isFullDelete != null)
                        message.isFullDelete = Boolean(object.isFullDelete);
                    if (object.mostRecentNonExpiringMessages) {
                        if (!Array.isArray(object.mostRecentNonExpiringMessages))
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.ConversationDelete.mostRecentNonExpiringMessages: array expected");
                        message.mostRecentNonExpiringMessages = [];
                        for (let i = 0; i < object.mostRecentNonExpiringMessages.length; ++i) {
                            if (typeof object.mostRecentNonExpiringMessages[i] !== "object")
                                throw TypeError(".signalservice.SyncMessage.DeleteForMe.ConversationDelete.mostRecentNonExpiringMessages: object expected");
                            message.mostRecentNonExpiringMessages[i] = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.fromObject(object.mostRecentNonExpiringMessages[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ConversationDelete message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.ConversationDelete} message ConversationDelete
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConversationDelete.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.mostRecentMessages = [];
                        object.mostRecentNonExpiringMessages = [];
                    }
                    if (options.defaults) {
                        object.conversation = null;
                        object.isFullDelete = false;
                    }
                    if (message.conversation != null && message.hasOwnProperty("conversation"))
                        object.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.toObject(message.conversation, options);
                    if (message.mostRecentMessages && message.mostRecentMessages.length) {
                        object.mostRecentMessages = [];
                        for (let j = 0; j < message.mostRecentMessages.length; ++j)
                            object.mostRecentMessages[j] = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.toObject(message.mostRecentMessages[j], options);
                    }
                    if (message.isFullDelete != null && message.hasOwnProperty("isFullDelete"))
                        object.isFullDelete = message.isFullDelete;
                    if (message.mostRecentNonExpiringMessages && message.mostRecentNonExpiringMessages.length) {
                        object.mostRecentNonExpiringMessages = [];
                        for (let j = 0; j < message.mostRecentNonExpiringMessages.length; ++j)
                            object.mostRecentNonExpiringMessages[j] = $root.signalservice.SyncMessage.DeleteForMe.AddressableMessage.toObject(message.mostRecentNonExpiringMessages[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ConversationDelete to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConversationDelete.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ConversationDelete
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.DeleteForMe.ConversationDelete
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ConversationDelete.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe.ConversationDelete";
                };

                return ConversationDelete;
            })();

            DeleteForMe.LocalOnlyConversationDelete = (function() {

                /**
                 * Properties of a LocalOnlyConversationDelete.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @interface ILocalOnlyConversationDelete
                 * @property {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null} [conversation] LocalOnlyConversationDelete conversation
                 */

                /**
                 * Constructs a new LocalOnlyConversationDelete.
                 * @memberof signalservice.SyncMessage.DeleteForMe
                 * @classdesc Represents a LocalOnlyConversationDelete.
                 * @implements ILocalOnlyConversationDelete
                 * @constructor
                 * @param {signalservice.SyncMessage.DeleteForMe.ILocalOnlyConversationDelete=} [properties] Properties to set
                 */
                function LocalOnlyConversationDelete(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LocalOnlyConversationDelete conversation.
                 * @member {signalservice.SyncMessage.DeleteForMe.IConversationIdentifier|null|undefined} conversation
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @instance
                 */
                LocalOnlyConversationDelete.prototype.conversation = null;

                /**
                 * Creates a new LocalOnlyConversationDelete instance using the specified properties.
                 * @function create
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.ILocalOnlyConversationDelete=} [properties] Properties to set
                 * @returns {signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete} LocalOnlyConversationDelete instance
                 */
                LocalOnlyConversationDelete.create = function create(properties) {
                    return new LocalOnlyConversationDelete(properties);
                };

                /**
                 * Encodes the specified LocalOnlyConversationDelete message. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.verify|verify} messages.
                 * @function encode
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.ILocalOnlyConversationDelete} message LocalOnlyConversationDelete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LocalOnlyConversationDelete.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.conversation != null && Object.hasOwnProperty.call(message, "conversation"))
                        $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.encode(message.conversation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LocalOnlyConversationDelete message, length delimited. Does not implicitly {@link signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.ILocalOnlyConversationDelete} message LocalOnlyConversationDelete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LocalOnlyConversationDelete.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LocalOnlyConversationDelete message from the specified reader or buffer.
                 * @function decode
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete} LocalOnlyConversationDelete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LocalOnlyConversationDelete.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LocalOnlyConversationDelete message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete} LocalOnlyConversationDelete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LocalOnlyConversationDelete.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LocalOnlyConversationDelete message.
                 * @function verify
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LocalOnlyConversationDelete.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.conversation != null && message.hasOwnProperty("conversation")) {
                        let error = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.verify(message.conversation);
                        if (error)
                            return "conversation." + error;
                    }
                    return null;
                };

                /**
                 * Creates a LocalOnlyConversationDelete message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete} LocalOnlyConversationDelete
                 */
                LocalOnlyConversationDelete.fromObject = function fromObject(object) {
                    if (object instanceof $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete)
                        return object;
                    let message = new $root.signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete();
                    if (object.conversation != null) {
                        if (typeof object.conversation !== "object")
                            throw TypeError(".signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete.conversation: object expected");
                        message.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.fromObject(object.conversation);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LocalOnlyConversationDelete message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete} message LocalOnlyConversationDelete
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LocalOnlyConversationDelete.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.conversation = null;
                    if (message.conversation != null && message.hasOwnProperty("conversation"))
                        object.conversation = $root.signalservice.SyncMessage.DeleteForMe.ConversationIdentifier.toObject(message.conversation, options);
                    return object;
                };

                /**
                 * Converts this LocalOnlyConversationDelete to JSON.
                 * @function toJSON
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LocalOnlyConversationDelete.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LocalOnlyConversationDelete
                 * @function getTypeUrl
                 * @memberof signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LocalOnlyConversationDelete.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/signalservice.SyncMessage.DeleteForMe.LocalOnlyConversationDelete";
                };

                return LocalOnlyConversationDelete;
            })();

            return DeleteForMe;
        })();

        return SyncMessage;
    })();

    signalservice.AttachmentPointer = (function() {

        /**
         * Properties of an AttachmentPointer.
         * @memberof signalservice
         * @interface IAttachmentPointer
         * @property {number|Long|null} [cdnId] AttachmentPointer cdnId
         * @property {string|null} [cdnKey] AttachmentPointer cdnKey
         * @property {Uint8Array|null} [clientUuid] AttachmentPointer clientUuid
         * @property {string|null} [contentType] AttachmentPointer contentType
         * @property {Uint8Array|null} [key] AttachmentPointer key
         * @property {number|null} [size] AttachmentPointer size
         * @property {Uint8Array|null} [thumbnail] AttachmentPointer thumbnail
         * @property {Uint8Array|null} [digest] AttachmentPointer digest
         * @property {Uint8Array|null} [incrementalMac] AttachmentPointer incrementalMac
         * @property {number|null} [chunkSize] AttachmentPointer chunkSize
         * @property {string|null} [fileName] AttachmentPointer fileName
         * @property {number|null} [flags] AttachmentPointer flags
         * @property {number|null} [width] AttachmentPointer width
         * @property {number|null} [height] AttachmentPointer height
         * @property {string|null} [caption] AttachmentPointer caption
         * @property {string|null} [blurHash] AttachmentPointer blurHash
         * @property {number|Long|null} [uploadTimestamp] AttachmentPointer uploadTimestamp
         * @property {number|null} [cdnNumber] AttachmentPointer cdnNumber
         */

        /**
         * Constructs a new AttachmentPointer.
         * @memberof signalservice
         * @classdesc Represents an AttachmentPointer.
         * @implements IAttachmentPointer
         * @constructor
         * @param {signalservice.IAttachmentPointer=} [properties] Properties to set
         */
        function AttachmentPointer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttachmentPointer cdnId.
         * @member {number|Long|null|undefined} cdnId
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.cdnId = null;

        /**
         * AttachmentPointer cdnKey.
         * @member {string|null|undefined} cdnKey
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.cdnKey = null;

        /**
         * AttachmentPointer clientUuid.
         * @member {Uint8Array} clientUuid
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.clientUuid = $util.newBuffer([]);

        /**
         * AttachmentPointer contentType.
         * @member {string} contentType
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.contentType = "";

        /**
         * AttachmentPointer key.
         * @member {Uint8Array} key
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.key = $util.newBuffer([]);

        /**
         * AttachmentPointer size.
         * @member {number} size
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.size = 0;

        /**
         * AttachmentPointer thumbnail.
         * @member {Uint8Array} thumbnail
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.thumbnail = $util.newBuffer([]);

        /**
         * AttachmentPointer digest.
         * @member {Uint8Array} digest
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.digest = $util.newBuffer([]);

        /**
         * AttachmentPointer incrementalMac.
         * @member {Uint8Array} incrementalMac
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.incrementalMac = $util.newBuffer([]);

        /**
         * AttachmentPointer chunkSize.
         * @member {number} chunkSize
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.chunkSize = 0;

        /**
         * AttachmentPointer fileName.
         * @member {string} fileName
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.fileName = "";

        /**
         * AttachmentPointer flags.
         * @member {number} flags
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.flags = 0;

        /**
         * AttachmentPointer width.
         * @member {number} width
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.width = 0;

        /**
         * AttachmentPointer height.
         * @member {number} height
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.height = 0;

        /**
         * AttachmentPointer caption.
         * @member {string} caption
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.caption = "";

        /**
         * AttachmentPointer blurHash.
         * @member {string} blurHash
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.blurHash = "";

        /**
         * AttachmentPointer uploadTimestamp.
         * @member {number|Long} uploadTimestamp
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.uploadTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AttachmentPointer cdnNumber.
         * @member {number} cdnNumber
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        AttachmentPointer.prototype.cdnNumber = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * AttachmentPointer attachmentIdentifier.
         * @member {"cdnId"|"cdnKey"|undefined} attachmentIdentifier
         * @memberof signalservice.AttachmentPointer
         * @instance
         */
        Object.defineProperty(AttachmentPointer.prototype, "attachmentIdentifier", {
            get: $util.oneOfGetter($oneOfFields = ["cdnId", "cdnKey"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AttachmentPointer instance using the specified properties.
         * @function create
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.IAttachmentPointer=} [properties] Properties to set
         * @returns {signalservice.AttachmentPointer} AttachmentPointer instance
         */
        AttachmentPointer.create = function create(properties) {
            return new AttachmentPointer(properties);
        };

        /**
         * Encodes the specified AttachmentPointer message. Does not implicitly {@link signalservice.AttachmentPointer.verify|verify} messages.
         * @function encode
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.IAttachmentPointer} message AttachmentPointer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttachmentPointer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cdnId != null && Object.hasOwnProperty.call(message, "cdnId"))
                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.cdnId);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);
            if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.thumbnail);
            if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.digest);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.height);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.caption);
            if (message.blurHash != null && Object.hasOwnProperty.call(message, "blurHash"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.blurHash);
            if (message.uploadTimestamp != null && Object.hasOwnProperty.call(message, "uploadTimestamp"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.uploadTimestamp);
            if (message.cdnNumber != null && Object.hasOwnProperty.call(message, "cdnNumber"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.cdnNumber);
            if (message.cdnKey != null && Object.hasOwnProperty.call(message, "cdnKey"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.cdnKey);
            if (message.chunkSize != null && Object.hasOwnProperty.call(message, "chunkSize"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.chunkSize);
            if (message.incrementalMac != null && Object.hasOwnProperty.call(message, "incrementalMac"))
                writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.incrementalMac);
            if (message.clientUuid != null && Object.hasOwnProperty.call(message, "clientUuid"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.clientUuid);
            return writer;
        };

        /**
         * Encodes the specified AttachmentPointer message, length delimited. Does not implicitly {@link signalservice.AttachmentPointer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.IAttachmentPointer} message AttachmentPointer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttachmentPointer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttachmentPointer message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.AttachmentPointer} AttachmentPointer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttachmentPointer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.AttachmentPointer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cdnId = reader.fixed64();
                        break;
                    }
                case 15: {
                        message.cdnKey = reader.string();
                        break;
                    }
                case 20: {
                        message.clientUuid = reader.bytes();
                        break;
                    }
                case 2: {
                        message.contentType = reader.string();
                        break;
                    }
                case 3: {
                        message.key = reader.bytes();
                        break;
                    }
                case 4: {
                        message.size = reader.uint32();
                        break;
                    }
                case 5: {
                        message.thumbnail = reader.bytes();
                        break;
                    }
                case 6: {
                        message.digest = reader.bytes();
                        break;
                    }
                case 19: {
                        message.incrementalMac = reader.bytes();
                        break;
                    }
                case 17: {
                        message.chunkSize = reader.uint32();
                        break;
                    }
                case 7: {
                        message.fileName = reader.string();
                        break;
                    }
                case 8: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 9: {
                        message.width = reader.uint32();
                        break;
                    }
                case 10: {
                        message.height = reader.uint32();
                        break;
                    }
                case 11: {
                        message.caption = reader.string();
                        break;
                    }
                case 12: {
                        message.blurHash = reader.string();
                        break;
                    }
                case 13: {
                        message.uploadTimestamp = reader.uint64();
                        break;
                    }
                case 14: {
                        message.cdnNumber = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttachmentPointer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.AttachmentPointer} AttachmentPointer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttachmentPointer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AttachmentPointer message.
         * @function verify
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AttachmentPointer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.cdnId != null && message.hasOwnProperty("cdnId")) {
                properties.attachmentIdentifier = 1;
                if (!$util.isInteger(message.cdnId) && !(message.cdnId && $util.isInteger(message.cdnId.low) && $util.isInteger(message.cdnId.high)))
                    return "cdnId: integer|Long expected";
            }
            if (message.cdnKey != null && message.hasOwnProperty("cdnKey")) {
                if (properties.attachmentIdentifier === 1)
                    return "attachmentIdentifier: multiple values";
                properties.attachmentIdentifier = 1;
                if (!$util.isString(message.cdnKey))
                    return "cdnKey: string expected";
            }
            if (message.clientUuid != null && message.hasOwnProperty("clientUuid"))
                if (!(message.clientUuid && typeof message.clientUuid.length === "number" || $util.isString(message.clientUuid)))
                    return "clientUuid: buffer expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                if (!$util.isString(message.contentType))
                    return "contentType: string expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                if (!(message.thumbnail && typeof message.thumbnail.length === "number" || $util.isString(message.thumbnail)))
                    return "thumbnail: buffer expected";
            if (message.digest != null && message.hasOwnProperty("digest"))
                if (!(message.digest && typeof message.digest.length === "number" || $util.isString(message.digest)))
                    return "digest: buffer expected";
            if (message.incrementalMac != null && message.hasOwnProperty("incrementalMac"))
                if (!(message.incrementalMac && typeof message.incrementalMac.length === "number" || $util.isString(message.incrementalMac)))
                    return "incrementalMac: buffer expected";
            if (message.chunkSize != null && message.hasOwnProperty("chunkSize"))
                if (!$util.isInteger(message.chunkSize))
                    return "chunkSize: integer expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.blurHash != null && message.hasOwnProperty("blurHash"))
                if (!$util.isString(message.blurHash))
                    return "blurHash: string expected";
            if (message.uploadTimestamp != null && message.hasOwnProperty("uploadTimestamp"))
                if (!$util.isInteger(message.uploadTimestamp) && !(message.uploadTimestamp && $util.isInteger(message.uploadTimestamp.low) && $util.isInteger(message.uploadTimestamp.high)))
                    return "uploadTimestamp: integer|Long expected";
            if (message.cdnNumber != null && message.hasOwnProperty("cdnNumber"))
                if (!$util.isInteger(message.cdnNumber))
                    return "cdnNumber: integer expected";
            return null;
        };

        /**
         * Creates an AttachmentPointer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.AttachmentPointer} AttachmentPointer
         */
        AttachmentPointer.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.AttachmentPointer)
                return object;
            let message = new $root.signalservice.AttachmentPointer();
            if (object.cdnId != null)
                if ($util.Long)
                    (message.cdnId = $util.Long.fromValue(object.cdnId)).unsigned = false;
                else if (typeof object.cdnId === "string")
                    message.cdnId = parseInt(object.cdnId, 10);
                else if (typeof object.cdnId === "number")
                    message.cdnId = object.cdnId;
                else if (typeof object.cdnId === "object")
                    message.cdnId = new $util.LongBits(object.cdnId.low >>> 0, object.cdnId.high >>> 0).toNumber();
            if (object.cdnKey != null)
                message.cdnKey = String(object.cdnKey);
            if (object.clientUuid != null)
                if (typeof object.clientUuid === "string")
                    $util.base64.decode(object.clientUuid, message.clientUuid = $util.newBuffer($util.base64.length(object.clientUuid)), 0);
                else if (object.clientUuid.length >= 0)
                    message.clientUuid = object.clientUuid;
            if (object.contentType != null)
                message.contentType = String(object.contentType);
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length >= 0)
                    message.key = object.key;
            if (object.size != null)
                message.size = object.size >>> 0;
            if (object.thumbnail != null)
                if (typeof object.thumbnail === "string")
                    $util.base64.decode(object.thumbnail, message.thumbnail = $util.newBuffer($util.base64.length(object.thumbnail)), 0);
                else if (object.thumbnail.length >= 0)
                    message.thumbnail = object.thumbnail;
            if (object.digest != null)
                if (typeof object.digest === "string")
                    $util.base64.decode(object.digest, message.digest = $util.newBuffer($util.base64.length(object.digest)), 0);
                else if (object.digest.length >= 0)
                    message.digest = object.digest;
            if (object.incrementalMac != null)
                if (typeof object.incrementalMac === "string")
                    $util.base64.decode(object.incrementalMac, message.incrementalMac = $util.newBuffer($util.base64.length(object.incrementalMac)), 0);
                else if (object.incrementalMac.length >= 0)
                    message.incrementalMac = object.incrementalMac;
            if (object.chunkSize != null)
                message.chunkSize = object.chunkSize >>> 0;
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.blurHash != null)
                message.blurHash = String(object.blurHash);
            if (object.uploadTimestamp != null)
                if ($util.Long)
                    (message.uploadTimestamp = $util.Long.fromValue(object.uploadTimestamp)).unsigned = true;
                else if (typeof object.uploadTimestamp === "string")
                    message.uploadTimestamp = parseInt(object.uploadTimestamp, 10);
                else if (typeof object.uploadTimestamp === "number")
                    message.uploadTimestamp = object.uploadTimestamp;
                else if (typeof object.uploadTimestamp === "object")
                    message.uploadTimestamp = new $util.LongBits(object.uploadTimestamp.low >>> 0, object.uploadTimestamp.high >>> 0).toNumber(true);
            if (object.cdnNumber != null)
                message.cdnNumber = object.cdnNumber >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an AttachmentPointer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {signalservice.AttachmentPointer} message AttachmentPointer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AttachmentPointer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.contentType = "";
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                object.size = 0;
                if (options.bytes === String)
                    object.thumbnail = "";
                else {
                    object.thumbnail = [];
                    if (options.bytes !== Array)
                        object.thumbnail = $util.newBuffer(object.thumbnail);
                }
                if (options.bytes === String)
                    object.digest = "";
                else {
                    object.digest = [];
                    if (options.bytes !== Array)
                        object.digest = $util.newBuffer(object.digest);
                }
                object.fileName = "";
                object.flags = 0;
                object.width = 0;
                object.height = 0;
                object.caption = "";
                object.blurHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.uploadTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uploadTimestamp = options.longs === String ? "0" : 0;
                object.cdnNumber = 0;
                object.chunkSize = 0;
                if (options.bytes === String)
                    object.incrementalMac = "";
                else {
                    object.incrementalMac = [];
                    if (options.bytes !== Array)
                        object.incrementalMac = $util.newBuffer(object.incrementalMac);
                }
                if (options.bytes === String)
                    object.clientUuid = "";
                else {
                    object.clientUuid = [];
                    if (options.bytes !== Array)
                        object.clientUuid = $util.newBuffer(object.clientUuid);
                }
            }
            if (message.cdnId != null && message.hasOwnProperty("cdnId")) {
                if (typeof message.cdnId === "number")
                    object.cdnId = options.longs === String ? String(message.cdnId) : message.cdnId;
                else
                    object.cdnId = options.longs === String ? $util.Long.prototype.toString.call(message.cdnId) : options.longs === Number ? new $util.LongBits(message.cdnId.low >>> 0, message.cdnId.high >>> 0).toNumber() : message.cdnId;
                if (options.oneofs)
                    object.attachmentIdentifier = "cdnId";
            }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                object.thumbnail = options.bytes === String ? $util.base64.encode(message.thumbnail, 0, message.thumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnail) : message.thumbnail;
            if (message.digest != null && message.hasOwnProperty("digest"))
                object.digest = options.bytes === String ? $util.base64.encode(message.digest, 0, message.digest.length) : options.bytes === Array ? Array.prototype.slice.call(message.digest) : message.digest;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.blurHash != null && message.hasOwnProperty("blurHash"))
                object.blurHash = message.blurHash;
            if (message.uploadTimestamp != null && message.hasOwnProperty("uploadTimestamp"))
                if (typeof message.uploadTimestamp === "number")
                    object.uploadTimestamp = options.longs === String ? String(message.uploadTimestamp) : message.uploadTimestamp;
                else
                    object.uploadTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.uploadTimestamp) : options.longs === Number ? new $util.LongBits(message.uploadTimestamp.low >>> 0, message.uploadTimestamp.high >>> 0).toNumber(true) : message.uploadTimestamp;
            if (message.cdnNumber != null && message.hasOwnProperty("cdnNumber"))
                object.cdnNumber = message.cdnNumber;
            if (message.cdnKey != null && message.hasOwnProperty("cdnKey")) {
                object.cdnKey = message.cdnKey;
                if (options.oneofs)
                    object.attachmentIdentifier = "cdnKey";
            }
            if (message.chunkSize != null && message.hasOwnProperty("chunkSize"))
                object.chunkSize = message.chunkSize;
            if (message.incrementalMac != null && message.hasOwnProperty("incrementalMac"))
                object.incrementalMac = options.bytes === String ? $util.base64.encode(message.incrementalMac, 0, message.incrementalMac.length) : options.bytes === Array ? Array.prototype.slice.call(message.incrementalMac) : message.incrementalMac;
            if (message.clientUuid != null && message.hasOwnProperty("clientUuid"))
                object.clientUuid = options.bytes === String ? $util.base64.encode(message.clientUuid, 0, message.clientUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientUuid) : message.clientUuid;
            return object;
        };

        /**
         * Converts this AttachmentPointer to JSON.
         * @function toJSON
         * @memberof signalservice.AttachmentPointer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AttachmentPointer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AttachmentPointer
         * @function getTypeUrl
         * @memberof signalservice.AttachmentPointer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AttachmentPointer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.AttachmentPointer";
        };

        /**
         * Flags enum.
         * @name signalservice.AttachmentPointer.Flags
         * @enum {number}
         * @property {number} VOICE_MESSAGE=1 VOICE_MESSAGE value
         * @property {number} BORDERLESS=2 BORDERLESS value
         * @property {number} GIF=8 GIF value
         */
        AttachmentPointer.Flags = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "VOICE_MESSAGE"] = 1;
            values[valuesById[2] = "BORDERLESS"] = 2;
            values[valuesById[8] = "GIF"] = 8;
            return values;
        })();

        return AttachmentPointer;
    })();

    signalservice.GroupContextV2 = (function() {

        /**
         * Properties of a GroupContextV2.
         * @memberof signalservice
         * @interface IGroupContextV2
         * @property {Uint8Array|null} [masterKey] GroupContextV2 masterKey
         * @property {number|null} [revision] GroupContextV2 revision
         * @property {Uint8Array|null} [groupChange] GroupContextV2 groupChange
         */

        /**
         * Constructs a new GroupContextV2.
         * @memberof signalservice
         * @classdesc Represents a GroupContextV2.
         * @implements IGroupContextV2
         * @constructor
         * @param {signalservice.IGroupContextV2=} [properties] Properties to set
         */
        function GroupContextV2(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupContextV2 masterKey.
         * @member {Uint8Array} masterKey
         * @memberof signalservice.GroupContextV2
         * @instance
         */
        GroupContextV2.prototype.masterKey = $util.newBuffer([]);

        /**
         * GroupContextV2 revision.
         * @member {number} revision
         * @memberof signalservice.GroupContextV2
         * @instance
         */
        GroupContextV2.prototype.revision = 0;

        /**
         * GroupContextV2 groupChange.
         * @member {Uint8Array} groupChange
         * @memberof signalservice.GroupContextV2
         * @instance
         */
        GroupContextV2.prototype.groupChange = $util.newBuffer([]);

        /**
         * Creates a new GroupContextV2 instance using the specified properties.
         * @function create
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.IGroupContextV2=} [properties] Properties to set
         * @returns {signalservice.GroupContextV2} GroupContextV2 instance
         */
        GroupContextV2.create = function create(properties) {
            return new GroupContextV2(properties);
        };

        /**
         * Encodes the specified GroupContextV2 message. Does not implicitly {@link signalservice.GroupContextV2.verify|verify} messages.
         * @function encode
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.IGroupContextV2} message GroupContextV2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupContextV2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.masterKey != null && Object.hasOwnProperty.call(message, "masterKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.masterKey);
            if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.revision);
            if (message.groupChange != null && Object.hasOwnProperty.call(message, "groupChange"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupChange);
            return writer;
        };

        /**
         * Encodes the specified GroupContextV2 message, length delimited. Does not implicitly {@link signalservice.GroupContextV2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.IGroupContextV2} message GroupContextV2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupContextV2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupContextV2 message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.GroupContextV2} GroupContextV2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupContextV2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.GroupContextV2();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.masterKey = reader.bytes();
                        break;
                    }
                case 2: {
                        message.revision = reader.uint32();
                        break;
                    }
                case 3: {
                        message.groupChange = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupContextV2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.GroupContextV2} GroupContextV2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupContextV2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupContextV2 message.
         * @function verify
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupContextV2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.masterKey != null && message.hasOwnProperty("masterKey"))
                if (!(message.masterKey && typeof message.masterKey.length === "number" || $util.isString(message.masterKey)))
                    return "masterKey: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision))
                    return "revision: integer expected";
            if (message.groupChange != null && message.hasOwnProperty("groupChange"))
                if (!(message.groupChange && typeof message.groupChange.length === "number" || $util.isString(message.groupChange)))
                    return "groupChange: buffer expected";
            return null;
        };

        /**
         * Creates a GroupContextV2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.GroupContextV2} GroupContextV2
         */
        GroupContextV2.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.GroupContextV2)
                return object;
            let message = new $root.signalservice.GroupContextV2();
            if (object.masterKey != null)
                if (typeof object.masterKey === "string")
                    $util.base64.decode(object.masterKey, message.masterKey = $util.newBuffer($util.base64.length(object.masterKey)), 0);
                else if (object.masterKey.length >= 0)
                    message.masterKey = object.masterKey;
            if (object.revision != null)
                message.revision = object.revision >>> 0;
            if (object.groupChange != null)
                if (typeof object.groupChange === "string")
                    $util.base64.decode(object.groupChange, message.groupChange = $util.newBuffer($util.base64.length(object.groupChange)), 0);
                else if (object.groupChange.length >= 0)
                    message.groupChange = object.groupChange;
            return message;
        };

        /**
         * Creates a plain object from a GroupContextV2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {signalservice.GroupContextV2} message GroupContextV2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupContextV2.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.masterKey = "";
                else {
                    object.masterKey = [];
                    if (options.bytes !== Array)
                        object.masterKey = $util.newBuffer(object.masterKey);
                }
                object.revision = 0;
                if (options.bytes === String)
                    object.groupChange = "";
                else {
                    object.groupChange = [];
                    if (options.bytes !== Array)
                        object.groupChange = $util.newBuffer(object.groupChange);
                }
            }
            if (message.masterKey != null && message.hasOwnProperty("masterKey"))
                object.masterKey = options.bytes === String ? $util.base64.encode(message.masterKey, 0, message.masterKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.masterKey) : message.masterKey;
            if (message.revision != null && message.hasOwnProperty("revision"))
                object.revision = message.revision;
            if (message.groupChange != null && message.hasOwnProperty("groupChange"))
                object.groupChange = options.bytes === String ? $util.base64.encode(message.groupChange, 0, message.groupChange.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupChange) : message.groupChange;
            return object;
        };

        /**
         * Converts this GroupContextV2 to JSON.
         * @function toJSON
         * @memberof signalservice.GroupContextV2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupContextV2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupContextV2
         * @function getTypeUrl
         * @memberof signalservice.GroupContextV2
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupContextV2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.GroupContextV2";
        };

        return GroupContextV2;
    })();

    signalservice.ContactDetails = (function() {

        /**
         * Properties of a ContactDetails.
         * @memberof signalservice
         * @interface IContactDetails
         * @property {string|null} [number] ContactDetails number
         * @property {string|null} [aci] ContactDetails aci
         * @property {string|null} [name] ContactDetails name
         * @property {signalservice.ContactDetails.IAvatar|null} [avatar] ContactDetails avatar
         * @property {number|null} [expireTimer] ContactDetails expireTimer
         * @property {number|null} [inboxPosition] ContactDetails inboxPosition
         */

        /**
         * Constructs a new ContactDetails.
         * @memberof signalservice
         * @classdesc Represents a ContactDetails.
         * @implements IContactDetails
         * @constructor
         * @param {signalservice.IContactDetails=} [properties] Properties to set
         */
        function ContactDetails(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactDetails number.
         * @member {string} number
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.number = "";

        /**
         * ContactDetails aci.
         * @member {string} aci
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.aci = "";

        /**
         * ContactDetails name.
         * @member {string} name
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.name = "";

        /**
         * ContactDetails avatar.
         * @member {signalservice.ContactDetails.IAvatar|null|undefined} avatar
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.avatar = null;

        /**
         * ContactDetails expireTimer.
         * @member {number} expireTimer
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.expireTimer = 0;

        /**
         * ContactDetails inboxPosition.
         * @member {number} inboxPosition
         * @memberof signalservice.ContactDetails
         * @instance
         */
        ContactDetails.prototype.inboxPosition = 0;

        /**
         * Creates a new ContactDetails instance using the specified properties.
         * @function create
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.IContactDetails=} [properties] Properties to set
         * @returns {signalservice.ContactDetails} ContactDetails instance
         */
        ContactDetails.create = function create(properties) {
            return new ContactDetails(properties);
        };

        /**
         * Encodes the specified ContactDetails message. Does not implicitly {@link signalservice.ContactDetails.verify|verify} messages.
         * @function encode
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.IContactDetails} message ContactDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.number);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.signalservice.ContactDetails.Avatar.encode(message.avatar, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.expireTimer != null && Object.hasOwnProperty.call(message, "expireTimer"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expireTimer);
            if (message.aci != null && Object.hasOwnProperty.call(message, "aci"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.aci);
            if (message.inboxPosition != null && Object.hasOwnProperty.call(message, "inboxPosition"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.inboxPosition);
            return writer;
        };

        /**
         * Encodes the specified ContactDetails message, length delimited. Does not implicitly {@link signalservice.ContactDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.IContactDetails} message ContactDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactDetails message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.ContactDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.ContactDetails} ContactDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ContactDetails();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.number = reader.string();
                        break;
                    }
                case 9: {
                        message.aci = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.avatar = $root.signalservice.ContactDetails.Avatar.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.expireTimer = reader.uint32();
                        break;
                    }
                case 10: {
                        message.inboxPosition = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.ContactDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.ContactDetails} ContactDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactDetails message.
         * @function verify
         * @memberof signalservice.ContactDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isString(message.number))
                    return "number: string expected";
            if (message.aci != null && message.hasOwnProperty("aci"))
                if (!$util.isString(message.aci))
                    return "aci: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                let error = $root.signalservice.ContactDetails.Avatar.verify(message.avatar);
                if (error)
                    return "avatar." + error;
            }
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                if (!$util.isInteger(message.expireTimer))
                    return "expireTimer: integer expected";
            if (message.inboxPosition != null && message.hasOwnProperty("inboxPosition"))
                if (!$util.isInteger(message.inboxPosition))
                    return "inboxPosition: integer expected";
            return null;
        };

        /**
         * Creates a ContactDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.ContactDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.ContactDetails} ContactDetails
         */
        ContactDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.ContactDetails)
                return object;
            let message = new $root.signalservice.ContactDetails();
            if (object.number != null)
                message.number = String(object.number);
            if (object.aci != null)
                message.aci = String(object.aci);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".signalservice.ContactDetails.avatar: object expected");
                message.avatar = $root.signalservice.ContactDetails.Avatar.fromObject(object.avatar);
            }
            if (object.expireTimer != null)
                message.expireTimer = object.expireTimer >>> 0;
            if (object.inboxPosition != null)
                message.inboxPosition = object.inboxPosition >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ContactDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.ContactDetails
         * @static
         * @param {signalservice.ContactDetails} message ContactDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.number = "";
                object.name = "";
                object.avatar = null;
                object.expireTimer = 0;
                object.aci = "";
                object.inboxPosition = 0;
            }
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = $root.signalservice.ContactDetails.Avatar.toObject(message.avatar, options);
            if (message.expireTimer != null && message.hasOwnProperty("expireTimer"))
                object.expireTimer = message.expireTimer;
            if (message.aci != null && message.hasOwnProperty("aci"))
                object.aci = message.aci;
            if (message.inboxPosition != null && message.hasOwnProperty("inboxPosition"))
                object.inboxPosition = message.inboxPosition;
            return object;
        };

        /**
         * Converts this ContactDetails to JSON.
         * @function toJSON
         * @memberof signalservice.ContactDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContactDetails
         * @function getTypeUrl
         * @memberof signalservice.ContactDetails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContactDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.ContactDetails";
        };

        ContactDetails.Avatar = (function() {

            /**
             * Properties of an Avatar.
             * @memberof signalservice.ContactDetails
             * @interface IAvatar
             * @property {string|null} [contentType] Avatar contentType
             * @property {number|null} [length] Avatar length
             */

            /**
             * Constructs a new Avatar.
             * @memberof signalservice.ContactDetails
             * @classdesc Represents an Avatar.
             * @implements IAvatar
             * @constructor
             * @param {signalservice.ContactDetails.IAvatar=} [properties] Properties to set
             */
            function Avatar(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Avatar contentType.
             * @member {string} contentType
             * @memberof signalservice.ContactDetails.Avatar
             * @instance
             */
            Avatar.prototype.contentType = "";

            /**
             * Avatar length.
             * @member {number} length
             * @memberof signalservice.ContactDetails.Avatar
             * @instance
             */
            Avatar.prototype.length = 0;

            /**
             * Creates a new Avatar instance using the specified properties.
             * @function create
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.IAvatar=} [properties] Properties to set
             * @returns {signalservice.ContactDetails.Avatar} Avatar instance
             */
            Avatar.create = function create(properties) {
                return new Avatar(properties);
            };

            /**
             * Encodes the specified Avatar message. Does not implicitly {@link signalservice.ContactDetails.Avatar.verify|verify} messages.
             * @function encode
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.IAvatar} message Avatar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Avatar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.length);
                return writer;
            };

            /**
             * Encodes the specified Avatar message, length delimited. Does not implicitly {@link signalservice.ContactDetails.Avatar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.IAvatar} message Avatar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Avatar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Avatar message from the specified reader or buffer.
             * @function decode
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {signalservice.ContactDetails.Avatar} Avatar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Avatar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.ContactDetails.Avatar();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contentType = reader.string();
                            break;
                        }
                    case 2: {
                            message.length = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Avatar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {signalservice.ContactDetails.Avatar} Avatar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Avatar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Avatar message.
             * @function verify
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Avatar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                return null;
            };

            /**
             * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {signalservice.ContactDetails.Avatar} Avatar
             */
            Avatar.fromObject = function fromObject(object) {
                if (object instanceof $root.signalservice.ContactDetails.Avatar)
                    return object;
                let message = new $root.signalservice.ContactDetails.Avatar();
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.length != null)
                    message.length = object.length >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an Avatar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {signalservice.ContactDetails.Avatar} message Avatar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Avatar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contentType = "";
                    object.length = 0;
                }
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                return object;
            };

            /**
             * Converts this Avatar to JSON.
             * @function toJSON
             * @memberof signalservice.ContactDetails.Avatar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Avatar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Avatar
             * @function getTypeUrl
             * @memberof signalservice.ContactDetails.Avatar
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Avatar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/signalservice.ContactDetails.Avatar";
            };

            return Avatar;
        })();

        return ContactDetails;
    })();

    signalservice.PniSignatureMessage = (function() {

        /**
         * Properties of a PniSignatureMessage.
         * @memberof signalservice
         * @interface IPniSignatureMessage
         * @property {Uint8Array|null} [pni] PniSignatureMessage pni
         * @property {Uint8Array|null} [signature] PniSignatureMessage signature
         */

        /**
         * Constructs a new PniSignatureMessage.
         * @memberof signalservice
         * @classdesc Represents a PniSignatureMessage.
         * @implements IPniSignatureMessage
         * @constructor
         * @param {signalservice.IPniSignatureMessage=} [properties] Properties to set
         */
        function PniSignatureMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PniSignatureMessage pni.
         * @member {Uint8Array} pni
         * @memberof signalservice.PniSignatureMessage
         * @instance
         */
        PniSignatureMessage.prototype.pni = $util.newBuffer([]);

        /**
         * PniSignatureMessage signature.
         * @member {Uint8Array} signature
         * @memberof signalservice.PniSignatureMessage
         * @instance
         */
        PniSignatureMessage.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new PniSignatureMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.IPniSignatureMessage=} [properties] Properties to set
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage instance
         */
        PniSignatureMessage.create = function create(properties) {
            return new PniSignatureMessage(properties);
        };

        /**
         * Encodes the specified PniSignatureMessage message. Does not implicitly {@link signalservice.PniSignatureMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.IPniSignatureMessage} message PniSignatureMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PniSignatureMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pni != null && Object.hasOwnProperty.call(message, "pni"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pni);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified PniSignatureMessage message, length delimited. Does not implicitly {@link signalservice.PniSignatureMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.IPniSignatureMessage} message PniSignatureMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PniSignatureMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PniSignatureMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PniSignatureMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.PniSignatureMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pni = reader.bytes();
                        break;
                    }
                case 2: {
                        message.signature = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PniSignatureMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PniSignatureMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PniSignatureMessage message.
         * @function verify
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PniSignatureMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pni != null && message.hasOwnProperty("pni"))
                if (!(message.pni && typeof message.pni.length === "number" || $util.isString(message.pni)))
                    return "pni: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a PniSignatureMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.PniSignatureMessage} PniSignatureMessage
         */
        PniSignatureMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.PniSignatureMessage)
                return object;
            let message = new $root.signalservice.PniSignatureMessage();
            if (object.pni != null)
                if (typeof object.pni === "string")
                    $util.base64.decode(object.pni, message.pni = $util.newBuffer($util.base64.length(object.pni)), 0);
                else if (object.pni.length >= 0)
                    message.pni = object.pni;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length >= 0)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a PniSignatureMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {signalservice.PniSignatureMessage} message PniSignatureMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PniSignatureMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.pni = "";
                else {
                    object.pni = [];
                    if (options.bytes !== Array)
                        object.pni = $util.newBuffer(object.pni);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.pni != null && message.hasOwnProperty("pni"))
                object.pni = options.bytes === String ? $util.base64.encode(message.pni, 0, message.pni.length) : options.bytes === Array ? Array.prototype.slice.call(message.pni) : message.pni;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this PniSignatureMessage to JSON.
         * @function toJSON
         * @memberof signalservice.PniSignatureMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PniSignatureMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PniSignatureMessage
         * @function getTypeUrl
         * @memberof signalservice.PniSignatureMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PniSignatureMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.PniSignatureMessage";
        };

        return PniSignatureMessage;
    })();

    signalservice.EditMessage = (function() {

        /**
         * Properties of an EditMessage.
         * @memberof signalservice
         * @interface IEditMessage
         * @property {number|Long|null} [targetSentTimestamp] EditMessage targetSentTimestamp
         * @property {signalservice.IDataMessage|null} [dataMessage] EditMessage dataMessage
         */

        /**
         * Constructs a new EditMessage.
         * @memberof signalservice
         * @classdesc Represents an EditMessage.
         * @implements IEditMessage
         * @constructor
         * @param {signalservice.IEditMessage=} [properties] Properties to set
         */
        function EditMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EditMessage targetSentTimestamp.
         * @member {number|Long} targetSentTimestamp
         * @memberof signalservice.EditMessage
         * @instance
         */
        EditMessage.prototype.targetSentTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EditMessage dataMessage.
         * @member {signalservice.IDataMessage|null|undefined} dataMessage
         * @memberof signalservice.EditMessage
         * @instance
         */
        EditMessage.prototype.dataMessage = null;

        /**
         * Creates a new EditMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.EditMessage
         * @static
         * @param {signalservice.IEditMessage=} [properties] Properties to set
         * @returns {signalservice.EditMessage} EditMessage instance
         */
        EditMessage.create = function create(properties) {
            return new EditMessage(properties);
        };

        /**
         * Encodes the specified EditMessage message. Does not implicitly {@link signalservice.EditMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.EditMessage
         * @static
         * @param {signalservice.IEditMessage} message EditMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetSentTimestamp != null && Object.hasOwnProperty.call(message, "targetSentTimestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.targetSentTimestamp);
            if (message.dataMessage != null && Object.hasOwnProperty.call(message, "dataMessage"))
                $root.signalservice.DataMessage.encode(message.dataMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EditMessage message, length delimited. Does not implicitly {@link signalservice.EditMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.EditMessage
         * @static
         * @param {signalservice.IEditMessage} message EditMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EditMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.EditMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.EditMessage} EditMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.EditMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetSentTimestamp = reader.uint64();
                        break;
                    }
                case 2: {
                        message.dataMessage = $root.signalservice.DataMessage.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EditMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.EditMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.EditMessage} EditMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EditMessage message.
         * @function verify
         * @memberof signalservice.EditMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EditMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetSentTimestamp != null && message.hasOwnProperty("targetSentTimestamp"))
                if (!$util.isInteger(message.targetSentTimestamp) && !(message.targetSentTimestamp && $util.isInteger(message.targetSentTimestamp.low) && $util.isInteger(message.targetSentTimestamp.high)))
                    return "targetSentTimestamp: integer|Long expected";
            if (message.dataMessage != null && message.hasOwnProperty("dataMessage")) {
                let error = $root.signalservice.DataMessage.verify(message.dataMessage);
                if (error)
                    return "dataMessage." + error;
            }
            return null;
        };

        /**
         * Creates an EditMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.EditMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.EditMessage} EditMessage
         */
        EditMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.EditMessage)
                return object;
            let message = new $root.signalservice.EditMessage();
            if (object.targetSentTimestamp != null)
                if ($util.Long)
                    (message.targetSentTimestamp = $util.Long.fromValue(object.targetSentTimestamp)).unsigned = true;
                else if (typeof object.targetSentTimestamp === "string")
                    message.targetSentTimestamp = parseInt(object.targetSentTimestamp, 10);
                else if (typeof object.targetSentTimestamp === "number")
                    message.targetSentTimestamp = object.targetSentTimestamp;
                else if (typeof object.targetSentTimestamp === "object")
                    message.targetSentTimestamp = new $util.LongBits(object.targetSentTimestamp.low >>> 0, object.targetSentTimestamp.high >>> 0).toNumber(true);
            if (object.dataMessage != null) {
                if (typeof object.dataMessage !== "object")
                    throw TypeError(".signalservice.EditMessage.dataMessage: object expected");
                message.dataMessage = $root.signalservice.DataMessage.fromObject(object.dataMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from an EditMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.EditMessage
         * @static
         * @param {signalservice.EditMessage} message EditMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EditMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.targetSentTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.targetSentTimestamp = options.longs === String ? "0" : 0;
                object.dataMessage = null;
            }
            if (message.targetSentTimestamp != null && message.hasOwnProperty("targetSentTimestamp"))
                if (typeof message.targetSentTimestamp === "number")
                    object.targetSentTimestamp = options.longs === String ? String(message.targetSentTimestamp) : message.targetSentTimestamp;
                else
                    object.targetSentTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.targetSentTimestamp) : options.longs === Number ? new $util.LongBits(message.targetSentTimestamp.low >>> 0, message.targetSentTimestamp.high >>> 0).toNumber(true) : message.targetSentTimestamp;
            if (message.dataMessage != null && message.hasOwnProperty("dataMessage"))
                object.dataMessage = $root.signalservice.DataMessage.toObject(message.dataMessage, options);
            return object;
        };

        /**
         * Converts this EditMessage to JSON.
         * @function toJSON
         * @memberof signalservice.EditMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EditMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EditMessage
         * @function getTypeUrl
         * @memberof signalservice.EditMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EditMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.EditMessage";
        };

        return EditMessage;
    })();

    signalservice.WebSocketRequestMessage = (function() {

        /**
         * Properties of a WebSocketRequestMessage.
         * @memberof signalservice
         * @interface IWebSocketRequestMessage
         * @property {string|null} [verb] WebSocketRequestMessage verb
         * @property {string|null} [path] WebSocketRequestMessage path
         * @property {Uint8Array|null} [body] WebSocketRequestMessage body
         * @property {Array.<string>|null} [headers] WebSocketRequestMessage headers
         * @property {number|Long|null} [id] WebSocketRequestMessage id
         */

        /**
         * Constructs a new WebSocketRequestMessage.
         * @memberof signalservice
         * @classdesc Represents a WebSocketRequestMessage.
         * @implements IWebSocketRequestMessage
         * @constructor
         * @param {signalservice.IWebSocketRequestMessage=} [properties] Properties to set
         */
        function WebSocketRequestMessage(properties) {
            this.headers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebSocketRequestMessage verb.
         * @member {string} verb
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.verb = "";

        /**
         * WebSocketRequestMessage path.
         * @member {string} path
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.path = "";

        /**
         * WebSocketRequestMessage body.
         * @member {Uint8Array} body
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.body = $util.newBuffer([]);

        /**
         * WebSocketRequestMessage headers.
         * @member {Array.<string>} headers
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.headers = $util.emptyArray;

        /**
         * WebSocketRequestMessage id.
         * @member {number|Long} id
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         */
        WebSocketRequestMessage.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new WebSocketRequestMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.IWebSocketRequestMessage=} [properties] Properties to set
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage instance
         */
        WebSocketRequestMessage.create = function create(properties) {
            return new WebSocketRequestMessage(properties);
        };

        /**
         * Encodes the specified WebSocketRequestMessage message. Does not implicitly {@link signalservice.WebSocketRequestMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.IWebSocketRequestMessage} message WebSocketRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketRequestMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.verb != null && Object.hasOwnProperty.call(message, "verb"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.verb);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.body);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.id);
            if (message.headers != null && message.headers.length)
                for (let i = 0; i < message.headers.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.headers[i]);
            return writer;
        };

        /**
         * Encodes the specified WebSocketRequestMessage message, length delimited. Does not implicitly {@link signalservice.WebSocketRequestMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.IWebSocketRequestMessage} message WebSocketRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebSocketRequestMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketRequestMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WebSocketRequestMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.verb = reader.string();
                        break;
                    }
                case 2: {
                        message.path = reader.string();
                        break;
                    }
                case 3: {
                        message.body = reader.bytes();
                        break;
                    }
                case 5: {
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push(reader.string());
                        break;
                    }
                case 4: {
                        message.id = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebSocketRequestMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketRequestMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebSocketRequestMessage message.
         * @function verify
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebSocketRequestMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.verb != null && message.hasOwnProperty("verb"))
                if (!$util.isString(message.verb))
                    return "verb: string expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            if (message.headers != null && message.hasOwnProperty("headers")) {
                if (!Array.isArray(message.headers))
                    return "headers: array expected";
                for (let i = 0; i < message.headers.length; ++i)
                    if (!$util.isString(message.headers[i]))
                        return "headers: string[] expected";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a WebSocketRequestMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WebSocketRequestMessage} WebSocketRequestMessage
         */
        WebSocketRequestMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WebSocketRequestMessage)
                return object;
            let message = new $root.signalservice.WebSocketRequestMessage();
            if (object.verb != null)
                message.verb = String(object.verb);
            if (object.path != null)
                message.path = String(object.path);
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length >= 0)
                    message.body = object.body;
            if (object.headers) {
                if (!Array.isArray(object.headers))
                    throw TypeError(".signalservice.WebSocketRequestMessage.headers: array expected");
                message.headers = [];
                for (let i = 0; i < object.headers.length; ++i)
                    message.headers[i] = String(object.headers[i]);
            }
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a WebSocketRequestMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {signalservice.WebSocketRequestMessage} message WebSocketRequestMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebSocketRequestMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.headers = [];
            if (options.defaults) {
                object.verb = "";
                object.path = "";
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            }
            if (message.verb != null && message.hasOwnProperty("verb"))
                object.verb = message.verb;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.headers && message.headers.length) {
                object.headers = [];
                for (let j = 0; j < message.headers.length; ++j)
                    object.headers[j] = message.headers[j];
            }
            return object;
        };

        /**
         * Converts this WebSocketRequestMessage to JSON.
         * @function toJSON
         * @memberof signalservice.WebSocketRequestMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebSocketRequestMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WebSocketRequestMessage
         * @function getTypeUrl
         * @memberof signalservice.WebSocketRequestMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WebSocketRequestMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.WebSocketRequestMessage";
        };

        return WebSocketRequestMessage;
    })();

    signalservice.WebSocketResponseMessage = (function() {

        /**
         * Properties of a WebSocketResponseMessage.
         * @memberof signalservice
         * @interface IWebSocketResponseMessage
         * @property {number|Long|null} [id] WebSocketResponseMessage id
         * @property {number|null} [status] WebSocketResponseMessage status
         * @property {string|null} [message] WebSocketResponseMessage message
         * @property {Array.<string>|null} [headers] WebSocketResponseMessage headers
         * @property {Uint8Array|null} [body] WebSocketResponseMessage body
         */

        /**
         * Constructs a new WebSocketResponseMessage.
         * @memberof signalservice
         * @classdesc Represents a WebSocketResponseMessage.
         * @implements IWebSocketResponseMessage
         * @constructor
         * @param {signalservice.IWebSocketResponseMessage=} [properties] Properties to set
         */
        function WebSocketResponseMessage(properties) {
            this.headers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebSocketResponseMessage id.
         * @member {number|Long} id
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebSocketResponseMessage status.
         * @member {number} status
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.status = 0;

        /**
         * WebSocketResponseMessage message.
         * @member {string} message
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.message = "";

        /**
         * WebSocketResponseMessage headers.
         * @member {Array.<string>} headers
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.headers = $util.emptyArray;

        /**
         * WebSocketResponseMessage body.
         * @member {Uint8Array} body
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         */
        WebSocketResponseMessage.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new WebSocketResponseMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.IWebSocketResponseMessage=} [properties] Properties to set
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage instance
         */
        WebSocketResponseMessage.create = function create(properties) {
            return new WebSocketResponseMessage(properties);
        };

        /**
         * Encodes the specified WebSocketResponseMessage message. Does not implicitly {@link signalservice.WebSocketResponseMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.IWebSocketResponseMessage} message WebSocketResponseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketResponseMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.status);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.body);
            if (message.headers != null && message.headers.length)
                for (let i = 0; i < message.headers.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.headers[i]);
            return writer;
        };

        /**
         * Encodes the specified WebSocketResponseMessage message, length delimited. Does not implicitly {@link signalservice.WebSocketResponseMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.IWebSocketResponseMessage} message WebSocketResponseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebSocketResponseMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketResponseMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WebSocketResponseMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint64();
                        break;
                    }
                case 2: {
                        message.status = reader.uint32();
                        break;
                    }
                case 3: {
                        message.message = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push(reader.string());
                        break;
                    }
                case 4: {
                        message.body = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebSocketResponseMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketResponseMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebSocketResponseMessage message.
         * @function verify
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebSocketResponseMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.headers != null && message.hasOwnProperty("headers")) {
                if (!Array.isArray(message.headers))
                    return "headers: array expected";
                for (let i = 0; i < message.headers.length; ++i)
                    if (!$util.isString(message.headers[i]))
                        return "headers: string[] expected";
            }
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a WebSocketResponseMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WebSocketResponseMessage} WebSocketResponseMessage
         */
        WebSocketResponseMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WebSocketResponseMessage)
                return object;
            let message = new $root.signalservice.WebSocketResponseMessage();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            if (object.status != null)
                message.status = object.status >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            if (object.headers) {
                if (!Array.isArray(object.headers))
                    throw TypeError(".signalservice.WebSocketResponseMessage.headers: array expected");
                message.headers = [];
                for (let i = 0; i < object.headers.length; ++i)
                    message.headers[i] = String(object.headers[i]);
            }
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length >= 0)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a WebSocketResponseMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {signalservice.WebSocketResponseMessage} message WebSocketResponseMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebSocketResponseMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.headers = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.status = 0;
                object.message = "";
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            if (message.headers && message.headers.length) {
                object.headers = [];
                for (let j = 0; j < message.headers.length; ++j)
                    object.headers[j] = message.headers[j];
            }
            return object;
        };

        /**
         * Converts this WebSocketResponseMessage to JSON.
         * @function toJSON
         * @memberof signalservice.WebSocketResponseMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebSocketResponseMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WebSocketResponseMessage
         * @function getTypeUrl
         * @memberof signalservice.WebSocketResponseMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WebSocketResponseMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.WebSocketResponseMessage";
        };

        return WebSocketResponseMessage;
    })();

    signalservice.WebSocketMessage = (function() {

        /**
         * Properties of a WebSocketMessage.
         * @memberof signalservice
         * @interface IWebSocketMessage
         * @property {signalservice.WebSocketMessage.Type|null} [type] WebSocketMessage type
         * @property {signalservice.IWebSocketRequestMessage|null} [request] WebSocketMessage request
         * @property {signalservice.IWebSocketResponseMessage|null} [response] WebSocketMessage response
         */

        /**
         * Constructs a new WebSocketMessage.
         * @memberof signalservice
         * @classdesc Represents a WebSocketMessage.
         * @implements IWebSocketMessage
         * @constructor
         * @param {signalservice.IWebSocketMessage=} [properties] Properties to set
         */
        function WebSocketMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebSocketMessage type.
         * @member {signalservice.WebSocketMessage.Type} type
         * @memberof signalservice.WebSocketMessage
         * @instance
         */
        WebSocketMessage.prototype.type = 0;

        /**
         * WebSocketMessage request.
         * @member {signalservice.IWebSocketRequestMessage|null|undefined} request
         * @memberof signalservice.WebSocketMessage
         * @instance
         */
        WebSocketMessage.prototype.request = null;

        /**
         * WebSocketMessage response.
         * @member {signalservice.IWebSocketResponseMessage|null|undefined} response
         * @memberof signalservice.WebSocketMessage
         * @instance
         */
        WebSocketMessage.prototype.response = null;

        /**
         * Creates a new WebSocketMessage instance using the specified properties.
         * @function create
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.IWebSocketMessage=} [properties] Properties to set
         * @returns {signalservice.WebSocketMessage} WebSocketMessage instance
         */
        WebSocketMessage.create = function create(properties) {
            return new WebSocketMessage(properties);
        };

        /**
         * Encodes the specified WebSocketMessage message. Does not implicitly {@link signalservice.WebSocketMessage.verify|verify} messages.
         * @function encode
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.IWebSocketMessage} message WebSocketMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                $root.signalservice.WebSocketRequestMessage.encode(message.request, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                $root.signalservice.WebSocketResponseMessage.encode(message.response, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WebSocketMessage message, length delimited. Does not implicitly {@link signalservice.WebSocketMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.IWebSocketMessage} message WebSocketMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebSocketMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebSocketMessage message from the specified reader or buffer.
         * @function decode
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {signalservice.WebSocketMessage} WebSocketMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.signalservice.WebSocketMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.request = $root.signalservice.WebSocketRequestMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.response = $root.signalservice.WebSocketResponseMessage.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebSocketMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {signalservice.WebSocketMessage} WebSocketMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebSocketMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebSocketMessage message.
         * @function verify
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebSocketMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.request != null && message.hasOwnProperty("request")) {
                let error = $root.signalservice.WebSocketRequestMessage.verify(message.request);
                if (error)
                    return "request." + error;
            }
            if (message.response != null && message.hasOwnProperty("response")) {
                let error = $root.signalservice.WebSocketResponseMessage.verify(message.response);
                if (error)
                    return "response." + error;
            }
            return null;
        };

        /**
         * Creates a WebSocketMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {signalservice.WebSocketMessage} WebSocketMessage
         */
        WebSocketMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.signalservice.WebSocketMessage)
                return object;
            let message = new $root.signalservice.WebSocketMessage();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "REQUEST":
            case 1:
                message.type = 1;
                break;
            case "RESPONSE":
            case 2:
                message.type = 2;
                break;
            }
            if (object.request != null) {
                if (typeof object.request !== "object")
                    throw TypeError(".signalservice.WebSocketMessage.request: object expected");
                message.request = $root.signalservice.WebSocketRequestMessage.fromObject(object.request);
            }
            if (object.response != null) {
                if (typeof object.response !== "object")
                    throw TypeError(".signalservice.WebSocketMessage.response: object expected");
                message.response = $root.signalservice.WebSocketResponseMessage.fromObject(object.response);
            }
            return message;
        };

        /**
         * Creates a plain object from a WebSocketMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {signalservice.WebSocketMessage} message WebSocketMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebSocketMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.request = null;
                object.response = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.signalservice.WebSocketMessage.Type[message.type] === undefined ? message.type : $root.signalservice.WebSocketMessage.Type[message.type] : message.type;
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = $root.signalservice.WebSocketRequestMessage.toObject(message.request, options);
            if (message.response != null && message.hasOwnProperty("response"))
                object.response = $root.signalservice.WebSocketResponseMessage.toObject(message.response, options);
            return object;
        };

        /**
         * Converts this WebSocketMessage to JSON.
         * @function toJSON
         * @memberof signalservice.WebSocketMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebSocketMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WebSocketMessage
         * @function getTypeUrl
         * @memberof signalservice.WebSocketMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WebSocketMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/signalservice.WebSocketMessage";
        };

        /**
         * Type enum.
         * @name signalservice.WebSocketMessage.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} REQUEST=1 REQUEST value
         * @property {number} RESPONSE=2 RESPONSE value
         */
        WebSocketMessage.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "REQUEST"] = 1;
            values[valuesById[2] = "RESPONSE"] = 2;
            return values;
        })();

        return WebSocketMessage;
    })();

    return signalservice;
})();

export { $root as default };
